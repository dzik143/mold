################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

# ------------------------------------------------------------------------------
#                                  Constants
# ------------------------------------------------------------------------------

# TODO: Clean up this mess.
SYSCALL_ID_TO_C_FUNCTION_MAP = {
  '2': '__MOLD_FileOpenForRead',   # 2
  '3': '__MOLD_FileOpenForWrite',  # 3
  '4': '__MOLD_FileOpenForCreate', # 4
  '5': '__MOLD_FileClose',         # 5

  '8':  '__MOLD_FileReadInt8',      # 8
  '9':  '__MOLD_FileReadInt16',     # 9
  '10': '__MOLD_FileReadInt32',     # 10
  '11': '__MOLD_FileReadInt64',     # 11

  '14': '__MOLD_FileReadFloat32',   # 14
  '15': '__MOLD_FileReadFloat64',   # 15
  '16': '__MOLD_FileReadBool8',     # 16
  '17': '__MOLD_FileReadBool16',    # 17
  '18': '__MOLD_FileReadBool32',    # 18
  '19': '__MOLD_FileReadBool64',    # 19
  '20': '__MOLD_FileReadChar',      # 20

  '21': '__MOLD_FileWriteBinary8',   # 21
  '22': '__MOLD_FileWriteBinary16',  # 22
  '23': '__MOLD_FileWriteBinary32',  # 23
  '24': '__MOLD_FileWriteBinary64',  # 24
  '25': '__MOLD_FileWriteBinary128', # 25

  '29': '__MOLD_FileLoad',      # 29

  '30': '__MOLD_EmptySyscall',  # 30

  '31': '__MOLD_Ord',           # 31
  '32': '__MOLD_Asc',           # 32
  '33': '__MOLD_ParseInteger',  # 33
  '34': '__MOLD_ParseFloat',    # 34

  '35': '__MOLD_Bitand',        # 35
  '36': '__MOLD_Bitor',         # 36
  '37': '__MOLD_Bitxor',        # 37
  '38': '__MOLD_Bitnot',        # 38

  '39': '__MOLD_CallExternal',  # 39

  '40': '__MOLD_Exit',          # 40
  '41': '__MOLD_Die',           # 41
  '42': '__MOLD_Str',           # 42
  '43': '__MOLD_Len',           # 43
  '44': '__MOLD_Typeof',        # 44

  '45': '__MOLD_VariantPrint',  # 45
  '46': '__MOLD_Warning',       # 46

  '50': '__MOLD_ArrayInsertAfterLast',
  '51': '__MOLD_ArrayInsertBeforeFirst',

  '55': '__MOLD_SubStr',
  '56': '__MOLD_InnerTypeOf',
  '57': '__MOLD_GetTypeId',
  '58': '__MOLD_BuildString'
}

const MIR_COMPARE_FLAGS = ['eq', 'ne', 'lt', 'ge', 'le', 'gt']

MIR_TO_C_TYPE_MAP = {
  'variant': 'Variant_t',
  'string':  'Variant_t',
  'int32':   'int32_t',
  'int64':   'int64_t',
  'float32': 'float32_t',
  'float64': 'float64_t',
  'bool32':  'bool32_t'
}

# Used during conversion: variant -> primitive.
# Read needed minimum.
MIR_TO_C_VARIANT_VALUE_AS_MAP = {
  'int32':   'valueAsInt32',
  'int64':   'valueAsInt64',
  'float32': 'valueAsFloat32',
  'float64': 'valueAsFloat64',
  'bool32':  'valueAsInt32'
}

# Used during conversion: primitive -> variant.
# Store as many as possible to avoid unexpected beheaviors:
# - non zeroed higher 32-bit,
# - not extended sign bits etc.
MIR_TO_C_VARIANT_VALUE_AS_MAP_WRITE = {
  'int32':   'valueAsInt64',
  'int64':   'valueAsInt64',
  'float32': 'valueAsFloat32',
  'float64': 'valueAsFloat64',
  'bool32':  'valueAsInt64'
}

MIR_TO_VARIANT_TYPE = {
  'int32':   'VARIANT_INTEGER',
  'int64':   'VARIANT_INTEGER',
  'float32': 'VARIANT_FLOAT',
  'float64': 'VARIANT_DOUBLE',
  'bool32':  'VARIANT_BOOLEAN'
}

# ------------------------------------------------------------------------------
#                        CodeGenerator for C target
# ------------------------------------------------------------------------------

class CodeGeneratorC
  method constructor()
    this.symbols             = {}
    this.globals             = {}
    this.isProfilerEnabled   = false
    this.mapOfEmittedBuffers = {}
    this.isBufferEmitted     = {}
  endmethod

  method _getSymbolType(id) -> rv
    global SYMBOL_KIND_LABEL

    if id is string
      rv = 'variant'
      symbolInfo = this.symbols{id}

      if symbolInfo is defined
        if symbolInfo.type is defined
          rv = symbolInfo.type

        elif symbolInfo.kind is SYMBOL_KIND_LABEL
          rv = 'label'
        endif
      endif

    elif id is integer
      if (id < -2147483648) or (id > 2147483647)
        rv = 'int64'
      else
        rv = 'int32'
      endif

    elif id is float
      rv = 'float64'

    elif id is boolean
      rv = 'bool32'

    else
      rv = 'custom'
    endif
  endmethod

  method variantDestroy(x)
    global SYMBOL_KIND_VAR_LOCAL
    global SYMBOL_KIND_VAR_GLOBAL
    global SYMBOL_KIND_VAR_RETVAL

    xInfo = this.symbols{x}

    if xInfo.usedAsIterator is @all(defined, true)
      # Symbol is used as loop iterator.
      # It's only dump reference for existing box values or keys.
      print '  // Skipped destroying loop iterator', x

    elif xInfo.kind is @any(SYMBOL_KIND_VAR_LOCAL,
                            SYMBOL_KIND_VAR_GLOBAL,
                            SYMBOL_KIND_VAR_RETVAL)

      if xInfo.type is @any('string', 'variant')
        if xInfo.kind is SYMBOL_KIND_VAR_RETVAL
          print `  __MOLD_VariantDestroy(${x});`
        else
          print `  __MOLD_VariantDestroy(&${x});`
        endif
      endif
    endif
  endmethod

  method _hash(x) -> rv
    # TODO: Optimize it.
    rv = typeof(x) ~ ':'

    if x is array
      rv = rv ~ str(len(x)) ~ ':'
      for values item in x
        rv = rv ~ this._hash(item)
      endfor

    else
      rv = rv ~ str(x)
    endif

    rv = rv ~ ';'
  endmethod

  method emitConstant(name, value, wantDeepIdx, deepIdx, isAnonymouse)
    isContentEmmited = false

    if wantDeepIdx is deepIdx
      bufferName = null

      if value is @any(array, string)
        # Check did we emit another buffer with the same content.
        hash       = this._hash(value)
        bufferName = this.mapOfEmittedBuffers{hash}

        if bufferName is defined
          # Buffer is already emited.
          # Just use it for another variable.
          print '// Reuse already emitted buffer'
          this.isBufferEmitted{name} = true

        else
          # Buffer is unique at this moment.
          # Generate new buffer name and go on.
          bufferName = `${name}_buffer`

          # Save buffer name for further calls.
          this.mapOfEmittedBuffers{hash} = bufferName
        endif
      endif

      if isAnonymouse is false
        print 'Variant_t', name, '='
      endif

      # Dispatch type.
      if value is integer
        print '  { VARIANT_INTEGER, 0,', value, '}'

      elif value is float
        print '  { VARIANT_DOUBLE, 0, valueAsFloat64:', value, '}'

      elif value is string
        print '  { VARIANT_STRING, 0, (uint64_t) &', bufferName, '}'

      elif value is array
        print '  { VARIANT_ARRAY, 0, (uint64_t) &', bufferName, '}'

      elif value is boolean
        if value is true
          valueAsInteger = '1'
        else
          valueAsInteger = '0'
        endif

        print '  { VARIANT_BOOLEAN, 0,', valueAsInteger, '}'

      elif value is undefined
        print '  { 0, 0, 0 }'

      else
        die('error: unhandled type: ' ~ typeof(value))
      endif

      if isAnonymouse is true
        print ','
      else
        print ';'
      endif
    endif


    # Emit buffer content for complex variables.
    if value is array
      this.emitArrayBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    elif value is string
      this.emitStringBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitStringBufferHead(name, value, wantDeep, deepIdx)
    if this.isBufferEmitted{name} is undefined
      if wantDeep is deepIdx
        bufferName      = name ~ '_buffer'
        bufferNameBytes = name ~ '_bufferBytes'
        print  'Buffer_t', bufferName, '= {', len(value) + 1, ', -1, 0, &', bufferNameBytes, '};'
      endif
    endif

    this.emitStringBufferContent(name, value, wantDeep, deepIdx + 1)
  endmethod

  method emitStringBufferContent(name, value, wantDeep, deepIdx)
    if wantDeep is deepIdx
      bufferNameBytes = `${name}_bufferBytes`
      stringLen       = len(value)

      # TODO: Handle 64-bit strings.
      bytesAsText = str(bitand(stringLen, 0xff))
      bytesAsText = bytesAsText ~ ',' ~ str(bitand(stringLen // 0xff     , 0xff))
      bytesAsText = bytesAsText ~ ',' ~ str(bitand(stringLen // 0xffff   , 0xff))
      bytesAsText = bytesAsText ~ ',' ~ str(bitand(stringLen // 0xffffff , 0xff))
      bytesAsText = bytesAsText ~ ',0,0,0,0  '

      for values character in value
        bytesAsText = bytesAsText ~ ',' ~ str(ord(character))
      endfor

      print `uint8_t ${bufferNameBytes}[] = { ${bytesAsText}, 0 };`
    endif
  endmethod

  method emitArrayBufferHead(name, items, wantDeepIdx, deepIdx)
    if this.isBufferEmitted{name} is undefined
      if wantDeepIdx is deepIdx
        itemsCnt        = len(items)
        bufferName      = name ~ '_buffer'
        bufferNameBytes = name ~ '_bufferBytes'

        print 'Buffer_t', bufferName, ' = {', itemsCnt * 16, ', -1, 0, &', bufferNameBytes, '};'
      endif

      this.emitArrayBufferContent(name, items, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitArrayBufferContent(name, items, wantDeepIdx, deepIdx)
    itemsCnt = len(items)

    if wantDeepIdx is deepIdx
      # TODO: Optimize it.
      # TODO: Move innerType check to earliear stage.
      innerType        = typeof(items[0])
      innerSize        = 0
      innerTypeForEmit = '0'
      structName       = 'Array_int8_t'
      innerValueMin    = items[0] # TODO: Use MAX_INTEGER like const?
      innerValueMax    = items[0] # TODO: Use MIN_INTEGER like const?
      innerItemIdx     = 0
      itemValue        = null

      goOn = true

      while (goOn is true) and (innerItemIdx < itemsCnt)
        itemValue = items[innerItemIdx]
        itemType  = typeof(itemValue)

        if itemType isnt innerType
          # Various types in one array.
          # Fall-back to variant storage and don't go anymore.
          innerTypeForEmit = '0'
          structName       = 'Array_t'
          goOn             = false

        elif itemType is 'integer'
          innerTypeForEmit = 'VARIANT_INTEGER'

          # Track max/min values to compact array storage.
          if (innerSize < 3) and ((itemValue < -2147483648) or (itemValue > 2147483647))
           # 2^3 bytes = 8 bytes = 64 bit (qword)
           innerSize  = 3
           structName = 'Array_int64_t'

          elif (innerSize < 2) and ((itemValue < -32768) or (itemValue > 32767))
           # 2^2 bytes = 4 bytes = 32 bit (dword)
           innerSize  = 2
           structName = 'Array_int32_t'

          elif (innerSize < 2) and ((itemValue < -128) or (itemValue > 127))
           # 2^1 bytes = 2 bytes = 16 bit (word)
           innerSize  = 1
           structName = 'Array_int16_t'
          endif

        else
          # Non-integer primitive.
          # Fall-back to variant storage and don't go anymore.
          # TODO: Don't duplcate code.
          # TODO: Handle non-integer primitives in const arrays.
          innerTypeForEmit = '0'
          structName       = 'Array_t'
          goOn             = false
        endif

        # Go to next item.
        innerItemIdx = innerItemIdx + 1
      endwhile

      # print '; innerType:'     , innerType
      # print '; innerValueMin:' , innerValueMin
      # print '; innerValueMax:' , innerValueMax

      bufferName      = `${name}_buffer`
      bufferNameBytes = `${name}_bufferBytes`

      print structName, bufferNameBytes, '= {'
      print ' ', innerTypeForEmit, ', // inner type'
      print ' ', innerSize, ', // inner size'
      print '  0, 0, 0, // reserved'
      print ' ', itemsCnt, ', // itemsCnt'
      print '  items: {'

      # Emit items as flat array if possible.
      if innerTypeForEmit isnt '0'
        sep = ' '

        for itemIdx in 0 .. itemsCnt
          __mold_printToStdOutput(sep)

          if items[itemIdx] is defined
            __mold_printToStdOutput(items[itemIdx])
          else
            __mold_printToStdOutput('0')
          endif

          sep = ', '
        endfor
        print ''

        # Don't go on recursively.
        itemsCnt = -1
      endif
    endif

    # Go on recursively for variant arrays.
    for itemIdx in 0 .. itemsCnt
      this.emitConstant(`${name}_${itemIdx}`, items[itemIdx], wantDeepIdx, deepIdx, true)
    endfor

    # Close C array.
    if wantDeepIdx is deepIdx
      print '}};'
      print ''
    endif
  endmethod

  method _declareVar(symbolInfo)
    global SYMBOL_KIND_VAR_RETVAL

    mirType = symbolInfo.type
    name    = symbolInfo.name

    if symbolInfo.writeHits is 0
      print '  // Skipped unused variable', name

    elif mirType is @any('variant', 'string')
      if symbolInfo.kind isnt SYMBOL_KIND_VAR_RETVAL
        print '  Variant_t', name, '= {0};'
      else
        print `  // Skipped non-primitive return value '${name}' (passed via pointer)`
      endif

    elif mirType is 'int64'
      print '  int64_t', name, '= 0;'

    elif mirType is 'int32'
      print '  int32_t', name, '= 0;'

    elif mirType is 'float64'
      print '  float64_t', name, '= 0.0;'

    elif mirType is 'bool32'
      print '  bool32_t', name, '= 0;'

    else
      die(`error: unhandled MIR type: ${mirType}`)
    endif
  endmethod

  method _renderFunctionProto(proto, emitForVCall) -> rv
    global MIR_TO_C_TYPE_MAP

    # Init C function proto.
    if emitForVCall is true
      # We're going to emit VCall wrapper over ordinary call.
      # Both return value and all parameters are converted to variants.
      # TODO: Handle non-variant return type for VCalls ?
      returnTypeForC = 'Variant_t'

    elif proto.rv is defined
      # Ordinary function with return type.
      symbolInfo     = proto.symbols{proto.rv}
      returnTypeForC = MIR_TO_C_TYPE_MAP{symbolInfo.type}

    else
      # Ordinary function without return type.
      returnTypeForC = 'void'
    endif

    # Add the first this parameter for class methods.
    if proto.symbols{'this'} is defined
      paramsProtoForC = 'Variant_t *this'
      sep = ', '
    else
      paramsProtoForC = ''
      sep = ''
    endif

    # Pass variant return value via pointer.
    if returnTypeForC is 'Variant_t'
      # Move return value into the first param (out).
      # TODO: Use rvName = @any(...) if ready?
      rvName = proto.rv
      if rvName is undefined
        rvName = '__anonymousRv'
      endif

      paramsProtoForC = 'Variant_t *' ~ rvName ~ sep ~ paramsProtoForC
      returnTypeForC  = 'void'
      sep             = ', '
    endif

    # Build params for ordinary call.
    # Possible primitive types.
    for values paramName in proto.params
      if emitForVCall is true
        symbolTypeC = 'Variant_t'
      else
        symbolInfo  = proto.symbols{paramName}
        symbolTypeC = MIR_TO_C_TYPE_MAP{symbolInfo.type}
      endif

      # Expect variant types passed via pointers.
      # Possible improvement: Simlify it?
      if symbolTypeC is 'Variant_t'
        symbolTypeC = 'Variant_t*'
      endif

      paramsProtoForC = paramsProtoForC ~ `${sep}${symbolTypeC} ${paramName}`
      sep = ', '
    endfor

    # TODO: Why sometimes we get fullName and sometimes name?
    if emitForVCall is true
      nameForC = '__vcall' ~ proto.name

    elif proto.fullName is defined
      nameForC = proto.fullName

    else
      nameForC = proto.name
    endif

    # Build final C function proto:
    # Example: int foo(double x, Variant_t *y)
    rv = `${returnTypeForC} ${nameForC}(${paramsProtoForC})`
  endmethod

  method _getSymbolInfo(x) -> rv
    rv = this.symbols{x}
    if rv is undefined
      rv = this.globals{x}
    endif
  endmethod

  method _getParamForCall(x) -> rv
    global SYMBOL_KIND_VAR_PARAM
    global SYMBOL_KIND_VAR_RETVAL

    rv = x

    if x is defined
      if x is @any(integer, float, boolean)
        rv = str(x)

      elif rv is string
        symbolInfo = this._getSymbolInfo(x)

        if ((symbolInfo is defined) and
            (symbolInfo.type is @any(undefined, 'variant', 'string')) and
            (symbolInfo.kind isnt @all(SYMBOL_KIND_VAR_PARAM, SYMBOL_KIND_VAR_RETVAL)))
          # Always pass variants via pointers.
          # For call params and return value & operator is unneded,
          # bacuse we already have pointers available.
          # as pointers.
          rv = `&${x}`

        elif rv is '__TrashBin'
          # Special case. This symbol is not defined in symbols table, but
          # used internally as NULL output if one of output variable isnt used
          # in ForEach loops.
          # Possbile improvement: Simplify it?
          rv = `&${x}`
        endif
      endif

    else
      rv = '&__undefined'
    endif
  endmethod

  method _buildCallList(params) -> rv
    rv  = ''
    sep = ''

    for values oneParam in params
      rv  = rv ~ sep ~ this._getParamForCall(oneParam)
      sep = ', '
    endfor
  endmethod

  method run(codeObj)
    global SYMBOL_KIND_VAR_LOCAL, SYMBOL_KIND_VAR_GLOBAL, SYMBOL_KIND_CONST
    global SYMBOL_KIND_VAR_PARAM, SYMBOL_KIND_JMP_TABLE, SYMBOL_KIND_VAR_RETVAL
    global SYMBOL_KIND_FUNCTION

    global REG_PARAMS_CNT, REG_PARAMS32, REG_PARAMS64
    global MIR_TO_VARIANT_TYPE_MAP, MIR_TYPE_SIZE_MAP
    global _VARIANT_INTEGER
    global _VARIANT_STRING
    global _VARIANT_DOUBLE
    global _VARIANT_BOOLEAN

    global MIR1_OPCODE_COMMENT, MIR1_OPCODE_LABEL
    global MIR1_OPCODE_PROC, MIR1_OPCODE_ENDP
    global MIR1_OPCODE_MOVE, MIR1_OPCODE_CONV
    global MIR1_OPCODE_NEG, MIR1_OPCODE_ADD, MIR1_OPCODE_SUB
    global MIR1_OPCODE_MUL, MIR1_OPCODE_DIV, MIR1_OPCODE_IDIV
    global MIR1_OPCODE_CMP_EQ, MIR1_OPCODE_CMP_NE, MIR1_OPCODE_CMP_LT
    global MIR1_OPCODE_CMP_LE, MIR1_OPCODE_CMP_GT, MIR1_OPCODE_CMP_GE
    global MIR1_OPCODE_CMP_IS_TYPEOF, MIR1_OPCODE_CMP_IS_NOT_TYPEOF
    global MIR1_OPCODE_JMP_IF_TYPEOF, MIR1_OPCODE_JMP_IF_NOT_TYPEOF
    global MIR1_OPCODE_JMP, MIR1_OPCODE_JMP_BY_TABLE
    global MIR1_OPCODE_JMP_IF_TRUE, MIR1_OPCODE_JMP_IF_FALSE
    global MIR1_OPCODE_JMP_IF_EQ, MIR1_OPCODE_JMP_IF_NE
    global MIR1_OPCODE_JMP_IF_LT, MIR1_OPCODE_JMP_IF_LE
    global MIR1_OPCODE_JMP_IF_GT, MIR1_OPCODE_JMP_IF_GE
    global MIR1_OPCODE_CALL, MIR1_OPCODE_VCALL, MIR1_OPCODE_SYSCALL
    global MIR1_OPCODE_RET, MIR1_OPCODE_INNER_RET
    global MIR1_OPCODE_NOP, MIR1_OPCODE_STRING_JOIN
    global MIR1_OPCODE_LOAD_NULL, MIR1_OPCODE_PRINT
    global MIR1_OPCODE_CREATE_OBJECT, MIR1_OPCODE_CREATE_ARRAY
    global MIR1_OPCODE_CREATE_MAP
    global MIR1_OPCODE_STORE_INDEX, MIR1_OPCODE_LOAD_INDEX
    global MIR1_OPCODE_STORE_KEY, MIR1_OPCODE_LOAD_KEY
    global MIR1_OPCODE_CREATE_VARIANT_FROM, MIR1_OPCODE_CAST_VARIANT_TO
    global MIR1_OPCODE_INIT_FRAME
    global MIR1_OPCODE_CMP_CC_GROUP, MIR1_OPCODE_JMP_IF_CC_GROUP
    global MIR_COMPARE_FLAGS_FOR_INTEGERS, MIR_COMPARE_FLAGS_FOR_FLOATS
    global MIR_ALU_OPCODES_FOR_INTEGERS, MIR_ALU_OPCODES_FOR_FLOATS
    global MIR1_OPCODE_ALU2_GROUP

    global MIR1_FIRST_DST_OP_X_Y_OPCODE
    global MIR1_FIRST_CALL_LIKE_OPCODE
    global MIR1_FIRST_CUSTOM_OPCODE

    global SYSCALL_ID_TO_C_FUNCTION_MAP
    global MIR_COMPARE_FLAGS
    global MIR_TO_C_TYPE_MAP
    global MIR_TO_C_VARIANT_VALUE_AS_MAP
    global MIR_TO_C_VARIANT_VALUE_AS_MAP_WRITE
    global MIR_TO_VARIANT_TYPE
    global MIR1_OPCODE_BUILD_STRING

    print '#include <Mold.h>'

    print '// -----------------------------------------------------------------------------'
    print '//                                 Data section'
    print '// -----------------------------------------------------------------------------'

    this.globals = codeObj.symbolTable.exportSymbols()

    print ''
    print '// Global vars'
    print '// -----------'

    for values oneItem in this.globals where oneItem.kind is SYMBOL_KIND_VAR_GLOBAL
      this._declareVar(oneItem)
    endfor

    #
    # TODO: Dump constant data to another section to catch access
    # violation on write attemp.
    #

    print '// Constants'
    print '// ---------'

    # TODO: Clean up this mess.
    print 'Variant_t __undefined = { 0 };'

    # TODO: Optimize it.
    # TODO: Use reverse for with step.
    deepIdx = 16
    while deepIdx > 0
      deepIdx = deepIdx - 1

      # print '// iter', deepIdx

      for values symbolInfo in this.globals
        if ((symbolInfo.kind is SYMBOL_KIND_CONST) and
            (symbolInfo.readHits > 0))
          name  = symbolInfo.name
          value = symbolInfo.value
          this.emitConstant(name, value, deepIdx, 0, false)
        endif
      endfor
    endwhile

    # Emit vtables forward declarations.

    print ''
    print '// forward declarations: vtables'
    print '// -----------------------------'

    classList = codeObj.classList

    for values oneClassProto in classList
      print 'extern void *__vtable_' ~ oneClassProto.name, '[];'
    endfor

    # Emit functions forward declarations.

    print ''
    print '// forward declarations: functions'
    print '// -------------------------------'

    for values oneItem in this.globals
      if oneItem.kind is SYMBOL_KIND_FUNCTION
        if oneItem.proto.builtIn is @any(undefined, false)
          print this._renderFunctionProto(oneItem.proto, false), ';'
        endif
      endif
    endfor

    print '// -----------------------------------------------------------------------------'
    print '//                                 Code section'
    print '// -----------------------------------------------------------------------------'

    #
    # Fetch code and code metas.
    #

    quads = codeObj.quads

    currentProcProto  = null
    currentProcName   = null
    currentProcRv     = null
    currentProcRvType = null
    currentSymbols    = {}

    # Split local vars into 2 groups:
    # - varsToFree[] - potentally needs to be free on call exit,
    # - varsToDrop[] - can be dropped safely without memory leak.
    varsToFree = []
    varsToDrop = []

    isInsideVcall = false

    dst = null
    x   = null
    y   = null

    opcode         = 0
    originalOpcode = 0
    paramsCnt      = 0

    #
    # Translate code section.
    #

    for values item in quads
      # Fetch instruction
      itemCnt = len(item)
      opcode  = item[0]
      dst     = item[1]
      x       = item[2]
      y       = item[3]

      dstType = this._getSymbolType(dst)
      xType   = this._getSymbolType(x)
      yType   = this._getSymbolType(y)

      dstForCall = this._getParamForCall(dst)
      xForCall   = this._getParamForCall(x)
      yForCall   = this._getParamForCall(y)

      opcodeAsText = MIR1_GetOpcodeAsText(opcode)

      if opcode isnt @all(MIR1_OPCODE_COMMENT,
                          MIR1_OPCODE_PROC,
                          MIR1_OPCODE_INIT_FRAME)

        print `  // [C] ${opcodeAsText}(${opcode}) dst=${dst}, x=${x}, y=${y}`
      endif

      isOpcodeHandled = true

      # ----------------------------------------------------------------------
      #                   Opcodes with custom handlers
      # ----------------------------------------------------------------------

      if opcode >= MIR1_FIRST_CUSTOM_OPCODE

        if opcode is MIR1_OPCODE_CREATE_ARRAY
          if x is defined
            print `  __MOLD_VariantArrayCreateFromInitList(${dstForCall}, ${xForCall});`
          else
            print `  __MOLD_VariantArrayCreate(${dstForCall});`
          endif

        elif opcode is MIR1_OPCODE_CREATE_MAP
          if x is defined
            print `  __MOLD_VariantMapCreateFromInitList(${dstForCall}, ${xForCall}, ${yForCall});`
          else
            print `  __MOLD_VariantMapCreate(${dstForCall});`
          endif

        elif opcode is MIR1_OPCODE_JMP_BY_TABLE
          symbolInfo = codeObj.symbolTable.lookup(dst)

          # Emit jmp table.
          labels       = symbolInfo.labels
          defaultLabel = symbolInfo.defaultLabel

          print '  static void *', symbolInfo.name, '[] = {'

          # TODO: Remove out-of-range labels at earlier stage.
          for labelIdx in symbolInfo.valueMin .. symbolInfo.valueMax + 1
            nextLabel = labels[labelIdx]

            if nextLabel is undefined
              print `   && ${defaultLabel}, // ${labelIdx} (otherwise)`
            else
              print `   && ${nextLabel}, // ${labelIdx}`
            endif
          endfor

          print `   && ${defaultLabel} // explicit default case`
          print '  };'
          print ''

          # Emit goto by table.
          # if (x - valueMin > valueMax - valueMin) {
          #   goto dst[defaultLabel];
          # } else {
          #   goto *dst[x];
          # }
          valueMax   = symbolInfo.valueMax
          valueMin   = symbolInfo.valueMin
          valueRange = valueMax - valueMin

          print `  if ((uint32_t) ${x} - ${valueMin} > ${valueRange}) {`
          print `    goto ${defaultLabel};`
          print '  } else {'
          print `    goto *${dst}[${x} - ${valueMin}];`
          print '  }'

        elif opcode is MIR1_OPCODE_STRING_JOIN
          print `  __MOLD_VariantStringJoin(${dstForCall}, ${xForCall}, ${yForCall});`

        elif opcode is @any(MIR1_OPCODE_CMP_IS_TYPEOF,
                            MIR1_OPCODE_CMP_IS_NOT_TYPEOF,
                            MIR1_OPCODE_JMP_IF_TYPEOF,
                            MIR1_OPCODE_JMP_IF_NOT_TYPEOF)

          if xType is 'variant'
            if opcode is MIR1_OPCODE_CMP_IS_TYPEOF
              print `  ${dst} = (${xForCall}) -> type == ${y};`

            elif opcode is MIR1_OPCODE_CMP_IS_NOT_TYPEOF
              print `  ${dst} = (${xForCall}) -> type != ${y};`

            elif opcode is MIR1_OPCODE_JMP_IF_TYPEOF
              print `  if ((${xForCall}) -> type == ${y}) goto ${dst};`

            elif opcode is MIR1_OPCODE_JMP_IF_NOT_TYPEOF
              print `  if ((${xForCall}) -> type != ${y}) goto ${dst};`
            endif

          else
            # TODO: Resolve at earlier stage.
            cmpResult = false

            if xType is 'float64'
              cmpResult = y is _VARIANT_DOUBLE

            elif xType is 'int32'
              cmpResult = y is _VARIANT_INTEGER

            elif xType is 'bool32'
              cmpResult = y is _VARIANT_INTEGER

            elif xType is 'string'
              cmpResult = y is _VARIANT_STRING
            endif

            if opcode is MIR1_OPCODE_CMP_IS_TYPEOF
              print `  ${dst} = ${cmpResult};`

            elif opcode is MIR1_OPCODE_CMP_IS_NOT_TYPEOF
              if cmpResult is true
                print `  ${dst} = false;`
              else
                print `  ${dst} = true;`
              endif

            elif opcode is MIR1_OPCODE_JMP_IF_TYPEOF
              if cmpResult is true
                print `  goto ${dst};`
              endif

            elif opcode is MIR1_OPCODE_JMP_IF_NOT_TYPEOF
              if cmpResult is false
                print `  goto ${dst};`
              endif
            endif
          endif

        elif opcode is MIR1_OPCODE_CREATE_OBJECT
          print `  __MOLD_VariantObjectCreate(${dstForCall}, __vtable_${x});`

        elif opcode is MIR1_OPCODE_STORE_INDEX
          # dst[x] := y
          print `  __MOLD_VariantStoreAtIndex_${yType}(${dstForCall}, ${xForCall}, ${yForCall});`

        elif opcode is MIR1_OPCODE_STORE_KEY
          # dst{x} := y
          print `  __MOLD_VariantStoreAtKey_${yType}(${dstForCall}, ${xForCall}, ${yForCall});`

        elif opcode is MIR1_OPCODE_COMMENT
          print '//', dst

        elif opcode is MIR1_OPCODE_LABEL
          # TODO: Clean up this mess.
          # TODO: Better way to detect inner function.
          # TODO: Implement substr() like function.
          if (dst[0] is 'l') and (dst[1] is 'o')
            # Inner function begin: loopBegin_lxxx:
            print `  void ${dst}() {`

          else
            # General case: lxxx:
            print dst, ':;'
          endif

        elif opcode is MIR1_OPCODE_JMP
          # TODO: Clean up this mess.
          if dst is '__MOLD_PrintErrorAndDie.notImplemented'
            print '  __MOLD_PrintErrorAndDie_notImplemented();'
            print '}'

          else
            print `  goto ${dst};`
          endif

        elif opcode is MIR1_OPCODE_LOAD_NULL
          # TODO: Review it?
          # this.variantDestroy(dst)
          print `  (${dstForCall}) -> type  = VARIANT_UNDEFINED;`

        elif opcode is @any(MIR1_OPCODE_PRINT,
                            MIR1_OPCODE_BUILD_STRING)
          params   = dst
          fmt      = ''
          callList = ''

          if opcode is MIR1_OPCODE_BUILD_STRING
            params = x
          endif

          for values oneParam in params
            if oneParam is @all(string, '__EOL')
              token = '!'

            elif oneParam is @all(string, '@glued')
              token = '~'

            else
              mirType  = this._getSymbolType(oneParam)

              if mirType is 'int64'
                token = 'I'
              else
                token = mirType[0]
              endif

              callList = callList ~ ',' ~ this._getParamForCall(oneParam)
            endif

            fmt = fmt ~ token
          endfor

          if opcode is MIR1_OPCODE_BUILD_STRING
            print ' ', dst, '= __MOLD_BuildString("' ~  fmt ~ '"', callList, ');'
          else
            print '  __MOLD_PrintFormat("' ~ fmt ~  '!"', callList, ');'
          endif

        elif opcode is MIR1_OPCODE_PROC
          # Remember info about current procedure.
          currentProcProto = item[1]
          currentProcName  = currentProcProto.name
          currentProcRv    = currentProcProto.rv
          currentSymbols   = currentProcProto.symbols
          isInsideVcall    = currentSymbols{'this'} is defined

          if currentProcRv is defined
            currentProcRvType = currentSymbols{currentProcRv}.type
          endif

          # Ordinary entry point.
          # This address can be called directly with primitive params.
          print this._renderFunctionProto(currentProcProto, false), '{'

          # Profiler code if needed.
          if this.isProfilerEnabled is true
            die('C: Profiler not implemented')
          endif

          # Extra guard against calling method on non-object e.g.
          # obj = new A()
          # obj = null
          # obj.foo()
          # Possible improvement: Optimize it.
          if isInsideVcall is true
            print '  if (this -> type != VARIANT_OBJECT) __MOLD_PrintErrorAndDie_vcallOnNonObject();'
          endif

        elif opcode is MIR1_OPCODE_INIT_FRAME
          currentFrame = dst
          symbols      = currentFrame.symbols
          params       = currentFrame.params

          # Clean up this mess.
          this.symbols = symbols

          # Split local vars into 2 groups:
          # - varsToFree[] - potentally needs to be free on call exit,
          # - varsToDrop[] - can be dropped safely without memory leak.
          varsToFree = []
          varsToDrop = []

          for values oneItem in symbols
            if oneItem.kind is SYMBOL_KIND_VAR_RETVAL
              # Don't free return variable - should be passed to caller.
              varsToDrop[@afterlast] = oneItem

            elif oneItem.kind is SYMBOL_KIND_VAR_LOCAL
              if oneItem.type is @any(undefined, 'string', 'variant')
                # Variant local variables.
                # It's potentially complex boxes with dynamically allocated
                # buffer inside.
                # Should be freed on call exit.
                varsToFree[@afterlast] = oneItem
              else
                # Primitives - can be dropped without memory leak.
                varsToDrop[@afterlast] = oneItem
              endif
            endif
          endfor

          if len(varsToFree) > 0
            print '  // Local variables (to be freed on exit)'
            print '  __MOLD_StackAlloc(', len(varsToFree), ');'
            for indexes idx values oneItem in varsToFree
              print '  #define', oneItem.name, `(__MOLD_StackPtr[${idx}])`
            endfor
          endif

          if len(varsToDrop) > 0
            print '  // Local variables (to be drop on exit)'
            for values oneItem in varsToDrop
              this._declareVar(oneItem)
            endfor
          endif

        elif opcode is MIR1_OPCODE_MOVE
          if xType is @any('variant', 'string')
            # Complex value - use function call.
            print `  __MOLD_VariantMove(${dstForCall}, ${xForCall});`

          else
            # Primitive value - set value directly.
            print `  ${dst} = ${x};`
          endif

        elif opcode is MIR1_OPCODE_NOP
          print '  // nop'

        elif opcode is MIR1_OPCODE_RET
          if len(varsToFree) > 0
            print '  // Clean up local frame'
            print '  __MOLD_StackFree(', len(varsToFree), ');'
            for indexes idx values oneItem in varsToFree
              print '  #undef', oneItem.name
            endfor
          endif

          # Profiler code if needed.
          if this.isProfilerEnabled is true
            die('C: Profiler not implemented')
          endif

          if currentProcName is 'start'
            print '  // Clean up global frame'
            for values oneItem in currentSymbols
              if oneItem.kind is SYMBOL_KIND_VAR_GLOBAL
                if oneItem.name is @any('argv', 'argc')
                  # Skip argv[] and argc.
                  # They're freed in main entry point function.
                  # TODO: Better way to exclude argv[] and argc.
                else
                  this.variantDestroy(oneItem.name)
                endif
              endif
            endfor
          endif

          if currentProcRv is defined
            if currentProcRvType isnt @all('variant', 'string')
              print '  return', currentProcRv, ';'
            else
              print `  // Skipped non-primitive return value '${currentProcRv}' (passed via pointer)`
            endif
          endif

          print '}'

        elif opcode is MIR1_OPCODE_INNER_RET
          # TODO: Review it?
          print '  }'

        elif opcode is MIR1_OPCODE_ENDP
          # Build vcall wrapper for virtual call if needed.

          if ((isInsideVcall is true) and
              (codeObj.methodsMap{currentProcProto.shortName} is defined))

            # Emit function header with __vcall prefix e.g..
            # Variant_t __vcall_A_foo(Variant_t this, ...) {
            print this._renderFunctionProto(currentProcProto, true), '{'

            # Build params for virtual call.
            if ((currentProcRv is defined) and
                (currentProcRvType is @any('variant', 'string')))
              callList = `${currentProcRv}, this`
            else
              callList = 'this'
            endif

            sep = ', '

            for values paramName in currentProcProto.params
              symbolInfo   = currentSymbols{paramName}
              valueAsField = MIR_TO_C_VARIANT_VALUE_AS_MAP{symbolInfo.type}

              if valueAsField is defined
                paramToPass = `${paramName} -> ${valueAsField}`
              else
                paramToPass = paramName
              endif

              callList = callList ~ sep ~ paramToPass
            endfor

            # TODO: Avoid returning a value for void functions.
            # For now vcall wrapper always return value, because
            # caller always assume there it is.
            if currentProcRvType is defined
              valueAsField = MIR_TO_C_VARIANT_VALUE_AS_MAP_WRITE{currentProcRvType}

              if valueAsField is defined
                # Convert primitive return value into variant if needed.
                # TODO: Handle non-variant return values for vcalls?
                print `  ${currentProcRv} -> type =`, MIR_TO_VARIANT_TYPE{currentProcRvType}, ';'
                print `  ${currentProcRv} -> ${valueAsField} = `
              endif
            endif

            # Call original method as ordinary call.
            print `  ${currentProcName}(${callList});`
            print '}'
          endif

          # TODO: Is it really needed?
          currentProcRvType = null

        else
          isOpcodeHandled = false
        endif

      # ------------------------------------------------------------------------
      #                           Call-like opcodes
      # ------------------------------------------------------------------------

      elif opcode >= MIR1_FIRST_CALL_LIKE_OPCODE
        # dst = x(y, ....)
        nameOrId  = x
        params    = y
        paramsCnt = len(params)

        if ((opcode is MIR1_OPCODE_CALL) and
            (nameOrId is @any('__MOLD_ForDriver_Generic',
                              '__MOLD_ForDriver_IndexesAndValuesInArray',
                              '__MOLD_ForDriver_IndexesAndValuesInArrayOrString',
                              '__MOLD_ForDriver_KeysAndValuesInMap')))

          box      = this._getParamForCall(params[0])
          idxOrKey = params[1]
          value    = params[2]
          cb       = params[3]
          print `  ${nameOrId}(${box}, &${idxOrKey}, &${value}, ${cb});`

        else
          # Push call parameters.
          callList       = ''
          sep            = ''
          hasPrimitiveRv = false

          if (dst is defined) and (opcode isnt MIR1_OPCODE_SYSCALL)
            if dstType is @any('variant', 'string')
              callList     = dstForCall
              sep          = ', '
            else
              hasPrimitiveRv = true
            endif
          endif

          for values oneParam in params
            # TODO: Clean up this mess.
            callList = callList ~ sep ~ this._getParamForCall(oneParam)
            sep      = ', '
          endfor

          # Generate call opcode.
          if opcode is MIR1_OPCODE_SYSCALL
            syscallName = SYSCALL_ID_TO_C_FUNCTION_MAP{str(nameOrId)}

            if dst is defined
              # TODO: Simplify it.
              # TODO: Set return value via pointer?
              # TODO: Move VariantDestroy into vcall dispatcher?
              # Destroy destination if needed.
              this.variantDestroy(dst)
              if dstType is @any('variant', 'string')
              # TODO: Clean up this mess.
                __mold_printToStdOutput(`  *${dstForCall} =`)
              else
                __mold_printToStdOutput(`  ${dst} =`)
              endif
            endif

            if syscallName is defined
              # dst = syscall(id, ...)
              print `  ${syscallName}(${callList});`

            elif nameOrId is string
              if paramsCnt > 0
                print `  __MOLD_SysCall(${nameOrId}, ${callList});`
              else
                print `  __MOLD_SysCall(${nameOrId});`
              endif
            endif

          elif opcode is MIR1_OPCODE_CALL
            # dst = foo(...)
            if hasPrimitiveRv is true
              print `  ${dst} = ${nameOrId}(${callList});`
            else
              print `  ${nameOrId}(${callList});`
            endif

          elif opcode is MIR1_OPCODE_VCALL
            methodId = nameOrId
            protoC   = ''
            sep      = ''

            for indexes idx in params
              protoC = protoC ~ sep ~ 'Variant_t*'
              sep = ','
            endfor

            thisForCall = this._getParamForCall(params[0])

            if dst is undefined
              dst = '__TrashBin'
            endif

            print `  if ((${thisForCall}) -> type != VARIANT_OBJECT) __MOLD_PrintErrorAndDie_vcallOnNonObject();`
            print `  ((void (*)(Variant_t*, ${protoC}))`
            print `  ((Object_t *) (${thisForCall}) -> valueAsBufferPtr -> bytesPtr) -> vtable[${methodId}])`
            print '  (', callList, ');'

          else
            isOpcodeHandled = false
          endif
        endif

      # ------------------------------------------------------------------------
      #                         Opcodes: dst = op(x, y)
      # ------------------------------------------------------------------------

      elif opcode >= MIR1_FIRST_DST_OP_X_Y_OPCODE

        opcodeMajor = bitand(opcode, 0xf8)
        opcodeMinor = bitand(opcode, 0x7)

        if opcode is MIR1_OPCODE_LOAD_INDEX
          # dst := x[y]
          # Result is always variant.
          # TODO: Handle non-variant items?
          print `  __MOLD_VariantLoadFromIndexAndAssign_${dstType}(${dstForCall}, ${xForCall}, ${yForCall});`

        elif opcode is MIR1_OPCODE_LOAD_KEY
          # dst := x{y}
          # Result is always variant.
          # TODO: Handle non-variant items?
          print `  __MOLD_VariantLoadFromKeyAndAssign_${dstType}(${dstForCall}, ${xForCall}, ${yForCall});`

        elif opcodeMajor is MIR1_OPCODE_CMP_CC_GROUP
          # Result is always bool32.
          cc = MIR_COMPARE_FLAGS[opcodeMinor]
          print `  ${dst} = __MOLD_cmp_${cc}_${xType}(${xForCall}, ${yForCall});`

        elif opcodeMajor is MIR1_OPCODE_JMP_IF_CC_GROUP
          # Result is always bool32.
          cc = MIR_COMPARE_FLAGS[opcodeMinor]
          print `  if (__MOLD_cmp_${cc}_${xType}(${xForCall}, ${yForCall})) goto ${dst};`

        elif opcodeMajor is MIR1_OPCODE_ALU2_GROUP
          aluOpcode = MIR_ALU_OPCODES_FOR_INTEGERS[opcodeMinor]
          if dstType is @any('variant', 'string')
            print `  __MOLD_${aluOpcode}AndAssign_${xType}(${dstForCall}, ${xForCall}, ${yForCall});`
          else
            print `  ${dst} = __MOLD_${aluOpcode}_${xType}(${xForCall}, ${yForCall});`
          endif

        else
          isOpcodeHandled = false
        endif

      else

        # ----------------------------------------------------------------------
        #                          dst = opcode(x)
        # ----------------------------------------------------------------------

        if opcode is MIR1_OPCODE_CAST_VARIANT_TO
          # Cast variant to primitive.
          # dst = x.value
          print `  ${dst} = __MOLD_VariantCastTo_${dstType}(${xForCall});`

        elif opcode is MIR1_OPCODE_CREATE_VARIANT_FROM
          # Create variant from primitive.
          # dst.value = x
          print `  __MOLD_VariantAssign_${xType}(${dstForCall}, ${xForCall});`

        elif opcode is MIR1_OPCODE_NEG
          this.variantDestroy(dst)
          print `  ${dst} = __MOLD_neg_${xType}(${xForCall});`

        elif opcode is MIR1_OPCODE_JMP_IF_TRUE
          if xType is 'variant'
            print `  if ((${xForCall}) -> value) goto ${dst};`
          elif xType is 'bool32'
            print `  if (${x}) goto ${dst};`
          endif

        elif opcode is MIR1_OPCODE_JMP_IF_FALSE
          if xType is 'variant'
            print `  if (!(${xForCall}) -> value) goto ${dst};`
          elif xType is 'bool32'
            print `  if (!${x}) goto ${dst};`
          endif

        else
          isOpcodeHandled = false
        endif
      endif

      if isOpcodeHandled is false
        die(`error: unhandled opcode '${opcodeAsText}`)
      endif

      # Separate MIR opcodes by new line for better readability.
      if opcode isnt MIR1_OPCODE_COMMENT
        print ''
      endif
    endfor

    # TODO: Clean up this mess.
    print 'int main(int _argc, char **_argv) {'
    print '  __MOLD_InitExceptions();'
    print '  __MOLD_InitArgv(_argc, _argv);'
    print ''
    print '  start();'
    print ''
    print '  __MOLD_VariantDestroy(&argv);'
    print '  __MOLD_MemoryDieIfMemoryLeak();'
    print '  return 0;'
    print '}'

    # Build vtables.
    print ''
    print '// vtables'
    print '// -------'

    for values classProto in codeObj.classList
      print 'void *__vtable_' ~ classProto.name, '[] = {'

      for indexes methodIdx values methodName in codeObj.methodsList
        methodProto = classProto.vtable{methodName}

        if methodProto is undefined
          methodPtr = '__MOLD_PrintErrorAndDie_nullMethodCalled'
        else
          methodPtr = '__vcall' ~ methodProto.fullName
        endif

        print `  &${methodPtr}, // ${methodName} (${methodIdx})`
      endfor

      print '};'
      print ''
    endfor

  endmethod
endclass
