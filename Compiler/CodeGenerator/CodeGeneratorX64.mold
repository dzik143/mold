################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2020 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

class CodeGeneratorX64

  method constructor()
    this.symbols             = {}
    this.isProfilerEnabled   = false
    this.mapOfEmittedBuffers = {}
    this.isBufferEmitted     = {}
  endmethod

  method lea(dst, src)
    print '  lea ', dst, ', [', src, ']'
  endmethod

  method push(x)
    print '  push', x
  endmethod

  method pop(x)
    print '  pop', x
  endmethod

  method mov(dst, src)
    print '  mov ', dst, ',', src
  endmethod

  method call(name)
    print '  call ', name
  endmethod

  method call1(name, x)
    this.lea('rcx', x)
    this.call(name)
  endmethod

  method call2(name, x, y)
    this.lea('rcx', x)
    this.lea('rdx', y)
    this.call(name)
  endmethod

  method call3(name, x, y, z)
    this.lea('rcx', x)
    this.lea('rdx', y)
    this.lea('r8', z)
    this.call(name)
  endmethod

  method call3AndDestroy(name, x, y, dst)
    if (x is dst) or (y is dst)
      this.lea('rcx', x)
      this.lea('rdx', y)
      this.lea('r8', dst)
      this.call(name)
    else
      this.variantDestroy(dst)
      this.call3(name, x, y, dst)
    endif
  endmethod

  method variantMove(dst, src)
    print '  lea rcx, [', dst, ']'
    print '  lea rdx, [', src, ']'
    print '  call __MOLD_VariantMove'
  endmethod

  method variantDestroy(x)
    #TODO
    global SYMBOL_KIND_VAR_LOCAL
    global SYMBOL_KIND_VAR_GLOBAL
    global SYMBOL_KIND_VAR_RETVAL

    xInfo = this.symbols{x}

    if ((xInfo is undefined) or
        (xInfo.kind is SYMBOL_KIND_VAR_LOCAL) or
        (xInfo.kind is SYMBOL_KIND_VAR_GLOBAL) or
        (xInfo.kind is SYMBOL_KIND_VAR_RETVAL))

      print '  lea  rcx, [', x, ']'
      print '  call __MOLD_VariantDestroy'
    endif
  endmethod

  method pushParametersBeforeCall(params)
    paramsCnt = len(params)
    regParams = ['rcx', 'rdx', 'r8', 'r9']

    if paramsCnt <= 4
      regParamsCnt   = paramsCnt
      stackParamsCnt = 0
    else
      regParamsCnt   = 4
      stackParamsCnt = paramsCnt - 4
    endif

    for idx in 0 .. regParamsCnt
      this.lea(regParams[idx], params[idx])
    endfor

    for idx in 4 .. paramsCnt
      # TODO: Optimize it.
      this.lea('rax', params[idx])
      this.push('rax')
    endfor
  endmethod

  method _hash(x) -> rv
    # TODO: Optimize it.
    rv = typeof(x) ~ ':'

    if typeof(x) is 'array'
      rv = rv ~ str(len(x)) ~ ':'
      for values item in x
        rv = rv ~ this._hash(item)
      endfor

    else
      rv = rv ~ str(x)
    endif

    rv = rv ~ ';'
  endmethod

  method emitConstant(name, value, wantDeepIdx, deepIdx)
    type             = typeof(value)
    isContentEmmited = false

    if wantDeepIdx is deepIdx
      bufferName = null

      if (type is 'array') or (type is 'string')
        # Check did we emit another buffer with the same content.
        hash       = this._hash(value)
        bufferName = this.mapOfEmittedBuffers{hash}

        if bufferName is defined
          # Buffer is already emited.
          # Just use it for another variable.
          print '; Reuse already emitted buffer'
          this.isBufferEmitted{name} = true

        else
          # Buffer is unique at this moment.
          # Generate new buffer name and go on.
          bufferName = name ~ '_buffer'

          # Save buffer name for further calls.
          this.mapOfEmittedBuffers{hash} = bufferName
        endif
      endif

      # Dispatch type.
      if type is 'integer'
        print name, 'Variant_t VARIANT_INTEGER, 0,', value

      elif type is 'float'
        print name, 'Variant_t VARIANT_DOUBLE, 0,', value

      elif type is 'string'
        print name, 'Variant_t VARIANT_STRING, 0,', bufferName

      elif type is 'array'
        print name, 'Variant_t VARIANT_ARRAY, 0,', bufferName

      elif type is 'boolean'
        if value is true
          valueAsInteger = '1'
        else
          valueAsInteger = '0'
        endif

        print name, 'Variant_t VARIANT_BOOLEAN, 0,', valueAsInteger
      else
        print name, 'Variant_t [error: unhandled type], ???'
      endif
    endif

    # Emit buffer content for complex variables.
    if type is 'array'
      this.emitArrayBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    elif type is 'string'
      this.emitStringBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitStringBufferHead(name, value, wantDeep, deepIdx)
    if this.isBufferEmitted{name} is undefined
      if wantDeep is deepIdx
        bufferName      = name ~ '_buffer'
        bufferNameBytes = name ~ '_bufferBytes'
        print  bufferName, 'Buffer_t', len(value) + 1, ', -1, 0,', bufferNameBytes
      endif

      this.emitStringBufferContent(name, value, wantDeep, deepIdx + 1)
    endif
  endmethod

  method emitStringBufferContent(name, value, wantDeep, deepIdx)
    if wantDeep is deepIdx
      bufferNameBytes = name ~ '_bufferBytes'
      bufferData      = '"'

      for values character in value
        if character is '"'
          bufferData = bufferData ~ '", 34, "'
        else
          bufferData = bufferData ~ character
        endif
      endfor

      bufferData = bufferData ~ '"'

      print bufferNameBytes, 'StringHead_t', len(value)
      print ' db ', bufferData, ', 0'
    endif
  endmethod

  method emitArrayBufferHead(name, items, wantDeepIdx, deepIdx)
    if this.isBufferEmitted{name} is undefined
      if wantDeepIdx is deepIdx
        itemsCnt        = len(items)
        bufferName      = name ~ '_buffer'
        bufferNameBytes = name ~ '_bufferBytes'

        print bufferName, 'Buffer_t', itemsCnt * 16, ', -1, 0,',  bufferNameBytes
      endif

      this.emitArrayBufferContent(name, items, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitArrayBufferContent(name, items, wantDeepIdx, deepIdx)
    itemsCnt = len(items)

    if wantDeepIdx is deepIdx
      # TODO: Optimize it.
      # TODO: Move innerType check to earliear stage.
      innerType        = typeof(items[0])
      innerSize        = 0
      innerTypeForEmit = '0'
      innerAsmType     = 'db'
      innerValueMin    = items[0] # TODO: Use MAX_INTEGER like const?
      innerValueMax    = items[0] # TODO: Use MIN_INTEGER like const?
      innerItemIdx     = 1
      itemValue        = null

      goOn = true

      while (goOn is true) and (innerItemIdx < itemsCnt)
        itemValue = items[innerItemIdx]
        itemType  = typeof(itemValue)

        if itemType isnt innerType
          # Various types in one array.
          # Fall-back to variant storage and don't go anymore.
          goOn = false

        elif itemType is 'integer'
          innerTypeForEmit = 'VARIANT_INTEGER'

          # Track max/min values to compact array storage.
          if (innerSize < 3) and ((itemValue < -2147483648) or (itemValue > 2147483647))
           # 2^3 bytes = 8 bytes = 64 bit (qword)
           innerSize    = 3
           innerAsmType = 'dq'

          elif (innerSize < 2) and ((itemValue < -32768) or (itemValue > 32767))
           # 2^2 bytes = 4 bytes = 32 bit (dword)
           innerSize    = 2
           innerAsmType = 'dd'

          elif (innerSize < 2) and ((itemValue < -128) or (itemValue > 127))
           # 2^1 bytes = 2 bytes = 16 bit (word)
           innerSize    = 1
           innerAsmType = 'dw'
          endif
        endif

        # Go to next item.
        innerItemIdx = innerItemIdx + 1
      endwhile

      # print '; innerType:'     , innerType
      # print '; innerValueMin:' , innerValueMin
      # print '; innerValueMax:' , innerValueMax

      bufferName      = name ~ '_buffer'
      bufferNameBytes = name ~ '_bufferBytes'

      print bufferNameBytes, 'dd', innerTypeForEmit, '; inner type'
      print 'db', innerSize, ' ; inner size'
      print 'db ?, ?, ? ; reserved'
      print 'dq', itemsCnt, '; itemsCnt'

      # Emit items as flat array if possible.
      if innerTypeForEmit isnt '0'
        __mold_printToStdOutput(innerAsmType)
        sep = ' '

        for itemIdx in 0 .. itemsCnt
          __mold_printToStdOutput(sep)
          __mold_printToStdOutput(items[itemIdx])
          sep = ', '
        endfor
        print ''

        # Don't go on recursively.
        itemsCnt = -1
      endif
    endif

    # Go on recursively for variant arrays.
    for itemIdx in 0 .. itemsCnt
      this.emitConstant(name ~ '_' ~ str(itemIdx), items[itemIdx], wantDeepIdx, deepIdx)
    endfor
  endmethod

  method _cmp_cc_int64(dst, x, y, cc)
    print '  mov dword [', dst, '], 0'
    print '  mov rcx, qword [', x, ']'
    print '  cmp rcx, qword [', y, ']'
    print '  set' ~ cc, 'byte [', dst, ']'
  endmethod

  method _cmp_cc_int32(dst, x, y, cc)
    print '  mov dword [', dst, '], 0'
    print '  mov ecx, dword [', x, ']'
    print '  cmp ecx, dword [', y, ']'
    print '  set' ~ cc, 'byte [', dst, ']'
  endmethod

  method _cmp_cc_float64(dst, x, y, cc)
    print '  xor eax, eax'
    print '  movq   xmm0, [', x, ']'
    print '  comisd xmm0, [', y, ']'
    print '  set' ~ cc, 'al'
    print '  mov dword [', dst, '], eax'
  endmethod

  method _jmp_if_cc_int64(dst, x, y, cc)
    print '  mov rax, qword [', x, ']'
    print '  cmp rax, qword [', y, ']'
    print '  j' ~ cc, dst
  endmethod

  method _jmp_if_cc_int32(dst, x, y, cc)
    if typeof(y) is 'integer'
      print '  cmp dword [', x, '],', y
    else
      print '  mov eax, dword [', x, ']'
      print '  cmp eax, dword [', y, ']'
    endif
    print '  j' ~ cc, dst
  endmethod

  method _jmp_if_cc_variant(dst, x, y, cc)
    # TODO: Optimize it.
    print '  lea rcx, [', x, ']'
    print '  lea rdx, [', y, ']'
    print '  lea r8, [__TrashBin]'
    print '  call __MOLD_VariantCompare' ~ cc
    print '  cmp dword [__TrashBin], 0'
    print '  jnz', dst
  endmethod

  method _getSymbolType(symbolsMap, id) -> rv
    rv = 'variant'
    if typeof(id) is 'string'
      symbolInfo = symbolsMap{id}
      if (symbolInfo is defined) and (symbolInfo.type is defined)
        rv = symbolInfo.type
      endif
    endif
  endmethod

  method run(codeObj)
    global SYMBOL_KIND_VAR_LOCAL, SYMBOL_KIND_VAR_GLOBAL, SYMBOL_KIND_CONST
    global SYMBOL_KIND_VAR_PARAM, SYMBOL_KIND_JMP_TABLE, SYMBOL_KIND_VAR_RETVAL

    #
    # Common headers.
    #

    print 'format PE64 console 5.0'
    print 'entry __MOLD_Main'
    print "include 'win64a.inc'"

    print '; ------------------------------------------------------------------------------'
    print ';                                 Code section'
    print '; ------------------------------------------------------------------------------'

    print "section '.text' code readable executable"
    print "stack 1024*1024*4, 1024*1024*4"
    print "include 'Variant.asm'"

    #
    # Fetch code and code metas.
    #

    quads = codeObj.quads

    currentProcProto    = null
    currentProcName     = null
    currentProcRv       = null
    currentSymbols      = {}
    currentFrameSize    = 0
    currentFrameOffsets = {}

    dst = null
    x   = null
    y   = null

    opcode         = ''
    originalOpcode = ''
    paramsCnt      = 0

    symbols = {}

    # TODO: Remove it.
    arrayOfProcedures = []

    #
    # Translate code section.
    #

    for values item in quads
      # Fetch instruction
      itemCnt = len(item)
      opcode  = item[0]
      dst     = item[1]
      x       = item[2]
      y       = item[3]

      # TODO: Optimize it.
      originalOpcode = opcode

      dstType = 'variant'
      xType   = 'variant'
      yType   = 'variant'

      if (itemCnt > 2) and (typeof(x) is 'string')
        if (opcode isnt 'call') and (opcode isnt 'vcall') and (opcode isnt 'syscall') and (opcode isnt 'create_object') and ((opcode[0] isnt 'c') or (opcode[1] is 'm'))

          # TODO: Clean up this mess.
          if opcode is 'load_index'
            dstType = this._getSymbolType(currentSymbols, dst)
            idxType = this._getSymbolType(currentSymbols, y)
            opcode  = opcode ~ '_' ~ dstType ~ '_by_' ~ idxType

          else
            xType  = this._getSymbolType(currentSymbols, x)
            opcode = opcode ~ '_' ~ xType
          endif
        endif
      endif

      # print '[x86]', opcode, dst, x, y

      # Dispatch opcode.
      if opcode is 'nop'
        print '  nop'

      elif opcode is 'comment'
        print ';', dst

      elif opcode is 'label'
        print dst ~ ':'

      elif ((opcode is 'move_variant') or
            (opcode is 'move_string') or
            (opcode is 'conv_string_to_variant'))

        this.variantDestroy(dst)
        this.variantMove(dst, x)

      elif (opcode is 'move_int32') or (opcode is 'move_bool32')
        print '  mov eax, dword [', x, ']'
        print '  mov dword [', dst, '], eax'

      elif (opcode is 'move_int64') or (opcode is 'move_float64')
        print '  mov rax, qword [', x, ']'
        print '  mov qword [', dst, '], rax'

      #
      # Typeof(x)
      # TODO: Move typeof(imm) to core.
      #

      elif (opcode is 'typeof_int64') or (opcode is 'typeof_int32')
        this.variantDestroy(dst)
        print '  movdqu xmm0, [StringInteger]'
        print '  movdqu [', dst, '], xmm0'

      elif opcode is 'typeof_float64'
        this.variantDestroy(dst)
        print '  movdqu xmm0, [StringFloat]'
        print '  movdqu [', dst, '], xmm0'

      elif opcode is 'typeof_bool32'
        this.variantDestroy(dst)
        print '  movdqu xmm0, [StringBoolean]'
        print '  movdqu [', dst, '], xmm0'

      #
      # int64 arithmetic
      #

      elif opcode is 'neg_int64'
        print '  mov rax, qword [', x, ']'
        print '  neg rax'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'add_int64'
        print '  mov rax, qword [', x, ']'
        print '  add rax, qword [', y, ']'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'sub_int64'
        print '  mov rax, qword [', x, ']'
        print '  sub rax, qword [', y, ']'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'mul_int64'
        print '  mov rcx, qword [', x, ']'
        print '  imul rcx, qword [', y, ']'
        print '  mov qword [', dst, '], rcx'

      elif opcode is 'div_int64'
        print '  cvtsi2sd  xmm0, qword [', x, ']'   # ; xmm0 = double(x)
        print '  cvtsi2sd  xmm1, qword [', y, ']'   # ; xmm1 = double(y)
        print '  divsd     xmm0, xmm1'              # ; xmm0 = x / y
        print '  movq      qword [', dst, '], xmm0' # ; dst  = x / y

      elif opcode is 'idiv_int64'
        print '  mov  rax, qword [', x, ']' # ; rax     = x
        print '  mov  rcx, qword [', y, ']' # ; rcx     = y
        print '  cqo'                       # ; rdx:rax = x
        print '  idiv rcx'                  # ; rax     = x / y
        print '  mov  qword [', dst,'], rax'

      elif opcode is 'cmp_eq_int64'
        this._cmp_cc_int64(dst, x, y, 'z')

      elif opcode is 'cmp_ne_int64'
        this._cmp_cc_int64(dst, x, y, 'nz')

      elif opcode is 'cmp_lt_int64'
        this._cmp_cc_int64(dst, x, y, 'l')

      elif opcode is 'cmp_le_int64'
        this._cmp_cc_int64(dst, x, y, 'le')

      elif opcode is 'cmp_gt_int64'
        this._cmp_cc_int64(dst, x, y, 'g')

      elif opcode is 'cmp_ge_int64'
        this._cmp_cc_int64(dst, x, y, 'ge')

      #
      # int32 arithmetic
      #

      elif opcode is 'neg_int32'
        print '  mov eax, dword [', x, ']'
        print '  neg eax'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'add_int32'
        print '  mov eax, dword [', x, ']'
        print '  add eax, dword [', y, ']'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'sub_int32'
        print '  mov eax, dword [', x, ']'
        print '  sub eax, dword [', y, ']'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'mul_int32'
        print '  mov ecx, dword [', x, ']'
        print '  imul ecx, dword [', y, ']'
        print '  mov dword [', dst, '], ecx'

      elif opcode is 'div_int32'
        print '  cvtsi2sd  xmm0, dword [', x, ']'   # ; xmm0 = double(x)
        print '  cvtsi2sd  xmm1, dword [', y, ']'   # ; xmm1 = double(y)
        print '  divsd     xmm0, xmm1'              # ; xmm0 = x / y
        print '  movq      qword [', dst, '], xmm0' # ; dst  = x / y

      elif opcode is 'idiv_int32'
        print '  mov  eax, dword [', x, ']' # ; eax     = x
        print '  mov  ecx, dword [', y, ']' # ; ecx     = y
        print '  cdq'                       # ; edx:eax = x
        print '  idiv ecx'                  # ; eax     = x / y
        print '  mov  dword [', dst,'], eax'

      elif opcode is 'cmp_eq_int32'
        this._cmp_cc_int32(dst, x, y, 'z')

      elif opcode is 'cmp_ne_int32'
        this._cmp_cc_int32(dst, x, y, 'nz')

      elif opcode is 'cmp_lt_int32'
        this._cmp_cc_int32(dst, x, y, 'l')

      elif opcode is 'cmp_le_int32'
        this._cmp_cc_int32(dst, x, y, 'le')

      elif opcode is 'cmp_gt_int32'
        this._cmp_cc_int32(dst, x, y, 'g')

      elif opcode is 'cmp_ge_int32'
        this._cmp_cc_int32(dst, x, y, 'ge')

      #
      # float64 arithmetic
      #

      elif opcode is 'neg_float64'
        print '  mov rax, qword [', x, ']'
        print '  xor rax, qword [__MOLD_VariantNeg.signBit]'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'add_float64'
        print '  movq  xmm0, [', x, ']'
        print '  addsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'sub_float64'
        print '  movq  xmm0, [', x, ']'
        print '  subsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'mul_float64'
        print '  movq  xmm0, [', x, ']'
        print '  mulsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'div_float64'
        print '  movq  xmm0, [', x, ']'
        print '  divsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'idiv_float64'
        print '  movq      xmm0, qword [', x, ']'  # xmm0 = x
        print '  movq      xmm1, qword [', y, ']'  # xmm1 = y
        print '  divsd     xmm0, xmm1'             # xmm0 = x / y
        print '  cvttsd2si rax, xmm0'              # rax  = int(x / y)
        print '  mov       qword [', dst, '], rax' # dst  = int(x / y)

      elif opcode is 'cmp_eq_float64'
        this._cmp_cc_float64(dst, x, y, 'z')

      elif opcode is 'cmp_ne_float64'
        this._cmp_cc_float64(dst, x, y, 'nz')

      elif opcode is 'cmp_lt_float64'
        this._cmp_cc_float64(dst, x, y, 'b')

      elif opcode is 'cmp_le_float64'
        this._cmp_cc_float64(dst, x, y, 'be')

      elif opcode is 'cmp_gt_float64'
        this._cmp_cc_float64(dst, x, y, 'a')

      elif opcode is 'cmp_ge_float64'
        this._cmp_cc_float64(dst, x, y, 'ae')

      #
      # Variant arithmetic.
      #

      elif opcode is 'neg_variant'
        this.call2('__MOLD_VariantNeg', x, dst)

      elif (opcode is 'add_variant') or (opcode is 'add_string')
        this.call3('__MOLD_VariantAdd', x, y, dst)

      elif opcode is 'sub_variant'
        this.call3('__MOLD_VariantSub', x, y, dst)

      elif opcode is 'mul_variant'
        this.call3('__MOLD_VariantMul', x, y, dst)

      elif opcode is 'div_variant'
        this.call3('__MOLD_VariantDiv', x, y, dst)

      elif opcode is 'idiv_variant'
        this.call3('__MOLD_VariantDivAsInteger', x, y, dst)

      elif (opcode is 'cmp_eq_variant') or (opcode is 'cmp_eq_string')
        this.call3('__MOLD_VariantCompareEQ', x, y, dst)

      elif (opcode is 'cmp_ne_variant') or (opcode is 'cmp_ne_string')
        this.call3('__MOLD_VariantCompareNE', x, y, dst)

      elif opcode is 'cmp_lt_variant'
        this.call3('__MOLD_VariantCompareLT', x, y, dst)

      elif opcode is 'cmp_le_variant'
        this.call3('__MOLD_VariantCompareLE', x, y, dst)

      elif opcode is 'cmp_gt_variant'
        this.call3('__MOLD_VariantCompareLT', y, x, dst)

      elif opcode is 'cmp_ge_variant'
        this.call3('__MOLD_VariantCompareLE', y, x, dst)

      #
      # build-in string operations
      #

      elif originalOpcode is 'string_join'
        this.call3AndDestroy('__MOLD_VariantStringJoin', x, y, dst)

      #
      # indirect jumps
      #

      elif opcode is 'jmp_by_table_variant'
        print '  mov rax, [', x, '+ Variant_t.value]'
        print '  jmp qword [', dst, '+ rax * 8]'

      elif opcode is 'jmp_by_table_int32'
        print '  mov eax, dword [', x, ']'
        print '  jmp qword [', dst, '+ rax * 8]'

      #
      # jmp_if_xx_variant
      #

      elif (opcode is 'jmp_if_eq_variant') or (opcode is 'jmp_if_eq_string')
        this._jmp_if_cc_variant(dst, x, y, 'EQ')

      elif (opcode is 'jmp_if_ne_variant') or (opcode is 'jmp_if_ne_string')
        this._jmp_if_cc_variant(dst, x, y, 'NE')

      elif opcode is 'jmp_if_lt_variant'
        this._jmp_if_cc_variant(dst, x, y, 'LT')

      elif opcode is 'jmp_if_le_variant'
        this._jmp_if_cc_variant(dst, x, y, 'LE')

      elif opcode is 'jmp_if_gt_variant'
        this._jmp_if_cc_variant(dst, y, x, 'LT')

      elif opcode is 'jmp_if_ge_variant'
        this._jmp_if_cc_variant(dst, y, x, 'LE')

      #
      # load imm values
      #

      elif originalOpcode is 'load_null'
        this.variantDestroy(dst)

      elif originalOpcode is 'load_int64'
        print '  mov rax,', x
        print '  mov qword [', dst, '], rax'

      elif originalOpcode is 'load_int32'
        print '  mov dword [', dst, '],', x

      elif originalOpcode is 'load_bool32'
        if x is true
          print '  mov dword [', dst, '],', 1
        else
          print '  mov dword [', dst, '],', 0
        endif

      elif originalOpcode is 'load_float64'
        print '  db 0x48, 0xb8' # mov rax, float64
        print '  dq', x
        print '  mov qword [', dst, '], rax'

      #
      # jmp_if_xx_int64
      #

      elif opcode is 'jmp_if_eq_int64'
        this._jmp_if_cc_int64(dst, x, y, 'z')

      elif opcode is 'jmp_if_ne_int64'
        this._jmp_if_cc_int64(dst, x, y, 'nz')

      elif opcode is 'jmp_if_lt_int64'
        this._jmp_if_cc_int64(dst, x, y, 'l')

      elif opcode is 'jmp_if_le_int64'
        this._jmp_if_cc_int64(dst, x, y, 'le')

      elif opcode is 'jmp_if_gt_int64'
        this._jmp_if_cc_int64(dst, x, y, 'g')

      elif opcode is 'jmp_if_ge_int64'
        this._jmp_if_cc_int64(dst, x, y, 'ge')

      #
      # jmp_if_xx_int32
      #

      elif opcode is 'jmp_if_eq_int32'
        this._jmp_if_cc_int32(dst, x, y, 'z')

      elif opcode is 'jmp_if_ne_int32'
        this._jmp_if_cc_int32(dst, x, y, 'nz')

      elif opcode is 'jmp_if_lt_int32'
        this._jmp_if_cc_int32(dst, x, y, 'l')

      elif opcode is 'jmp_if_le_int32'
        this._jmp_if_cc_int32(dst, x, y, 'le')

      elif opcode is 'jmp_if_gt_int32'
        this._jmp_if_cc_int32(dst, x, y, 'g')

      elif opcode is 'jmp_if_ge_int32'
        this._jmp_if_cc_int32(dst, x, y, 'ge')

      #
      # jmp_if_true_bool32
      # jmp_if_false_bool32
      #

      elif opcode is 'jmp_if_true_bool32'
        print '  cmp dword [', x, '], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_false_bool32'
        print '  cmp dword [', x, '], 0'
        print '  jz', dst

      elif opcode is 'jmp_if_eq_bool32'
        print '  xor   eax, eax'
        print '  or    dword [', x, '], eax'
        print '  setnz cl'
        print '  or    dword [', y, '], eax'
        print '  setz  al'
        print '  xor   al, cl'
        print '  jnz', dst

      elif opcode is 'jmp_if_ne_bool32'
        print '  xor  eax, eax'
        print '  or   dword [', x, '], eax'
        print '  setz cl'
        print '  or   dword [', y, '], eax'
        print '  setz al'
        print '  xor  al, cl'
        print '  jnz', dst

      elif opcode is 'cmp_eq_bool32'
        print '  xor   eax, eax'
        print '  or    dword [', x, '], eax'
        print '  setnz cl'
        print '  or    dword [', y, '], eax'
        print '  setz  al'
        print '  xor   al, cl'
        print '  mov   dword [', dst, '], eax'

      elif opcode is 'cmp_ne_bool32'
        print '  xor  eax, eax'
        print '  or   dword [', x, '], eax'
        print '  setz cl'
        print '  or   dword [', y, '], eax'
        print '  setz al'
        print '  xor  al, cl'
        print '  mov  dword [', dst, '], eax'

      #
      # jmp_if_xx_float64
      #

      elif opcode is 'jmp_if_eq_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jz', dst

      elif opcode is 'jmp_if_ne_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jnz', dst

      elif opcode is 'jmp_if_lt_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jb', dst

      elif opcode is 'jmp_if_le_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jbe', dst

      elif opcode is 'jmp_if_gt_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  ja', dst

      elif opcode is 'jmp_if_ge_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jae', dst

      #
      # Print functions.
      #

      elif opcode is 'print_array_of_variants_ln'
        params    = dst
        paramsCnt = len(params)

        if paramsCnt is 1
          this.call1('__MOLD_PrintVariantLn', params[0])
        else
          newParams = [paramsCnt]
          for idx in 0 .. paramsCnt
            newParams[idx + 1] = params[idx]
          endfor
          paramsCnt = paramsCnt + 1

          this.pushParametersBeforeCall(newParams)

          this.call('__MOLD_PrintArrayOfVariantsLn')

          if paramsCnt > 4
            print '  add rsp,', paramsCnt * 8 - 32
          endif
        endif

      elif opcode is 'str_int64'
        this.variantDestroy(dst)
        print '  mov r9, [', x, ']'
        print '  mov r10d, VARIANT_INTEGER'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertPrimitiveToString'

      elif opcode is 'str_int32'
        this.variantDestroy(dst)
        print '  mov r9d, [', x, ']'
        print '  mov r10d, VARIANT_INTEGER'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertPrimitiveToString'

      elif opcode is 'str_float64'
        this.variantDestroy(dst)
        print '  mov r9, [', x, ']'
        print '  mov r10d, VARIANT_DOUBLE'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertPrimitiveToString'

      elif opcode is 'str_bool32'
        this.variantDestroy(dst)
        print '  mov r9d, dword [', x, ']'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertBool64ToString'

      elif (opcode is 'call') or (opcode is 'syscall')
        rv        = item[1]
        name      = item[2]
        params    = item[3]
        paramsCnt = len(params)

        if rv is defined
          # Function has return value.
          # TODO: Clean up this mess.
          this.push('rdi')
          this.pushParametersBeforeCall(params)
          this.lea('rdi', rv)
          this.mov('[rdi + Variant_t.type]', 'VARIANT_UNDEFINED')
        else
          # No return value.
          this.pushParametersBeforeCall(params)
        endif

        if opcode is 'syscall'
          # Syscall
          if typeof(name) is 'integer'
            print '  mov eax, ', name
          else
            print '  mov eax, dword [', name, '+ Variant_t.value]'
          endif

          this.call('__MOLD_SysCall')

        else
          # Ordinary function.
          this.call(name)
        endif

        if paramsCnt > 4
          print '  add rsp,', paramsCnt * 8 - 32
        endif

        if rv is defined
          this.pop('rdi')
        endif

      elif opcode is 'vcall'
        rv        = item[1]
        methodId  = item[2]
        params    = item[3]
        paramsCnt = len(params)

        if rv is defined
          this.push('rdi')
          this.pushParametersBeforeCall(params)
          print '  lea  rdi, [', rv, ']'
          print '  mov [rdi + Variant_t.type], VARIANT_UNDEFINED'
        else
          this.pushParametersBeforeCall(params)
        endif

        print '  mov  eax,', methodId
        print '  call __MOLD_VCall'

        if paramsCnt > 4
          print '  add rsp,', paramsCnt * 8 - 32
        endif

        if rv is defined
          this.pop('rdi')
        endif

      elif opcode is 'create_object'
        this.variantDestroy(dst)
        print '  lea  rcx, [', dst, ']'
        print '  lea  rdx, [vtable_' ~ str(x) ~ ']'
        print '  call __MOLD_VariantObjectCreate'

      elif originalOpcode is 'conv_int32_to_float64'
        print '  cvtsi2sd xmm0, dword [', x, ']'
        print '  movq [', dst, '], xmm0'

      elif originalOpcode is 'conv_int64_to_float64'
        print '  cvtsi2sd xmm0, qword [', x, ']'
        print '  movq [', dst, '], xmm0'

      elif originalOpcode is 'conv_int32_to_variant'
        print '  mov [', dst, '+ Variant_t.type], VARIANT_INTEGER'

        if typeof(x) is 'integer'
          print '  mov [', dst, '+ Variant_t.value],', x
        else
          print '  movsxd rax, dword [', x, ']'
          print '  mov [', dst, '+ Variant_t.value], rax'
        endif

      elif originalOpcode is 'conv_int64_to_variant'
        if typeof(x) is 'integer'
          print '  mov rax,', x
        else
          print '  mov rax, qword [', x, ']'
        endif

        print '  mov [', dst, '+ Variant_t.type], VARIANT_INTEGER'
        print '  mov [', dst, '+ Variant_t.value], rax'

      elif originalOpcode is 'conv_float64_to_variant'
        if typeof(x) is 'float'
          print '  db 0x48, 0xb8' # mov rax, float64
          print '  dq', x
        else
          print '  mov rax, qword [', x, ']'
        endif

        print '  mov [', dst, '+ Variant_t.type], VARIANT_DOUBLE'
        print '  mov [', dst, '+ Variant_t.value], rax'

      elif originalOpcode is 'conv_float64_to_int32'
        if typeof(x) is 'float'
          die('error: convert imm float64 to int32 not supported')
        else
          print '  cvttsd2si eax, [', x, ']'
          print '  mov dword [', dst, '], eax'
        endif

      elif originalOpcode is 'conv_float64_to_int64'
        if typeof(x) is 'float'
          die('error: convert imm float64 to int64 not supported')
        else
          print '  cvttsd2si rax, [', x, ']'
          print '  mov qword [', dst, '], rax'
        endif

      elif originalOpcode is 'conv_bool32_to_variant'
        if typeof(x) is 'boolean'
          if x is true
            print '  mov eax, 1'
          elif x is false
            print '  mov eax, 0'
          endif
        else
          print '  mov eax, dword [', x, ']'
        endif

        print '  mov [', dst, '+ Variant_t.type], VARIANT_BOOLEAN'
        print '  mov [', dst, '+ Variant_t.value], rax'

      elif originalOpcode is 'conv_variant_to_bool32'
        print '  cmp [', x, '+ Variant_t.type], VARIANT_BOOLEAN'
        print '  jnz __MOLD_PrintErrorAndDie.booleanExpected'
        print '  mov eax, dword [', x, '+ Variant_t.value]'
        print '  mov dword [', dst, '], eax'

      elif originalOpcode is 'conv_variant_to_int32'
        # TODO: Handle very long arrays?
        # TODO: Optimize it.
        print '  cmp [', x, '+ Variant_t.type], VARIANT_INTEGER'
        print '  jnz __MOLD_PrintErrorAndDie.integerExpected'
        print '  mov eax, dword [', x, '+ Variant_t.value]'
        print '  mov dword [', dst, '], eax'

      elif originalOpcode is 'conv_variant_to_int64'
        print '  cmp [', x, '+ Variant_t.type], VARIANT_INTEGER'
        print '  jnz __MOLD_PrintErrorAndDie.integerExpected'
        print '  mov rax, qword [', x, '+ Variant_t.value]'
        print '  mov qword [', dst, '], rax'

      elif originalOpcode is 'conv_variant_to_float64'
        print '  cmp [', x, '+ Variant_t.type], VARIANT_DOUBLE'
        print '  jnz __MOLD_PrintErrorAndDie.floatExpected'
        print '  mov rax, qword [', x, '+ Variant_t.value]'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'jmp_if_true_variant'
        print '  cmp  [', x, ' + Variant_t.value], 0'
        print '  jnz ', dst

      elif opcode is 'jmp_if_false_variant'
        print '  cmp  [', x, ' + Variant_t.value], 0'
        print '  jz  ', dst

      elif opcode is 'jmp_if_variant_ge_int64'
        print '  cmp  [', x, ' + Variant_t.value],', y
        print '  jge ', dst

      elif opcode is 'inner_ret'
        # TODO: Better handling of nested procedures.
        print '  ret'

      elif opcode is 'ret'
        print ''
        print '  ; clean frame'
        print '  ; -----------'

        # TODO: Clean up this mess.
        symbols = currentSymbols

        for values oneItem in symbols

          if ((oneItem.kind is SYMBOL_KIND_VAR_LOCAL) and
              ((oneItem.type is undefined) or (oneItem.type is 'variant')))

            if oneItem.usedAsIterator is defined
              # Symbol is used as loop iterator.
              # It's only dump reference for existing box values or keys.
              print '  ; Skipped loop iterator', oneItem.name

            else
              this.variantDestroy(oneItem.name)
            endif
          endif
        endfor

        # Profiler code if needed.
        if this.isProfilerEnabled is true
          print '  ; leave profiler code'
          print '  ; -------------------'
          print '  push   rdx'
          print '  rdtsc'
          print '  shl    rdx, 32'
          print '  add    rdx, rax'
          print '  add    qword [__profilerCounterEntry_' ~ currentProcName ~ '], rdx'
          print '  pop    rdx'

          if currentProcName is 'start'
            print ''
            print '  ; print profiler result'
            print '  ; ---------------------'
            print '  lea  rcx, [__profilerCounterData]'
            print '  call __MOLD_PrintProfilerData'
            print ''
          endif
        endif

        if currentProcName is 'start'
          for values oneItem in symbols

            if ((oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and
                ((oneItem.type is undefined) or (oneItem.type is 'variant')))

              this.variantDestroy(oneItem.name)
            endif
          endfor
        endif

        print ''
        print '  add  rsp,', currentFrameSize
        print '  pop  rbp'
        print '  ret'

      elif opcode is 'proc'
        proto            = item[1]
        currentProcProto = proto
        currentProcName  = proto.name
        currentProcRv    = proto.rv
        currentSymbols   = proto.symbols
        print currentProcName ~ ':'

        arrayOfProcedures[@afterlast] = currentProcName

        # Profiler code if needed.
        if this.isProfilerEnabled is true
          print '  ; enter profiler code'
          print '  ; -------------------'
          print '  push   rdx'
          print '  rdtsc'
          print '  shl    rdx, 32'
          print '  add    rdx, rax'
          print '  sub    qword [__profilerCounterEntry_' ~ currentProcName ~ '], rdx'
          print '  pop    rdx'
        endif

      elif opcode is 'endp'
        print ''
        # TODO: Clean up this mess.
        for values oneItem in symbols

          if ((oneItem.kind is SYMBOL_KIND_VAR_LOCAL) or
              (oneItem.kind is SYMBOL_KIND_VAR_PARAM) or
              (oneItem.kind is SYMBOL_KIND_VAR_RETVAL))

            print '  restore', oneItem.name
          endif
        endfor

      elif opcode is 'init_frame'
        currentFrame = dst
        symbols      = currentFrame.symbols
        params       = currentFrame.params
        paramsCnt    = len(params)

        # Clean up this mess.
        this.symbols = symbols

        regParams = ['rcx','rdx', 'r8', 'r9']

        print '  ; init frame'
        print '  ; ----------'

        # Calculate frame size.
        currentFrameSize = 0
        paramsPassedCnt  = 0
        symbolsCnt       = len(symbols)

        # TODO: Clean up this mess.
        # TODO: Use reverse.
        symbolsIndex = []
        for values v in symbols
          symbolsIndex[@afterlast] = v
        endfor
        symbolsCnt = len(symbolsIndex)

        # TODO: Use reverse when ready.
        for symbolIdx in 0 .. symbolsCnt
          symbol = symbolsIndex[symbolsCnt - symbolIdx - 1]

          if ((symbol.kind is SYMBOL_KIND_VAR_LOCAL) or
              (symbol.kind is SYMBOL_KIND_VAR_PARAM))

            if (symbol.type is undefined) or (symbol.type is 'variant') or (symbol.type is 'string')
              varSize = 16

            elif (symbol.type is 'int64') or (symbol.type is 'float64')
              varSize = 8

            elif (symbol.type is 'int32') or (symbol.type is 'bool32')
              varSize = 4

            else
              # TODO: Remove unneded assign.
              varSize = -1
              die('error: unhandled operand type while setting up frame: ' ~ str(symbol.type))
            endif

            currentFrameSize = currentFrameSize + varSize

            print ' ', symbol.name, 'EQU rbp -', 8 + currentFrameSize, ';', varSize, 'bytes'

          elif symbol.kind is SYMBOL_KIND_VAR_RETVAL
            # TODO: Pass variant return values on stack?
            print ' ', symbol.name, 'EQU rdi'
          endif

          # TODO: Dirty fix to handle real number of stack parameters if 'this'
          # pointer is used.
          if symbol.kind is SYMBOL_KIND_VAR_PARAM
            paramsPassedCnt = paramsPassedCnt + 1
          endif
        endfor

        # Align to 16-bytes and add 32-byte shadow space.
        # TODO: Optimize it.
        if currentFrameSize > 0
          currentFrameSize = ((currentFrameSize + 32) // 16 + 1) * 16
        else
          currentFrameSize = 32
        endif

        print ''
        print '  push rbp'
        print '  mov  rbp, rsp'
        print '  sub  rsp,', currentFrameSize
        print ''

        paramIdx = 0

        for values oneItem in symbols
          if oneItem.kind is SYMBOL_KIND_VAR_LOCAL
            if ((oneItem.type is undefined) or
                (oneItem.type is 'variant') or
                (oneItem.type is 'string'))

              # Local Variant_t variable - init to undefined.
              if oneItem.usedAsIterator is defined
                # Symbol is used as loop iterator.
                # It's only dump reference for existing box values or keys.
                print '  ; Skipped loop iterator', oneItem.item
              else
                print '  mov [' ~ oneItem.name ~ ' + Variant_t.type], VARIANT_UNDEFINED'
              endif
            endif

          elif oneItem.kind is SYMBOL_KIND_VAR_PARAM
            # Call parameter - copy to local var.
            if (oneItem.readHits > 0) or (oneItem.writeHits > 0)
              if paramIdx < 4
                srcPtr = regParams[paramIdx]
              else
                print '  mov    rax, [rbp + 16 + 8 *', paramsPassedCnt - paramIdx - 1, ']'
                srcPtr = 'rax'
              endif

              if ((oneItem.type is undefined) or
                  (oneItem.type is 'variant') or
                  (oneItem.type is 'string'))

                  print '  movdqu xmm0', ', [', srcPtr, ']'
                  print '  movdqu [', oneItem.name, '], xmm0'

                if oneItem.duplicateOnFirstWrite is defined
                  print '  or [', oneItem.name, ' + Variant_t.flags ], VARIANT_FLAG_DUPLICATE_ON_FIRST_WRITE'
                endif

              elif ((oneItem.type is 'int32') or
                    (oneItem.type is 'bool32'))
                print '  mov eax, dword [', srcPtr, ']'
                print '  mov dword [', oneItem.name, '], eax'

              elif ((oneItem.type is 'int64') or
                    (oneItem.type is 'bool64') or
                    (oneItem.type is 'float64'))
                print '  mov rax, qword [', srcPtr, ']'
                print '  mov qword [', oneItem.name, '], rax'

              else
                die("error: unhandled type for param '" ~ oneItem.name ~ "': " ~ oneItem.type)
              endif

            else
              print '  ; skipped unused param [', oneItem.name, ']'
            endif

            paramIdx = paramIdx  + 1
          endif
        endfor

        if currentProcName is 'start'
          print ''
          for values oneItem in symbols
            # TODO: Better way to exclude external vars.
            if (oneItem.name is 'argv') or (oneItem.name is 'argc')
              # Do nothing.

            elif ((oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and
                  ((oneItem.type is undefined) or (oneItem.type is 'variant')))

              print '  mov [' ~ oneItem.name ~ ' + Variant_t.type], VARIANT_UNDEFINED'
            endif

          endfor
        endif

        print ''
        print '  ; code'
        print '  ; ----'

      elif originalOpcode is 'create_array'
        this.variantDestroy(dst)
        this.call1('__MOLD_VariantArrayCreate', dst)

      elif originalOpcode is 'create_map'
        this.variantDestroy(dst)
        this.call1('__MOLD_VariantMapCreate', dst)

      elif opcode is 'store_index_variant'
        # dst[x] := y
        this.call3('__MOLD_VariantStoreAtIndex', dst, x, y)

      elif (opcode is 'store_key_string') or (opcode is 'store_key_variant')
        # dst{x} := y
        this.call3('__MOLD_VariantStoreAtKey', dst, x, y)

      elif opcode is 'store_index_int32'
        # dst[x] := y
        this.call3('__MOLD_VariantStoreAtIndex_int32', dst, x, y)

      elif opcode is 'load_index_variant_by_variant'
        # dst := x[y]
        this.call3AndDestroy('__MOLD_VariantLoadFromIndex', x, y, dst)

      elif ((opcode is 'load_index_variant_by_int32') or
            (opcode is 'load_index_string_by_int32'))

        # dst := x[y]
        this.call3AndDestroy('__MOLD_VariantLoadFromIndex_int32', x, y, dst)

      elif opcode is 'load_index_int32_by_int32'
        # dst := x[y]
        this.call3('__MOLD_VariantLoadFromIndex_native', x, y, dst)

      elif opcode is 'load_key_variant'
        # dst := x[y]
        this.call3AndDestroy('__MOLD_VariantLoadFromKey', x, y, dst)

      elif originalOpcode is 'jmp'
       print '  jmp', dst

      else
        die('error: unhandled opcode "' ~ str(opcode) ~ '"')
      endif
    endfor

    print ''
    print 'endOfCodeSection:'

    #
    # Generate data section.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                                 Data section'
    print '; ------------------------------------------------------------------------------'
    print "section '.data' data readable writeable"

    print "include 'CommonData.asm'"
    print ''

    print ''
    print '; Global vars'
    print '; -----------'

    globals = codeObj.symbolTable.exportSymbols()

    for values oneItem in globals
      if oneItem.kind is SYMBOL_KIND_VAR_GLOBAL
        if ((oneItem.type is 'variant') or
            (oneItem.type is 'string') or
            (oneItem.type is undefined))
          print oneItem.name, ' Variant_t 0, 0, 0'

        elif oneItem.type is 'int64'
          print oneItem.name, ' dq 0'

        elif oneItem.type is 'int32'
          print oneItem.name, ' dd 0'

        elif oneItem.type is 'float64'
          print oneItem.name, ' dq 0'

        elif oneItem.type is 'bool32'
          print oneItem.name, ' dd 0'

        else
          die('error: unhandled global type: ' ~ str(oneItem.type))
        endif
      endif
    endfor

    #
    # Dump constant data to another section to catch access
    # violation on write attemp.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                     Constant (read-only) data section'
    print '; ------------------------------------------------------------------------------'
    print "section '.rdata' data readable"

    print ''
    print '; Constants'
    print '; ---------'

    print 'db ?'

    # TODO: Optimize it.
    for deepIdx in 0 .. 16
      print '; iter', deepIdx

      for values symbolInfo in globals
        if symbolInfo.kind is SYMBOL_KIND_CONST
          name  = symbolInfo.name
          value = symbolInfo.value
          this.emitConstant(name, value, deepIdx, 0)
        endif
      endfor
    endfor

    # Jump tables
    print ''
    print '; Jump tables'
    print '; -----------'

    for values symbolInfo in globals
      if symbolInfo.kind is SYMBOL_KIND_JMP_TABLE
        name         = symbolInfo.name
        labels       = symbolInfo.labels
        defaultLabel = symbolInfo.defaultLabel

        print name ~ ':'

        for indexes labelIdx values nextLabel in labels
          if nextLabel is undefined
            nextLabel = defaultLabel
          endif

          print '  dq ', nextLabel, ';', labelIdx
        endfor
      endif
    endfor

    # Build vtables.
    print ''
    print '; vtables'
    print '; -------'

    classListCnt   = codeObj.classListCnt
    classList      = codeObj.classList
    classMap       = codeObj.classMap
    methodsMap     = codeObj.methodsMap
    methodsList    = codeObj.methodsList
    methodsListCnt = codeObj.methodsListCnt

    for classIdx in 0 .. classListCnt
      classProto = classList[classIdx]
      className  = classProto.name
      vtable     = classProto.vtable

      print 'vtable_' ~ className ~ ':'

      # Find first and last used entry.
      firstUsedMethodIdx = 0
      lastUsedMethodIdx  = 0

      for indexes methodIdx values methodName in methodsList
        if vtable{methodName} is defined
          # Update index of last used method always, on all occerencies.
          lastUsedMethodIdx = methodIdx + 1

          # Save index of first used method once, on first occurence.
          if firstUsedMethodIdx is 0
            firstUsedMethodIdx = methodIdx
          endif
        endif
      endfor

      print '.offset dd 8 *', firstUsedMethodIdx
      print '.length dd 8 *', lastUsedMethodIdx - firstUsedMethodIdx

      print '.entries:'

      for methodIdx in firstUsedMethodIdx .. lastUsedMethodIdx
        methodName  = methodsList[methodIdx]
        methodProto = vtable{methodName}

        if methodProto is undefined
          methodPtr = '__MOLD_NullMethodCalled'
        else
          methodPtr = methodProto.fullName
        endif

        print '  dq', methodPtr, ';', methodName, '(', methodIdx, ')'
      endfor

      print ''
    endfor

    #
    # Generate imports section.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                               Imports section'
    print '; ------------------------------------------------------------------------------'

    print "section '.idata' import data readable writeable"
    print "  include 'CommonImports.asm'"
    print ''

    #
    # Generate debug section with symbols.
    #

    procedures    = codeObj.procedures
    proceduresCnt = codeObj.proceduresCnt

    print '; ------------------------------------------------------------------------------'
    print ';                                Debug section'
    print '; ------------------------------------------------------------------------------'

    print "section '.debug' data readable"

    # Dump symbols.
    print 'SymbolTable:'
    print 'dq 0, 0'
    print "include 'SymbolTableCommon.asm'"

    for values procName in arrayOfProcedures
      print 'dq ', procName, ',', 'name_' ~ procName
    endfor

    print 'dq endOfCodeSection, name_endOfCodeSection'
    print 'SymbolTableEnd:'
    print 'dq 0, 0'
    print ''

    print 'SymbolTableNames:'
    print "include 'SymbolTableCommonNames.asm'"

    for values procName in arrayOfProcedures
      print 'name_' ~ procName, 'db', "'" ~ procName ~ "', 0"
    endfor

    print "name_endOfCodeSection db 'out of code section', 0"

    #
    # Generate profiler section if needed.
    #

    if this.isProfilerEnabled is true
      print '; ------------------------------------------------------------------------------'
      print ';                              Profile section'
      print '; ------------------------------------------------------------------------------'

      print "section '.profile' data readable writeable"
      print '__profilerCounterData:'

      for values procName in arrayOfProcedures
        print '__profilerCounterEntry_' ~ procName, ' dq 0,', 'name_' ~ procName
      endfor

      print 'dq 0, 0'
    endif

  endmethod
endclass
