################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2020 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

const REG_PARAMS_CNT = 4
const REG_PARAMS32   = ['ecx', 'edx', 'r8d', 'r9d']
const REG_PARAMS64   = ['rcx', 'rdx', 'r8' , 'r9']

MIR_TO_VARIANT_TYPE_MAP = {
  'int32':   'VARIANT_INTEGER',
  'int64':   'VARIANT_INTEGER',
  'float32': 'VARIANT_FLOAT',
  'float64': 'VARIANT_DOUBLE',
  'bool32':  'VARIANT_BOOLEAN',
  'bool64':  'VARIANT_BOOLEAN',
  'string':  'VARIANT_STRING',
  'array':   'VARIANT_ARRAY',
  'map':     'VARIANT_MAP'
}

MIR_TYPE_SIZE_MAP = {
  'int32':   4,
  'int64':   8,
  'float32': 4,
  'float64': 8,
  'bool32':  4,
  'bool64':  8,
  'variant': 16,
  'string':  16,
  'array':   16,
  'map':     16
}

const MIR_COMPARE_FLAGS_FOR_INTEGERS = ['e', 'ne', 'l', 'ge', 'le', 'g']
const MIR_COMPARE_FLAGS_FOR_FLOATS   = ['e', 'ne', 'b', 'ae', 'be', 'a']

const MIR_ALU_OPCODES_FOR_INTEGERS = ['add'   , 'sub'   , 'imul'  , 'div'   , 'idiv']
const MIR_ALU_OPCODES_FOR_FLOATS   = ['addsd' , 'subsd' , 'mulsd' , 'divsd' , 'divsd']

# TODO: Remove _ prefix.
const _VARIANT_UNDEFINED = 0
const _VARIANT_NULL      = 1

# Primitives.
const _VARIANT_INTEGER   = 2
const _VARIANT_FLOAT     = 3
const _VARIANT_DOUBLE    = 4
const _VARIANT_STRING    = 5
const _VARIANT_BOOLEAN   = 6

# Complex containers.
const _VARIANT_ARRAY     = 7
const _VARIANT_MAP       = 8
const _VARIANT_OBJECT    = 9
const _VARIANT_TYPE_MAX  = 9

class CodeGeneratorX64

  method constructor()
    this.symbols             = {}
    this.globals             = {}
    this.isProfilerEnabled   = false
    this.mapOfEmittedBuffers = {}
    this.isBufferEmitted     = {}
  endmethod

  method lea(dst, src)
    print '  lea ', dst, ', [', src, ']'
  endmethod

  method store(dst, src)
    print '  mov [', dst, '],', src
  endmethod

  method store32(dst, src)
    print '  mov dword [', dst, '],', src
  endmethod

  method storeResultAfterCall(dst)
    mirType = this._getSymbolType(dst)

    if mirType is @any('int32', 'bool32')
      print '  mov dword [', dst, '], ecx'

    elif mirType is 'int64'
      print '  mov qword [', dst, '], rcx'

    elif mirType is 'float64'
      print '  movq qword [', dst, '], xmm0'

    elif mirType is @any('variant', 'string')
      # Do nothing.
      # Non-primitive result should be passed via pointer parameter.

    elif mirType is 'label'
      # Jump target - do nothing.

    else
      die('unhandled result type: ' ~ mirType)
    endif
  endmethod

  method call(name)
    print '  call ', name
  endmethod

  method call1(name, x)
    this.pushOneParameterBeforeCall(x, 0)
    this.call(name)
  endmethod

  method call2(name, x, y)
    this.pushOneParameterBeforeCall(x, 0)
    this.pushOneParameterBeforeCall(y, 1)
    this.call(name)
  endmethod

  method call3(name, x, y, z)
    this.pushOneParameterBeforeCall(x, 0)
    this.pushOneParameterBeforeCall(y, 1)
    this.pushOneParameterBeforeCall(z, 2)
    this.call(name)
  endmethod

  method call3AndDestroy(name, x, y, dst)
    if @any(x, y) is dst
      # Specal cases (overlapped dst and src):
      #   x = foo(x, y)
      #   y = foo(x, y)
      this.call3(name, x, y, dst)
    else
      # General case:
      #   dst = foo(x, y)
      this.variantDestroy(dst)
      this.call3(name, x, y, dst)
    endif
  endmethod

  method variantMove(dst, src)
    this.pushOneParameterBeforeCall(dst, 0)
    this.pushOneParameterBeforeCall(src, 1)
    print '  call __MOLD_VariantMove'
  endmethod

  method variantDestroy(x)
    #TODO
    global SYMBOL_KIND_VAR_LOCAL
    global SYMBOL_KIND_VAR_GLOBAL
    global SYMBOL_KIND_VAR_RETVAL

    xInfo = this.symbols{x}

    if ((xInfo is undefined) or
        (xInfo.kind is @any(SYMBOL_KIND_VAR_LOCAL,
                            SYMBOL_KIND_VAR_GLOBAL,
                            SYMBOL_KIND_VAR_RETVAL)))

      print '  lea  rcx, [', x, ']'
      print '  call __MOLD_VariantDestroy'
    endif
  endmethod

  method getVariableSize(varName) -> varSize
    if varName is '__TrashBin'
      varSize = 16

    else
      symbolInfo = this.symbols{varName}

      if symbolInfo is undefined
        symbolInfo = this.globals{varName}
      endif

      if symbolInfo is undefined
        die('error: failed to get variable size:' ~ varName)
        varSize = -1

      elif symbolInfo.type is @any(undefined, 'variant', 'string')
        # TODO: Review it.
        varSize = 16

      elif symbolInfo.type is @any('int64', 'float64')
        varSize = 8

      elif symbolInfo.type is @any('int32', 'bool32')
        varSize = 4

      else
        # TODO: Remove unneded assign.
        varSize = -1
        die('error: unhandled variable type: ' ~ str(symbolInfo.type))
      endif
    endif
  endmethod

  method pushOneParameterBeforeCall(param, paramIdx)
    global REG_PARAMS_CNT
    global REG_PARAMS32
    global REG_PARAMS64
    global SYMBOL_KIND_VAR_PARAM
    global SYMBOL_KIND_CONST

    if param is string
      varSize = this.getVariableSize(param)

      # TODO: Clean up this mess.
      symbolInfo = this.symbols{param}
      if symbolInfo is undefined
        if param is '__TrashBin'
          symbolInfo = {'kind': -1}
        else
          symbolInfo = this.globals{param}
        endif
      endif

      if paramIdx < REG_PARAMS_CNT
        if varSize is 4
          print '  mov', REG_PARAMS32[paramIdx], ', dword [', param, ']'

        elif varSize is 8
          if this.symbols{param}.type is 'float64'
            print '  movq xmm' ~ str(paramIdx), ', qword [', param, ']'
          else
            print '  mov', REG_PARAMS64[paramIdx], ', qword [', param, ']'
          endif

        elif varSize is 16
          if symbolInfo.kind is SYMBOL_KIND_VAR_PARAM
            print '  mov', REG_PARAMS64[paramIdx], ', [', param, ']'
          else
            print '  lea', REG_PARAMS64[paramIdx], ', [', param, ']'
          endif
        endif

      else
        if varSize is 4
          print '  mov  eax, dword [', param, ']'
          print '  push rax'

        elif varSize is 8
          print '  push qword [', param, ']'

        elif varSize is 16
          if symbolInfo.kind is SYMBOL_KIND_VAR_PARAM
            print '  push qword [', param, ']'
          else
            print '  lea rax, [', param, ']'
            print '  push rax'
          endif
        endif
      endif

    elif param is integer
      if (param < -2147483648) or (param > 2147483647)
        # 64-bit immediate.
        if paramIdx < REG_PARAMS_CNT
          print '  mov', REG_PARAMS64[paramIdx], ',', param
        else
          print '  mov rax,', param
          print '  push rax'
        endif

      else
        # 32-bit immediate.
        if paramIdx < REG_PARAMS_CNT
          print '  mov', REG_PARAMS32[paramIdx], ',', param
        else
          print '  push', param
        endif
      endif

    elif param is boolean
      # 32-bit boolean
      if paramIdx < REG_PARAMS_CNT
        print '  mov', REG_PARAMS32[paramIdx], ',', param
      else
        print '  push', param
      endif

    elif param is float
      #print '  db 0x48, 0xb8' # mov rax, float64
      #print '  dq', param
      print '  mov rax,', param

      if paramIdx < REG_PARAMS_CNT
        print '  movq xmm' ~ str(paramIdx), ', rax'
      else
        print '  push rax'
      endif

    else
      die('unhandled param type before push: ' ~ typeof(param))
    endif
  endmethod

  method pushParametersBeforeCall(params)
    global REG_PARAMS_CNT
    global REG_PARAMS32
    global REG_PARAMS64

    for indexes idx values oneParam in params
      # Skip unused params.
      if oneParam is defined
        this.pushOneParameterBeforeCall(oneParam, idx)
      else
        print '  ; skipped unused call param'
      endif
    endfor
  endmethod

  method setDestinationVariableBeforeCall(dst, paramIdx)
    # TODO: Optimize it.
    dstType = this._getSymbolType(dst)
    if dstType is @any('variant', 'string')
      this.pushOneParameterBeforeCall(dst, paramIdx)
    endif
  endmethod

  method _hash(x) -> rv
    # TODO: Optimize it.
    rv = typeof(x) ~ ':'

    if x is array
      rv = rv ~ str(len(x)) ~ ':'
      for values item in x
        rv = rv ~ this._hash(item)
      endfor

    else
      rv = rv ~ str(x)
    endif

    rv = rv ~ ';'
  endmethod

  method emitConstant(name, value, wantDeepIdx, deepIdx)
    isContentEmmited = false

    if wantDeepIdx is deepIdx
      bufferName = null

      if value is @any(array, string)
        # Check did we emit another buffer with the same content.
        hash       = this._hash(value)
        bufferName = this.mapOfEmittedBuffers{hash}

        if bufferName is defined
          # Buffer is already emited.
          # Just use it for another variable.
          print '; Reuse already emitted buffer'
          this.isBufferEmitted{name} = true

        else
          # Buffer is unique at this moment.
          # Generate new buffer name and go on.
          bufferName = name ~ '_buffer'

          # Save buffer name for further calls.
          this.mapOfEmittedBuffers{hash} = bufferName
        endif
      endif

      # Dispatch type.
      if value is integer
        print name, 'Variant_t VARIANT_INTEGER, 0,', value

      elif value is float
        print name, 'Variant_t VARIANT_DOUBLE, 0,', value

      elif value is string
        if len(value) is 1
          # One character string.
          # Possible improvement: Handle empty string?
          print name, 'Variant_t VARIANT_STRING, VARIANT_FLAG_ONE_CHARACTER,', ord(value)
        else
          # Multicharacter string.
          print name, 'Variant_t VARIANT_STRING, 0,', bufferName
        endif

      elif value is array
        print name, 'Variant_t VARIANT_ARRAY, 0,', bufferName

      elif value is boolean
        if value is true
          valueAsInteger = '1'
        else
          valueAsInteger = '0'
        endif

        print name, 'Variant_t VARIANT_BOOLEAN, 0,', valueAsInteger

      elif value is undefined
        print name, 'Variant_t VARIANT_UNDEFINED, 0, 0'

      else
        die('error: unhandled type: ' ~ typeof(value))
      endif
    endif

    # Emit buffer content for complex variables.
    if value is array
      this.emitArrayBufferHead(name, value, wantDeepIdx, deepIdx + 1)

    elif (value is string) and (len(value) isnt 1)
      this.emitStringBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitStringBufferHead(name, value, wantDeep, deepIdx)
    if this.isBufferEmitted{name} is undefined
      if wantDeep is deepIdx
        bufferName      = name ~ '_buffer'
        bufferNameBytes = name ~ '_bufferBytes'
        print  bufferName, 'Buffer_t', len(value) + 1, ', -1, 0,', bufferNameBytes
      endif

      this.emitStringBufferContent(name, value, wantDeep, deepIdx + 1)
    endif
  endmethod

  method escapeString(text) -> rv
    rv = '"'
    for values character in text
      if character is '"'
        rv = rv ~ '", 34, "'
      else
        rv = rv ~ character
      endif
    endfor
    rv = rv ~ '"'
  endmethod

  method emitStringBufferContent(name, value, wantDeep, deepIdx)
    if wantDeep is deepIdx
      bufferNameBytes = name ~ '_bufferBytes'
      bufferData      = this.escapeString(value)

      print bufferNameBytes, 'StringHead_t', len(value)
      print ' db ', bufferData, ', 0'
    endif
  endmethod

  method emitArrayBufferHead(name, items, wantDeepIdx, deepIdx)
    if this.isBufferEmitted{name} is undefined
      if wantDeepIdx is deepIdx
        itemsCnt        = len(items)
        bufferName      = name ~ '_buffer'
        bufferNameBytes = name ~ '_bufferBytes'

        print bufferName, 'Buffer_t', itemsCnt * 16, ', -1, 0,',  bufferNameBytes
      endif

      this.emitArrayBufferContent(name, items, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitArrayBufferContent(name, items, wantDeepIdx, deepIdx)
    itemsCnt = len(items)

    if wantDeepIdx is deepIdx
      # TODO: Optimize it.
      # TODO: Move innerType check to earliear stage.
      innerType        = typeof(items[0])
      innerSize        = 0
      innerTypeForEmit = '0'
      innerAsmType     = 'db'
      innerValueMin    = items[0] # TODO: Use MAX_INTEGER like const?
      innerValueMax    = items[0] # TODO: Use MIN_INTEGER like const?
      innerItemIdx     = 0
      itemValue        = null

      goOn = true

      while (goOn is true) and (innerItemIdx < itemsCnt)
        itemValue = items[innerItemIdx]
        itemType  = typeof(itemValue)

        if itemType isnt innerType
          # Various types in one array.
          # Fall-back to variant storage and don't go anymore.
          innerTypeForEmit = '0'
          goOn             = false

        elif itemType is 'integer'
          innerTypeForEmit = 'VARIANT_INTEGER'

          # Track max/min values to compact array storage.
          if (innerSize < 3) and ((itemValue < -2147483648) or (itemValue > 2147483647))
           # 2^3 bytes = 8 bytes = 64 bit (qword)
           innerSize    = 3
           innerAsmType = 'dq'

          elif (innerSize < 2) and ((itemValue < -32768) or (itemValue > 32767))
           # 2^2 bytes = 4 bytes = 32 bit (dword)
           innerSize    = 2
           innerAsmType = 'dd'

          elif (innerSize < 2) and ((itemValue < -128) or (itemValue > 127))
           # 2^1 bytes = 2 bytes = 16 bit (word)
           innerSize    = 1
           innerAsmType = 'dw'
          endif
        endif

        # Go to next item.
        innerItemIdx = innerItemIdx + 1
      endwhile

      # print '; innerType:'     , innerType
      # print '; innerValueMin:' , innerValueMin
      # print '; innerValueMax:' , innerValueMax

      bufferName      = name ~ '_buffer'
      bufferNameBytes = name ~ '_bufferBytes'

      print bufferNameBytes, 'dd', innerTypeForEmit, '; inner type'
      print 'db', innerSize, ' ; inner size'
      print 'db ?, ?, ? ; reserved'
      print 'dq', itemsCnt, '; itemsCnt'

      # Emit items as flat array if possible.
      if innerTypeForEmit isnt '0'
        __mold_printToStdOutput(innerAsmType)
        sep = ' '

        for itemIdx in 0 .. itemsCnt
          __mold_printToStdOutput(sep)

          if items[itemIdx] is defined
            __mold_printToStdOutput(items[itemIdx])
          else
            __mold_printToStdOutput('0')
          endif

          sep = ', '
        endfor
        print ''

        # Don't go on recursively.
        itemsCnt = -1
      endif
    endif

    # Go on recursively for variant arrays.
    for itemIdx in 0 .. itemsCnt
      this.emitConstant(name ~ '_' ~ str(itemIdx), items[itemIdx], wantDeepIdx, deepIdx)
    endfor
  endmethod

  method _getSymbolType(id) -> rv
    global SYMBOL_KIND_LABEL

    if id is string
      rv = 'variant'
      symbolInfo = this.symbols{id}

      if symbolInfo is defined
        if symbolInfo.type is defined
          rv = symbolInfo.type

        elif symbolInfo.kind is SYMBOL_KIND_LABEL
          rv = 'label'
        endif
      endif

    elif id is integer
      if (id < -2147483648) or (id > 2147483647)
        rv = 'int64'
      else
        rv = 'int32'
      endif

    elif id is float
      rv = 'float64'

    elif id is boolean
      rv = 'bool32'

    else
      rv = 'custom'
    endif
  endmethod

  method _syscall(id)
    if id is integer
      print '  call qword [rbx + 8 *', id, ']'
    else
      print '  mov eax, dword [', id, ']'
      print '  call qword [rbx]'
    endif
  endmethod

  method run(codeObj)
    global SYMBOL_KIND_VAR_LOCAL, SYMBOL_KIND_VAR_GLOBAL, SYMBOL_KIND_CONST
    global SYMBOL_KIND_VAR_PARAM, SYMBOL_KIND_JMP_TABLE, SYMBOL_KIND_VAR_RETVAL
    global REG_PARAMS_CNT, REG_PARAMS32, REG_PARAMS64
    global MIR_TO_VARIANT_TYPE_MAP, MIR_TYPE_SIZE_MAP

    # TODO: Remove _ prefix.
    global _VARIANT_INTEGER
    global _VARIANT_STRING
    global _VARIANT_DOUBLE
    global _VARIANT_BOOLEAN

    global MIR1_OPCODE_COMMENT, MIR1_OPCODE_LABEL
    global MIR1_OPCODE_PROC, MIR1_OPCODE_ENDP
    global MIR1_OPCODE_MOVE, MIR1_OPCODE_CONV
    global MIR1_OPCODE_NEG, MIR1_OPCODE_ADD, MIR1_OPCODE_SUB
    global MIR1_OPCODE_MUL, MIR1_OPCODE_DIV, MIR1_OPCODE_IDIV
    global MIR1_OPCODE_CMP_EQ, MIR1_OPCODE_CMP_NE, MIR1_OPCODE_CMP_LT
    global MIR1_OPCODE_CMP_LE, MIR1_OPCODE_CMP_GT, MIR1_OPCODE_CMP_GE
    global MIR1_OPCODE_CMP_IS_TYPEOF, MIR1_OPCODE_CMP_IS_NOT_TYPEOF
    global MIR1_OPCODE_JMP_IF_TYPEOF, MIR1_OPCODE_JMP_IF_NOT_TYPEOF
    global MIR1_OPCODE_JMP, MIR1_OPCODE_JMP_BY_TABLE
    global MIR1_OPCODE_JMP_IF_TRUE, MIR1_OPCODE_JMP_IF_FALSE
    global MIR1_OPCODE_JMP_IF_EQ, MIR1_OPCODE_JMP_IF_NE
    global MIR1_OPCODE_JMP_IF_LT, MIR1_OPCODE_JMP_IF_LE
    global MIR1_OPCODE_JMP_IF_GT, MIR1_OPCODE_JMP_IF_GE
    global MIR1_OPCODE_CALL, MIR1_OPCODE_VCALL, MIR1_OPCODE_SYSCALL
    global MIR1_OPCODE_RET, MIR1_OPCODE_INNER_RET
    global MIR1_OPCODE_NOP, MIR1_OPCODE_STRING_JOIN
    global MIR1_OPCODE_LOAD_NULL, MIR1_OPCODE_PRINT
    global MIR1_OPCODE_CREATE_OBJECT, MIR1_OPCODE_CREATE_ARRAY
    global MIR1_OPCODE_CREATE_MAP
    global MIR1_OPCODE_STORE_INDEX, MIR1_OPCODE_LOAD_INDEX
    global MIR1_OPCODE_STORE_KEY, MIR1_OPCODE_LOAD_KEY
    global MIR1_OPCODE_CREATE_VARIANT_FROM, MIR1_OPCODE_CAST_VARIANT_TO
    global MIR1_OPCODE_INIT_FRAME
    global MIR1_OPCODE_CMP_CC_GROUP, MIR1_OPCODE_JMP_IF_CC_GROUP
    global MIR_COMPARE_FLAGS_FOR_INTEGERS, MIR_COMPARE_FLAGS_FOR_FLOATS
    global MIR_ALU_OPCODES_FOR_INTEGERS, MIR_ALU_OPCODES_FOR_FLOATS
    global MIR1_OPCODE_ALU2_GROUP

    global MIR1_FIRST_DST_OP_X_Y_OPCODE
    global MIR1_FIRST_CALL_LIKE_OPCODE
    global MIR1_FIRST_CUSTOM_OPCODE

    #
    # Common headers.
    #

    print 'format PE64 console 5.0'
    print 'entry __MOLD_Main'

    print '; ------------------------------------------------------------------------------'
    print ';                                 Code section'
    print '; ------------------------------------------------------------------------------'

    print "section '.text' code readable executable"
    print "stack 1024*1024*4, 1024*1024*4"
    print "include 'x64\Variant.asm'"

    #
    # Fetch code and code metas.
    #

    quads = codeObj.quads

    currentProcProto    = null
    currentProcName     = null
    currentProcRv       = null
    currentProcRvType   = null
    currentSymbols      = {}
    currentFrameSize    = 0
    currentFrameOffsets = {}

    isInsideVcall = false

    dst = null
    x   = null
    y   = null

    opcode         = 0
    originalOpcode = 0
    paramsCnt      = 0

    # TODO: Remove it.
    arrayOfProcedures     = []
    arrayOfMessageFormats = []
    fmtHashToIdMap        = {}

    # TODO: Clean up this mess.
    fakeSymbolInfoForEOL   = {'name': '__EOL'}
    fakeSymbolInfoForGlued = {'name': '@glued'}

    this.globals = codeObj.symbolTable.exportSymbols()

    #
    # Translate code section.
    #

    for values item in quads
      # Fetch instruction
      itemCnt = len(item)
      opcode  = item[0]
      dst     = item[1]
      x       = item[2]
      y       = item[3]

      dstType = this._getSymbolType(dst)
      xType   = this._getSymbolType(x)
      yType   = this._getSymbolType(y)

      #if ((opcode isnt MIR1_OPCODE_COMMENT) and
      #    (opcode isnt MIR1_OPCODE_PROC) and
      #    (opcode isnt MIR1_OPCODE_INIT_FRAME))
      #  print '  ; [x64]', opcode, dst, x, y
      #endif

      isOpcodeHandled = true

      # ----------------------------------------------------------------------
      #                   Opcodes with custom handlers
      # ----------------------------------------------------------------------

      if opcode >= MIR1_FIRST_CUSTOM_OPCODE

        if opcode is MIR1_OPCODE_CREATE_ARRAY
          this.variantDestroy(dst)
          if x is defined
            this.call2('__MOLD_VariantArrayCreateFromInitList', dst, x)
          else
            this.call1('__MOLD_VariantArrayCreate', dst)
          endif

        elif opcode is MIR1_OPCODE_CREATE_MAP
          this.variantDestroy(dst)
          if x is defined
            this.call3('__MOLD_VariantMapCreateFromInitList', dst, x, y)
          else
            this.call1('__MOLD_VariantMapCreate', dst)
          endif

        elif opcode is MIR1_OPCODE_JMP_BY_TABLE
          symbolInfo = codeObj.symbolTable.lookup(dst)

          print '  mov eax, dword [', x, ']'
          print '  sub eax,', symbolInfo.valueMin
          print '  cmp eax,', symbolInfo.valueMax - symbolInfo.valueMin
          print '  ja', symbolInfo.defaultLabel

          print '  movsx rax, word [', dst, '+ rax * 2]'
          print '  lea rax, [', symbolInfo.defaultLabel, '+ rax]'
          print '  jmp rax'

        elif opcode is MIR1_OPCODE_STRING_JOIN
          this.call3AndDestroy('__MOLD_VariantStringJoin', x, y, dst)

        elif opcode is @any(MIR1_OPCODE_CMP_IS_TYPEOF,
                            MIR1_OPCODE_CMP_IS_NOT_TYPEOF,
                            MIR1_OPCODE_JMP_IF_TYPEOF,
                            MIR1_OPCODE_JMP_IF_NOT_TYPEOF)

          if xType is 'variant'
            this.pushOneParameterBeforeCall(x, 0)
            print '  cmp [rcx + Variant_t.type],', y

            if opcode is MIR1_OPCODE_CMP_IS_TYPEOF
              print '  setz cl'
              print '  and ecx, 1'
              this.storeResultAfterCall(dst)

            elif opcode is MIR1_OPCODE_CMP_IS_NOT_TYPEOF
              print '  setnz cl'
              print '  and ecx, 1'
              this.storeResultAfterCall(dst)

            elif opcode is MIR1_OPCODE_JMP_IF_TYPEOF
              print '  jz', dst

            elif opcode is MIR1_OPCODE_JMP_IF_NOT_TYPEOF
              print '  jnz', dst
            endif

          else
            # TODO: Resolve at earlier stage.
            cmpResult = false

            if xType is 'float64'
              cmpResult = y is _VARIANT_DOUBLE

            elif xType is 'int32'
              cmpResult = y is _VARIANT_INTEGER

            elif xType is 'bool32'
              cmpResult = y is _VARIANT_INTEGER

            elif xType is 'string'
              cmpResult = y is _VARIANT_STRING
            endif

            if opcode is MIR1_OPCODE_CMP_IS_TYPEOF
              this.store32(dst, cmpResult)

            elif opcode is MIR1_OPCODE_CMP_IS_NOT_TYPEOF
              # TODO: Use not x
              if cmpResult is true
                this.store32(dst, false)
              else
                this.store32(dst, true)
              endif

            elif opcode is MIR1_OPCODE_JMP_IF_TYPEOF
              if cmpResult is true
                print '  jmp', dst
              endif

            elif opcode is MIR1_OPCODE_JMP_IF_NOT_TYPEOF
              if cmpResult is false
                print '  jmp', dst
              endif
            endif
          endif

        elif opcode is MIR1_OPCODE_CREATE_OBJECT
          this.variantDestroy(dst)
          print '  lea  rcx, [', dst, ']'
          print '  lea  rdx, [vtable_' ~ str(x) ~ ']'
          print '  call __MOLD_VariantObjectCreate'

        elif opcode is MIR1_OPCODE_STORE_INDEX
          # dst[x] := y
          this.pushOneParameterBeforeCall(dst, 0)
          this.pushOneParameterBeforeCall(x, 1)
          this.pushOneParameterBeforeCall(y, 2)
          print '  call __MOLD_VariantStoreAtIndex_' ~ yType

        elif opcode is MIR1_OPCODE_STORE_KEY
          # dst{x} := y
          this.pushOneParameterBeforeCall(dst, 0)
          this.pushOneParameterBeforeCall(x, 1)
          this.pushOneParameterBeforeCall(y, 2)
          print '  call __MOLD_VariantStoreAtKey_' ~ yType

        elif opcode is MIR1_OPCODE_COMMENT
          print ';', dst

        elif opcode is MIR1_OPCODE_LABEL
          print dst ~ ':'

        elif opcode is MIR1_OPCODE_JMP
         print '  jmp', dst

        elif opcode is MIR1_OPCODE_LOAD_NULL
          this.variantDestroy(dst)

        elif opcode is MIR1_OPCODE_PRINT
          params    = dst
          paramsCnt = len(params)

          # Build msg format.
          encodedFormat     = []
          encodedFormatHash = ''

          for values oneParam in params
            if oneParam is string
              symbolInfo = currentSymbols{oneParam}

              if symbolInfo is defined
                encodedFormat[@afterlast] = symbolInfo
                encodedFormatHash = encodedFormatHash ~ 'l:' ~ str(symbolInfo.kind) ~ ':' ~ str(symbolInfo.name)

              elif oneParam is '__EOL'
                # TODO: Clean up this mess.
                encodedFormat[@afterlast] = fakeSymbolInfoForEOL
                encodedFormatHash = encodedFormatHash ~ '@eol'

              elif oneParam is '@glued'
                # TODO: Clean up this mess.
                encodedFormat[@afterlast] = fakeSymbolInfoForGlued
                encodedFormatHash = encodedFormatHash ~ '@glued'

              else
                encodedFormat[@afterlast] = codeObj.symbolTable.lookup(oneParam)
                encodedFormatHash = encodedFormatHash ~ 'g:' ~ oneParam
              endif

            else
              # Immediate value.
              # Build fake one-time symbol format.
              encodedFormat[@afterlast] = {
                'name': 'imm',
                'kind': SYMBOL_KIND_CONST,
                'value': oneParam,
                'readHits': 1
              }
              encodedFormatHash = encodedFormatHash ~ 'imm:' ~ str(oneParam)
            endif

            encodedFormatHash = encodedFormatHash ~ ';'
          endfor

          messageFormatId = fmtHashToIdMap{encodedFormatHash}

          if messageFormatId isnt defined
            arrayOfMessageFormats[@afterlast] = encodedFormat
            messageFormatId                   = len(arrayOfMessageFormats) - 1
            fmtHashToIdMap{encodedFormatHash} = messageFormatId
          endif

          print '  lea rcx, [__fmt' ~ str(messageFormatId), ']'
          print '  call __MOLD_PrintFormatFromMemory'

        elif opcode is MIR1_OPCODE_PROC
          proto            = item[1]
          currentProcProto = proto
          currentProcName  = proto.name
          currentProcRv    = proto.rv
          currentSymbols   = proto.symbols
          isInsideVcall    = false

          if currentProcRv is defined
            symbolInfo        = currentSymbols{currentProcRv}
            currentProcRvType = symbolInfo.type
          endif

          # Extra entry point for virtual call.
          # Virtual call params are always variants.
          # We need to translave variants to primitive before go on.
          if @all(currentSymbols{'this'},
                  codeObj.methodsMap{proto.shortName}) is defined

            isInsideVcall = true
            paramsCnt     = len(proto.params)

            print currentProcName ~ '_vcall:'

            for indexes paramIdx values paramName in proto.params
              symbolInfo = currentSymbols{paramName}

              if @all(symbolInfo.readHits, symbolInfo.writeHits) is 0
                print '  ; skipped unused parameter [', paramName, ']'
              else
                symbolType = symbolInfo.type

                # TODO: Clean up this mess.
                if symbolType is defined
                  symbolSize = MIR_TYPE_SIZE_MAP{symbolType}
                else
                  symbolSize = 16
                endif

                if symbolSize <= 8
                  # Primitive type.
                  expectedType = MIR_TO_VARIANT_TYPE_MAP{symbolType}

                  # TODO: Optimize it.
                  if paramIdx < 3
                    reg = REG_PARAMS64[paramIdx + 1]
                    print '  cmp [', reg, ' + Variant_t.type],', expectedType
                    print '  jnz __MOLD_PrintErrorAndDie.implicitConversion'
                    print '  mov ', reg, ', [', reg, ' + Variant_t.value]'
                    print ''

                  else
                    paramOffset = (paramsCnt - paramIdx) * 8
                    print '  mov r10, [rsp +', paramOffset, ']'
                    print '  cmp [r10 + Variant_t.type],', expectedType
                    print '  jnz __MOLD_PrintErrorAndDie.implicitConversion'
                    print '  mov r10, [r10 + Variant_t.value]'
                    print '  mov [rsp +', paramOffset, '], r10'
                    print ''
                  endif
                endif
              endif
            endfor

            # Make sure return value is passed as variant.
            # TODO: Handle non-variant return value for vcalls?
            if currentProcRv is defined
              rvSize        = MIR_TYPE_SIZE_MAP{currentProcRvType}
              rvVariantType = MIR_TO_VARIANT_TYPE_MAP{currentProcRvType}

              if rvSize <= 8
                # Original function returns primitive type.
                # Redirect original return value pointer to variant_t.value part.
                print '  mov  [rax + Variant_t.type],', rvVariantType

                if rvSize is 4
                  # 32-bit result.
                  # Zero fill higher dword of value part.
                  # Caller need to sign-extend it to 64-bit if needed.
                  print '  mov  [rax + Variant_t.value], 0'
                  print '  add  rax, Variant_t.value'
                else
                  # 64-bit result.
                  # Just skip to to value part.
                  print '  add  rax, Variant_t.value'
                endif

                print ''
              endif
            endif
          endif

          # Ordinary entry point.
          # This address can be called directly with primitive params.
          print currentProcName ~ ':'

          arrayOfProcedures[@afterlast] = currentProcName

          # Profiler code if needed.
          if this.isProfilerEnabled is true
            print '  ; enter profiler code'
            print '  ; -------------------'
            print '  push   rdx'
            print '  rdtsc'
            print '  shl    rdx, 32'
            print '  add    rdx, rax'
            print '  sub    qword [__profilerCounterEntry_' ~ currentProcName ~ '], rdx'
            print '  pop    rdx'
          endif

        elif opcode is MIR1_OPCODE_INIT_FRAME
          currentFrame = dst
          symbols      = currentFrame.symbols
          params       = currentFrame.params
          paramsCnt    = len(params)

          # Clean up this mess.
          this.symbols = symbols

          print '  ; init frame'
          print '  ; ----------'

          # Calculate frame size.
          currentFrameSize = 0
          paramsPassedCnt  = paramsCnt

          if currentFrame.rv is defined
            print ' ', currentFrame.rv, 'EQU rdi'
          endif

          if symbols{'this'} is defined
            # TODO: Dirty fix to handle real number of stack parameters if 'this'
            # pointer is used.
            paramsPassedCnt = paramsPassedCnt + 1
          endif

          if paramsPassedCnt > 0
            paramIdx = 0
            for values symbol in symbols
              if symbol.kind is SYMBOL_KIND_VAR_PARAM
                if paramIdx < 4
                  currentFrameSize = currentFrameSize + 8
                  rbpOffset        = - (8 + currentFrameSize)
                  print ' ', symbol.name, 'EQU rbp', rbpOffset, '; param', str(paramIdx + 1), '(reg)'

                else
                  rbpOffset = 8 + 8 * paramsPassedCnt - paramIdx * 8
                  print ' ', symbol.name, 'EQU rbp +', rbpOffset, '; param', str(paramIdx + 1), '(stack)'
                endif

                symbol.rbpOffset = rbpOffset
                paramIdx = paramIdx + 1
              endif
            endfor
            print ''
          endif

          # Pass #1: Allocate variant varibles on stack before all others.
          # TODO: Clean up this mess.
          # TODO: Don't repeat code.
          for values symbol in symbols
            if @any(symbol.readHits, symbol.writeHits) > 0
              if symbol.kind is SYMBOL_KIND_VAR_LOCAL

                if symbol.type is @any(undefined, 'variant', 'string')
                  varSize          = 16
                  currentFrameSize = currentFrameSize + varSize
                  symbol.rbpOffset = - (8 + currentFrameSize)
                  print ' ', symbol.name, 'EQU rbp -', 8 + currentFrameSize, ';', varSize, 'bytes, (kind=', symbol.kind, ', type=', symbol.type, ', writeHits=', symbol.writeHits, ', readHits=', symbol.readHits, ')'
                endif
              endif
            endif
          endfor

          # Pass #2: Allocate primitive values on stack.
          for values symbol in symbols
            if @any(symbol.readHits, symbol.writeHits) > 0
              if symbol.kind is SYMBOL_KIND_VAR_LOCAL
                varSize = this.getVariableSize(symbol.name)
                if varSize < 16
                  currentFrameSize = currentFrameSize + varSize
                  symbol.rbpOffset = - (8 + currentFrameSize)
                  print ' ', symbol.name, 'EQU rbp -', 8 + currentFrameSize, ';', varSize, 'bytes, (kind=', symbol.kind, ', type=', symbol.type, ', writeHits=', symbol.writeHits, ', readHits=', symbol.readHits, ')'
                endif
              endif
            endif
          endfor

          # Align to 16-bytes and add 32-byte shadow space.
          currentFrameSize = bitand(currentFrameSize + 32 + (16 - 1), -16)

          print ''
          print '  push rbp'
          print '  mov  rbp, rsp'

          if currentFrame.rv is defined
            print ''
            print '  push rdi'
            print '  mov  rdi, rax'
            print ''
          endif

          print '  sub  rsp,', currentFrameSize
          print ''

          paramIdx  = 0
          isRaxZero = false

          for values oneItem in symbols
            if oneItem.kind is SYMBOL_KIND_VAR_LOCAL
              if oneItem.type is @any(undefined, 'variant', 'string')
                # Local Variant_t variable - init to undefined.
                if oneItem.usedAsIterator is defined
                  # Symbol is used as loop iterator.
                  # It's only dump reference for existing box values or keys.
                  print '  ; Skipped loop iterator', oneItem.item
                else
                  if isRaxZero is false
                    print '  xor eax, eax'
                    isRaxZero = true
                  endif
                  print '  mov [' ~ oneItem.name ~ ' + Variant_t.type], eax'
                endif
              endif

            elif oneItem.kind is SYMBOL_KIND_VAR_PARAM
              # Call parameter - copy to local var.
              if @any(oneItem.readHits, oneItem.writeHits) > 0
                varSize    = this.getVariableSize(oneItem.name)
                movOpcode8 = 'mov'

                if paramIdx < 4
                  if oneItem.type is 'float64'
                    srcPtr     = 'xmm' ~ str(paramIdx)
                    movOpcode8 = 'movq'

                  elif varSize is 4
                    srcPtr = REG_PARAMS32[paramIdx]

                  else
                    srcPtr = REG_PARAMS64[paramIdx]
                  endif

                  if varSize is 4
                    print '  mov dword [', oneItem.name, '],', srcPtr
                  else
                    print ' ', movOpcode8, 'qword [', oneItem.name, '],', srcPtr
                  endif
                endif
              else
                print '  ; skipped unused param [', oneItem.name, ']'
              endif

              paramIdx = paramIdx  + 1
            endif
          endfor

          if currentProcName is 'start'
            print ''
            for values oneItem in symbols
              # TODO: Better way to exclude external vars.
              if oneItem.name is @any('argv', 'argc')
                # Do nothing.

              elif ((oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and
                    (oneItem.type is @any(undefined, 'variant')))
                print '  mov [' ~ oneItem.name ~ ' + Variant_t.type], VARIANT_UNDEFINED'
              endif
            endfor
          endif

          print ''
          print '  ; code'
          print '  ; ----'

        elif opcode is MIR1_OPCODE_MOVE
          if xType is @any('variant', 'string')
            this.variantDestroy(dst)
            this.variantMove(dst, x)
          else
            this.pushOneParameterBeforeCall(x, 0)
            this.storeResultAfterCall(dst)
          endif

        elif opcode is MIR1_OPCODE_NOP
          print '  nop'

        elif opcode is MIR1_OPCODE_RET
          print ''
          print '  ; clean frame'
          print '  ; -----------'

          # TODO: Clean up this mess.
          for values oneItem in currentSymbols
            # TODO: Clean up this mess.
            if ((oneItem.kind is SYMBOL_KIND_VAR_LOCAL) and
                (oneItem.type is @any(undefined, 'variant', 'string')))

              if oneItem.usedAsIterator is defined
                # Symbol is used as loop iterator.
                # It's only dump reference for existing box values or keys.
                print '  ; Skipped loop iterator', oneItem.name

              else
                this.variantDestroy(oneItem.name)
              endif
            endif
          endfor

          # Profiler code if needed.
          if this.isProfilerEnabled is true
            print '  ; leave profiler code'
            print '  ; -------------------'
            print '  push   rdx'
            print '  rdtsc'
            print '  shl    rdx, 32'
            print '  add    rdx, rax'
            print '  add    qword [__profilerCounterEntry_' ~ currentProcName ~ '], rdx'
            print '  pop    rdx'

            if currentProcName is 'start'
              print ''
              print '  ; print profiler result'
              print '  ; ---------------------'
              print '  lea  rcx, [__profilerCounterData]'
              print '  call __MOLD_PrintProfilerData'
              print ''
            endif
          endif

          if currentProcName is 'start'
            for values oneItem in currentSymbols

              if ((oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and
                  (oneItem.type is @any(undefined, 'variant')))

                this.variantDestroy(oneItem.name)
              endif
            endfor
          endif

          print ''
          print '  add  rsp,', currentFrameSize

          if currentProcRv is defined
            if (isInsideVcall is true) and (currentProcRvType is 'int32')
              # Set sign flag for int32 vcall result.
              print '  or dword [', currentProcRv, '], 0'
            endif
            print '  pop  rdi'
          endif

          print '  pop  rbp'
          print '  ret'

        elif opcode is MIR1_OPCODE_INNER_RET
          # TODO: Better handling of nested procedures.
          print '  ret'

        elif opcode is MIR1_OPCODE_ENDP
          print ''
          # TODO: Clean up this mess.
          for values oneItem in currentSymbols
            if oneItem.kind is @any(SYMBOL_KIND_VAR_LOCAL,
                                    SYMBOL_KIND_VAR_PARAM,
                                    SYMBOL_KIND_VAR_RETVAL)

              if @any(oneItem.readHits, oneItem.writeHits) > 0
                print '  restore', oneItem.name
              endif
            endif
          endfor

        else
          isOpcodeHandled = false
        endif

      # ------------------------------------------------------------------------
      #                           Call-like opcodes
      # ------------------------------------------------------------------------

      elif opcode >= MIR1_FIRST_CALL_LIKE_OPCODE
        # dst = x(y, ....)
        nameOrId  = x
        params    = y
        paramsCnt = len(params)

        if ((opcode is MIR1_OPCODE_CALL) and
            (nameOrId is @any('__MOLD_ForDriver_Generic',
                              '__MOLD_ForDriver_IndexesAndValuesInArray',
                              '__MOLD_ForDriver_IndexesAndValuesInArrayOrString',
                              '__MOLD_ForDriver_KeysAndValuesInMap')))

          # TODO: Clean up this mess.
          this.pushOneParameterBeforeCall(params[0], 0)
          print '  lea rdx, [', params[1], ']'
          print '  lea r8, [', params[2], ']'
          print '  lea r9, [', params[3], ']'
          print '  call', nameOrId

        else

          # Push call parameters.
          this.pushParametersBeforeCall(params)

          # Push pointer to return value if any.
          if dst is defined
            # TODO: Standarize return value passing.
            if opcode is MIR1_OPCODE_SYSCALL
              # Add pointer to the return-value buffer as the last param.
              this.pushOneParameterBeforeCall(dst, paramsCnt)
            else
              print '  lea rax, [', dst, ']'
            endif
          endif

          # Generate call opcode.
          if opcode is MIR1_OPCODE_SYSCALL
            # dst = syscall(id, ...)
            # TODO: Why we sometimes got string 'id' here?
            this._syscall(nameOrId)

          elif opcode is MIR1_OPCODE_CALL
            # dst = foo(...)
            this.call(nameOrId)

          elif opcode is MIR1_OPCODE_VCALL
            methodId  = nameOrId

            if dst is defined
              # dst = obj.foo(...)
              # TODO: Better way to handle 32-bit int result?
              signOkLabel = codeObj.symbolTable.createLabel()

              print '  mov  r10d,', methodId
              print '  call __MOLD_VCall'

              print ''
              print '  ; 32-bit int sign extend after vcall if needed.'
              print '  jns', signOkLabel
              print '  movsxd rax, dword [', dst, '+ Variant_t.value ]'
              print '  mov    qword [', dst, '+ Variant_t.value ], rax'
              print signOkLabel ~ ':'
              print ''

            else
              # obj.foo(...)
              print '  mov  r10d,', methodId
              print '  call __MOLD_VCall'
            endif

          else
            isOpcodeHandled = false
          endif

          # Clean stack after call if needed.
          if paramsCnt > 4
            print '  add rsp,', paramsCnt * 8 - 32
          endif
        endif

      # ------------------------------------------------------------------------
      #                         Opcodes: dst = op(x, y)
      # ------------------------------------------------------------------------

      elif opcode >= MIR1_FIRST_DST_OP_X_Y_OPCODE

        this.pushOneParameterBeforeCall(x, 0)
        this.pushOneParameterBeforeCall(y, 1)
        this.setDestinationVariableBeforeCall(dst, 2)

        opcodeMajor = bitand(opcode, 0xf8)
        opcodeMinor = bitand(opcode, 0x7)

        if opcode is MIR1_OPCODE_LOAD_INDEX
          # dst := x[y]
          print '  call __MOLD_VariantLoadFromIndex'

        elif opcode is MIR1_OPCODE_LOAD_KEY
          # dst := x{y}
          print '  call __MOLD_VariantLoadFromKey_' ~ dstType

        elif xType is @any('variant', 'string')
          if opcodeMajor is MIR1_OPCODE_CMP_CC_GROUP
            print '  call __MOLD_Variant_cmp_' ~ MIR_COMPARE_FLAGS_FOR_INTEGERS[opcodeMinor]

          elif opcodeMajor is MIR1_OPCODE_JMP_IF_CC_GROUP
            print '  call __MOLD_Variant_cmp_' ~ MIR_COMPARE_FLAGS_FOR_INTEGERS[opcodeMinor]
            print '  test ecx, ecx'
            print '  jnz', dst

          elif opcodeMajor is MIR1_OPCODE_ALU2_GROUP
            print '  call __MOLD_Variant_' ~ MIR_ALU_OPCODES_FOR_INTEGERS[opcodeMinor]
          endif

        elif opcodeMajor is @any(MIR1_OPCODE_CMP_CC_GROUP,
                                 MIR1_OPCODE_JMP_IF_CC_GROUP)

          if xType is 'float64'
            cmpFlag = MIR_COMPARE_FLAGS_FOR_FLOATS[opcodeMinor]
            print '  comisd xmm0, xmm1'
          else
            cmpFlag = MIR_COMPARE_FLAGS_FOR_INTEGERS[opcodeMinor]
            print '  cmp ecx, edx'
          endif

          if opcodeMajor is MIR1_OPCODE_CMP_CC_GROUP
            print '  set' ~ cmpFlag, 'cl'
            print '  and ecx, 1'
          else
            print '  j' ~ cmpFlag, dst
          endif

        #
        # Arithmetic
        #

        elif opcodeMajor is MIR1_OPCODE_ALU2_GROUP

          if (opcode is MIR1_OPCODE_DIV) and (xType is 'int32')
            print '  cvtsi2sd  xmm0, rcx'  # xmm0 = double(x)
            print '  cvtsi2sd  xmm1, rdx'  # xmm1 = double(y)
            print '  divsd     xmm0, xmm1' # xmm0 = x / y

          elif opcode is MIR1_OPCODE_IDIV
            if xType is 'int32'
              print '  mov  eax, ecx'  # ; eax     = x
              print '  mov  ecx, edx'  # ; ecx     = y
              print '  cdq'            # ; edx:eax = x
              print '  idiv ecx'       # ; eax     = x // y
              print '  mov  ecx, eax'  # ; ecx     = x // y (TODO)

            else
              print '  divsd xmm0, xmm1'     # xmm0 = x / y
              print '  cvttsd2si rcx, xmm0'  # rcx  = int(x / y)
            endif

          elif xType is 'float64'
            print ' ', MIR_ALU_OPCODES_FOR_FLOATS[opcodeMinor], 'xmm0, xmm1'

          elif xType is 'int32'
            print ' ', MIR_ALU_OPCODES_FOR_INTEGERS[opcodeMinor], 'ecx, edx'
          endif

        else
          isOpcodeHandled = false
        endif

        this.storeResultAfterCall(dst)

      else

        # ----------------------------------------------------------------------
        #                          dst = opcode(x)
        # ----------------------------------------------------------------------

        this.pushOneParameterBeforeCall(x, 0)
        this.setDestinationVariableBeforeCall(dst, 1)

        if opcode is MIR1_OPCODE_CAST_VARIANT_TO
          # Cast variant to primitive.
          # dst = x.value
          this.call('__MOLD_VariantCastTo_' ~ dstType)

        elif opcode is MIR1_OPCODE_CREATE_VARIANT_FROM
          # Create variant from primitive.
          # dst.value = x
          this.call('__MOLD_VariantCreateFrom_' ~ xType)

        elif opcode is MIR1_OPCODE_NEG
          if xType is 'int32'
            print '  neg ecx'

          elif xType is 'float64'
            # TODO: Optimize it.
            print '  pxor xmm0, xword [__MOLD_VariantNeg.signBit]'

          elif xType is 'variant'
            this.call('__MOLD_VariantNeg')
          endif

        elif opcode is @any(MIR1_OPCODE_JMP_IF_TRUE,
                            MIR1_OPCODE_JMP_IF_FALSE)

          if xType is 'variant'
            print '  test byte [rcx + Variant_t.value], 0'
          elif xType is 'bool32'
            print '  test ecx, ecx'
          endif

          if opcode is MIR1_OPCODE_JMP_IF_TRUE
            print '  jnz', dst
          else
            print '  jz', dst
          endif

        else
          isOpcodeHandled = false
        endif

        this.storeResultAfterCall(dst)
      endif

      if isOpcodeHandled is false
        die('error: unhandled opcode "' ~ MIR1_GetOpcodeAsText(opcode) ~ '"')
      endif

      # Separate MIR opcodes by new line for better readability.
      if opcode isnt MIR1_OPCODE_COMMENT
        print ''
      endif
    endfor

    print ''
    print 'endOfCodeSection:'

    #
    # Generate data section.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                                 Data section'
    print '; ------------------------------------------------------------------------------'
    print "section '.data' data readable writeable"

    print "include 'x64\CommonData.asm'"
    print ''

    print ''
    print '; Global vars'
    print '; -----------'

    for values oneItem in this.globals
      if (oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and (oneItem.writeHits > 0)
        if oneItem.type is @any('variant', 'string', undefined)
          print oneItem.name, ' Variant_t 0, 0, 0'

        elif oneItem.type is 'int64'
          print oneItem.name, ' dq 0'

        elif oneItem.type is 'int32'
          print oneItem.name, ' dd 0'

        elif oneItem.type is 'float64'
          print oneItem.name, ' dq 0'

        elif oneItem.type is 'bool32'
          print oneItem.name, ' dd 0'

        else
          die('error: unhandled global type: ' ~ str(oneItem.type))
        endif
      endif
    endfor

    #
    # Dump constant data to another section to catch access
    # violation on write attemp.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                     Constant (read-only) data section'
    print '; ------------------------------------------------------------------------------'
    print "section '.rdata' data readable"

    print '  dq ?'

    # Build print formats.
    print ''
    print '; Encoded print formats'
    print '; ---------------------'

    for indexes formatId values encodedFormat in arrayOfMessageFormats
      print '__fmt' ~ str(formatId) ~ ':'

      for values symbolInfo in encodedFormat
        if symbolInfo.type is defined
          mirType = symbolInfo.type
        else
          mirType = 'variant'
        endif

        if symbolInfo.name is '__EOL'
          print '  db FMT_EOL'

        elif symbolInfo.name is '@glued'
          print '  db FMT_PREFIX_GLUED'

        elif symbolInfo.kind is SYMBOL_KIND_CONST
          msgContent = str(symbolInfo.value)
          msgLength  = len(msgContent)

          symbolInfo.readHits = symbolInfo.readHits - 1

          if msgLength > 0
            print '  db FMT_TEXT8,', msgLength, ', ', this.escapeString(msgContent)
          endif

        elif symbolInfo.rbpOffset is defined
          if ((symbolInfo.kind is SYMBOL_KIND_VAR_PARAM) and
              (mirType is @any('variant', 'string')))
            print '  db FMT_LOCAL_variant_ptr'
          else
            print '  db FMT_LOCAL_' ~ mirType
          endif
          print '  dw', symbolInfo.rbpOffset

        elif symbolInfo.kind is SYMBOL_KIND_VAR_RETVAL
          print '  db FMT_RETVAL_' ~ mirType

        elif symbolInfo.kind is @any(SYMBOL_KIND_VAR_GLOBAL, SYMBOL_KIND_CONST)
          print '  db FMT_GLOBAL_' ~ mirType
          print '  dq', symbolInfo.name

        else
          die('error: unhandled format item: ' ~ symbolInfo.name)
        endif
      endfor
      print '  db FMT_TERMINATOR'
      print ''
    endfor

    print ''
    print '; Constants'
    print '; ---------'

    # TODO: Optimize it.
    for deepIdx in 0 .. 16
      print '; iter', deepIdx

      for values symbolInfo in this.globals
        if (symbolInfo.kind is SYMBOL_KIND_CONST) and (symbolInfo.readHits > 0)
          name  = symbolInfo.name
          value = symbolInfo.value
          this.emitConstant(name, value, deepIdx, 0)
        endif
      endfor
    endfor

    # Jump tables
    print ''
    print '; Jump tables'
    print '; -----------'

    for values symbolInfo in this.globals
      if symbolInfo.kind is SYMBOL_KIND_JMP_TABLE
        name         = symbolInfo.name
        labels       = symbolInfo.labels
        defaultLabel = symbolInfo.defaultLabel

        print name ~ ':'

        # TODO: Remove out-of-range labels at earlier stage.
        for labelIdx in symbolInfo.valueMin .. symbolInfo.valueMax + 1
          nextLabel = labels[labelIdx]
          if nextLabel is undefined
            print '  dw 0 ;', labelIdx, 'otherwise'
          else
            print '  dw ', nextLabel, '-', defaultLabel, ';', labelIdx
          endif
        endfor

        print '  dw 0 ; explicit default case'
        print ''
      endif
    endfor

    # Build vtables.
    print ''
    print '; vtables'
    print '; -------'

    classListCnt   = codeObj.classListCnt
    classList      = codeObj.classList
    classMap       = codeObj.classMap
    methodsMap     = codeObj.methodsMap
    methodsList    = codeObj.methodsList
    methodsListCnt = codeObj.methodsListCnt

    for classIdx in 0 .. classListCnt
      classProto = classList[classIdx]
      className  = classProto.name
      vtableData = classProto.vtable

      print 'vtable_' ~ className ~ ':'

      # Find first and last used entry.
      firstUsedMethodIdx = 0
      lastUsedMethodIdx  = 0
      firstMethodFound   = false

      for indexes methodIdx values methodName in methodsList
        if vtableData{methodName} is defined
          # Update index of last used method always, on all occerencies.
          lastUsedMethodIdx = methodIdx

          # Save index of first used method once, on first occurence.
          if firstMethodFound is false
            firstUsedMethodIdx = methodIdx
            firstMethodFound   = true
          endif
        endif
      endfor

      print '.offset dd 8 *', firstUsedMethodIdx
      print '.length dd 8 *', lastUsedMethodIdx - firstUsedMethodIdx

      if firstMethodFound is true
        print '.entries:'

        for methodIdx in firstUsedMethodIdx .. lastUsedMethodIdx + 1
        #for methodIdx in firstUsedMethodIdx .. methodsListCnt
          methodName  = methodsList[methodIdx]
          methodProto = vtableData{methodName}

          if methodProto is undefined
            methodPtr = '__MOLD_PrintErrorAndDie.nullMethodCalled'
          else
            methodPtr = methodProto.fullName ~ '_vcall'
          endif

          print '  dq', methodPtr, ';', methodName, '(', methodIdx, ')'
        endfor
      endif

      print ''
    endfor

    #
    # Generate imports section.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                               Imports section'
    print '; ------------------------------------------------------------------------------'

    print "section '.idata' import data readable writeable"
    print "  include 'x64\CommonImports.asm'"
    print ''

    #
    # Generate debug section with symbols.
    #

    procedures    = codeObj.procedures
    proceduresCnt = codeObj.proceduresCnt

    print '; ------------------------------------------------------------------------------'
    print ';                                Debug section'
    print '; ------------------------------------------------------------------------------'

    print "section '.debug' data readable"

    # Dump symbols.
    print 'SymbolTable:'
    print 'dq 0, 0'
    print "include 'x64\SymbolTableCommon.asm'"

    for values procName in arrayOfProcedures
      print 'dq', procName, ',', 'name_' ~ procName
    endfor

    print 'dq endOfCodeSection, name_endOfCodeSection'
    print 'SymbolTableEnd:'
    print 'dq 0, 0'
    print ''

    print 'SymbolTableNames:'
    print "include 'x64\SymbolTableCommonNames.asm'"

    for values procName in arrayOfProcedures
      print 'name_' ~ procName, 'db', "'" ~ procName ~ "', 0"
    endfor

    print "name_endOfCodeSection db 'out of code section', 0"

    #
    # Generate profiler section if needed.
    #

    if this.isProfilerEnabled is true
      print '; ------------------------------------------------------------------------------'
      print ';                              Profile section'
      print '; ------------------------------------------------------------------------------'

      print "section '.profile' data readable writeable"
      print '__profilerCounterData:'

      for values procName in arrayOfProcedures
        print '__profilerCounterEntry_' ~ procName, ' dq 0,', 'name_' ~ procName
      endfor

      print 'dq 0, 0'
    endif

  endmethod
endclass
