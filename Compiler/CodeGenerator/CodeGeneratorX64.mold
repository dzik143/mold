################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki (sw143@wp.pl)                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'Utils/SymbolTable.mold'
import 'MIR/MIR.mold'
import 'Utils/Stack.mold'

class CodeGeneratorX64

  method constructor()
    this.symbols = {}
  endmethod

  method lea(dst, src)
    print '  lea ', dst, ', [', src, ']'
  endmethod

  method push(x)
    print '  push', x
  endmethod

  method pop(x)
    print '  pop', x
  endmethod

  method mov(dst, src)
    print '  mov ', dst, ',', src
  endmethod

  method call(name)
    print '  call ', name
  endmethod

  method call1(name, x)
    this.lea('rcx', x)
    this.call(name)
  endmethod

  method call2(name, x, y)
    this.lea('rcx', x)
    this.lea('rdx', y)
    this.call(name)
  endmethod

  method call3(name, x, y, z)
    this.lea('rcx', x)
    this.lea('rdx', y)
    this.lea('r8', z)
    this.call(name)
  endmethod

  method call3AndDestroy(name, x, y, dst)
    if (x is dst) or (y is dst)
      this.lea('rcx', x)
      this.lea('rdx', y)
      this.lea('r8', dst)
      this.call(name)
    else
      this.variantDestroy(dst)
      this.call3(name, x, y, dst)
    endif
  endmethod

  method variantMove(dst, src)
    print '  lea rcx, [', dst, ']'
    print '  lea rdx, [', src, ']'
    print '  call __MOLD_VariantMove'
  endmethod

  method variantDestroy(x)
    #TODO
    global SYMBOL_KIND_VAR_LOCAL
    global SYMBOL_KIND_VAR_GLOBAL

    xInfo = this.symbols[x]

    if (typeof(xInfo) is 'undefined') or (xInfo.kind is SYMBOL_KIND_VAR_LOCAL) or (xInfo.kind is SYMBOL_KIND_VAR_GLOBAL)
      print '  lea  rcx, [', x, ']'
      print '  call __MOLD_VariantDestroy'
    endif
  endmethod

  method pushParametersBeforeCall(params)
    paramsCnt = len(params)
    regParams = ['rcx', 'rdx', 'r8', 'r9']

    if paramsCnt <= 4
      regParamsCnt   = paramsCnt
      stackParamsCnt = 0
    else
      regParamsCnt   = 4
      stackParamsCnt = paramsCnt - 4
    endif

    for idx in 0 .. regParamsCnt
      this.lea(regParams[idx], params[idx])
    endfor

    for idx in 4 .. paramsCnt
      # TODO: Optimize it.
      this.lea('rax', params[idx])
      this.push('rax')
    endfor
  endmethod

  method emitConstant(name, value, wantDeepIdx, deepIdx)
    type = typeof(value)

    if wantDeepIdx is deepIdx
      if type is 'integer'
        print name, 'Variant_t VARIANT_INTEGER, 0,', value

      elif type is 'float'
        print name, 'Variant_t VARIANT_DOUBLE, 0,', value

      elif type is 'string'
        print name, 'Variant_t VARIANT_STRING, 0,', name + '_buffer'

      elif type is 'array'
        print name, 'Variant_t VARIANT_ARRAY, 0,', name + '_buffer'

      elif type is 'boolean'
        if value is true
          valueAsInteger = '1'
        else
          valueAsInteger = '0'
        endif

        print name, 'Variant_t VARIANT_BOOLEAN, 0,', valueAsInteger
      else
        print name, 'Variant_t [error: unhandled type], ???'
      endif
    endif

    if type is 'array'
      this.emitArrayBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    elif type is 'string'
      this.emitStringBufferHead(name, value, wantDeepIdx, deepIdx + 1)
    endif
  endmethod

  method emitStringBufferHead(name, value, wantDeep, deepIdx)
    if wantDeep is deepIdx
      bufferName      = name + '_buffer'
      bufferNameBytes = name + '_bufferBytes'
      print  bufferName, 'Buffer_t', len(value) + 1, ', -1, 0,', bufferNameBytes
    endif

    this.emitStringBufferContent(name, value, wantDeep, deepIdx + 1)
  endmethod

  method emitStringBufferContent(name, value, wantDeep, deepIdx)
    if wantDeep is deepIdx
      bufferNameBytes = name + '_bufferBytes'
      bufferData      = '"'
      stringLen       = len(value)

      for characterIdx in 0 .. stringLen
        character = value[characterIdx]

        if character is '"'
          bufferData = bufferData + '", 34, "'
        else
          bufferData = bufferData + character
        endif
      endfor

      bufferData = bufferData + '"'

      print bufferNameBytes, 'StringHead_t', stringLen
      print ' db ', bufferData, ', 0'
    endif
  endmethod

  method emitArrayBufferHead(name, items, wantDeepIdx, deepIdx)
    itemsCnt = len(items)

    if wantDeepIdx is deepIdx
      bufferName      = name + '_buffer'
      bufferNameBytes = name + '_bufferBytes'
      print bufferName, 'Buffer_t', itemsCnt * 16, ', -1, 0,',  bufferNameBytes
    endif

    this.emitArrayBufferContent(name, items, wantDeepIdx, deepIdx + 1)
  endmethod

  method emitArrayBufferContent(name, items, wantDeepIdx, deepIdx)
    itemsCnt  = len(items)

    # TODO: Optimize it.
    # TODO: Move innerType check to earliear stage.
    innerType        = typeof(items[0])
    innerSize        = 0
    innerTypeForEmit = '0'
    innerAsmType     = 'db'
    innerValueMin    = items[0] # TODO: Use MAX_INTEGER like const?
    innerValueMax    = items[0] # TODO: Use MIN_INTEGER like const?
    innerItemIdx     = 1

    goOn = true

    while (goOn is true) and (innerItemIdx < itemsCnt)
      itemValue = items[innerItemIdx]
      itemType  = typeof(itemValue)

      if itemType isnt innerType
        # Various types in one array.
        # Fall-back to variant storage and don't go anymore.
        goOn = false

      elif itemType is 'integer'
        innerTypeForEmit = 'VARIANT_INTEGER'

        # Track max/min values to compact array storage.
        if (innerSize < 3) and ((itemValue < -2147483648) or (itemValue > 2147483647))
         # 2^3 bytes = 8 bytes = 64 bit (qword)
         innerSize    = 3
         innerAsmType = 'dq'

        elif (innerSize < 2) and ((itemValue < -32768) or (itemValue > 32767))
         # 2^2 bytes = 4 bytes = 32 bit (dword)
         innerSize    = 2
         innerAsmType = 'dd'

        elif (innerSize < 2) and ((itemValue < -128) or (itemValue > 127))
         # 2^1 bytes = 2 bytes = 16 bit (word)
         innerSize    = 1
         innerAsmType = 'dw'
        endif
      endif

      # Go to next item.
      innerItemIdx = innerItemIdx + 1
    endwhile

    #print '; innerType:'     , innerType
    #print '; innerValueMin:' , innerValueMin
    #print '; innerValueMax:' , innerValueMax

    if wantDeepIdx is deepIdx
      bufferName      = name + '_buffer'
      bufferNameBytes = name + '_bufferBytes'

      print bufferNameBytes, 'dd', innerTypeForEmit, '; inner type'
      print 'db', innerSize, ' ; inner size'
      print 'db ?, ?, ? ; reserved'
      print 'dq', itemsCnt, '; itemsCnt'

      # Emit items as flat array if possible.
      if innerTypeForEmit isnt '0'
        __mold_printToStdOutput(innerAsmType)
        sep = ' '

        for itemIdx in 0 .. itemsCnt
          __mold_printToStdOutput(sep)
          __mold_printToStdOutput(items[itemIdx])
          sep = ', '
        endfor
        print ''

        # Don't go on recursively.
        itemsCnt = -1
      endif
    endif

    # Go on recursively for variant arrays.
    for itemIdx in 0 .. itemsCnt
      this.emitConstant(name + '_' + str(itemIdx), items[itemIdx], wantDeepIdx, deepIdx)
    endfor
  endmethod

  method run(codeObj)
    global SYMBOL_KIND_VAR_LOCAL, SYMBOL_KIND_VAR_GLOBAL, SYMBOL_KIND_CONST
    global SYMBOL_KIND_VAR_PARAM, SYMBOL_KIND_JMP_TABLE

    #
    # Common headers.
    #

    print 'format PE64 console 5.0'
    print 'entry __MOLD_Main'
    print "include 'win64a.inc'"

    print '; ------------------------------------------------------------------------------'
    print ';                                 Code section'
    print '; ------------------------------------------------------------------------------'

    print "section '.text' code readable executable"
    print "stack 1024*1024*4, 1024*1024*4"
    print "include 'Variant.asm'"
    print "__rv EQU rdi"

    #
    # Fetch code and code metas.
    #

    quads    = codeObj.quads
    quadsCnt = len(quads)

    currentProcProto    = false
    currentProcName     = false
    currentProcRv       = false
    currentSymbols      = {}
    currentFrameSize    = 0
    currentFrameOffsets = {}

    symbols = {}

    # TODO: Remove it.
    arrayOfProcedures = []

    #
    # Translate code section.
    #

    for quadIdx in 0 .. quadsCnt
      # Fetch instruction
      item    = quads[quadIdx]
      itemCnt = len(item)
      opcode  = item[0]
      dst     = item[1]
      x       = item[2]
      y       = item[3]

      # TODO: Optimize it.
      originalOpcode = opcode

      xType = 'variant'
      if (itemCnt > 2) and (typeof(x) is 'string')
        if (opcode isnt 'call') and (opcode isnt 'vcall') and (opcode isnt 'create_object') and ((opcode[0] isnt 'c') or (opcode[1] is 'm'))
          xInfo = currentSymbols[x]
          if typeof(xInfo) isnt 'undefined'
            if typeof(xInfo.type) isnt 'undefined'
              xType = xInfo.type
            endif
          endif

          opcode = opcode + '_' + xType
        endif
      endif

      # print '[x86]', opcode, dst, x, y

      # Dispatch opcode.
      if opcode is 'nop'
        print '  nop'

      elif opcode is 'comment'
        print ';', dst

      elif opcode is 'label'
        print dst + ':'

      elif opcode is 'move_variant'
        this.variantDestroy(dst)
        this.variantMove(dst, x)

      elif (opcode is 'move_int32') or (opcode is 'move_bool32')
        print '  mov eax, dword [', x, ']'
        print '  mov dword [', dst, '], eax'

      elif (opcode is 'move_int64') or (opcode is 'move_float64')
        print '  mov rax, qword [', x, ']'
        print '  mov qword [', dst, '], rax'

      #
      # Typeof(x)
      # TODO: Move typeof(imm) to core.
      #
      elif opcode is 'typeof_variant'
        this.variantDestroy(dst)
        this.call2('__MOLD_VariantTypeOf', x, dst)

      elif (opcode is 'typeof_int64') or (opcode is 'typeof_int32')
        this.variantDestroy(dst)
        print '  movdqu xmm0, [StringInteger]'
        print '  movdqu [', dst, '], xmm0'

      elif opcode is 'typeof_float64'
        this.variantDestroy(dst)
        print '  movdqu xmm0, [StringFloat]'
        print '  movdqu [', dst, '], xmm0'

      elif opcode is 'typeof_bool32'
        this.variantDestroy(dst)
        print '  movdqu xmm0, [StringBoolean]'
        print '  movdqu [', dst, '], xmm0'

      elif opcode is 'len_variant'
        this.variantDestroy(dst)
        this.call2('__MOLD_VariantLength', x, dst)

      elif opcode is 'neg_variant'
        this.variantDestroy(dst)
        this.call2('__MOLD_VariantNeg', x, dst)

      #
      # int64 arithmetic
      #

      elif opcode is 'neg_int64'
        print '  mov rax, qword [', x, ']'
        print '  neg rax'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'add_int64'
        print '  mov rax, qword [', x, ']'
        print '  add rax, qword [', y, ']'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'sub_int64'
        print '  mov rax, qword [', x, ']'
        print '  sub rax, qword [', y, ']'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'mul_int64'
        print '  mov rcx, qword [', x, ']'
        print '  imul rcx, qword [', y, ']'
        print '  mov qword [', dst, '], rcx'

      elif opcode is 'div_int64'
        print '  cvtsi2sd  xmm0, qword [', x, ']'   # ; xmm0 = double(x)
        print '  cvtsi2sd  xmm1, qword [', y, ']'   # ; xmm1 = double(y)
        print '  divsd     xmm0, xmm1'              # ; xmm0 = x / y
        print '  movq      qword [', dst, '], xmm0' # ; dst  = x / y

      elif opcode is 'idiv_int64'
        print '  mov  rax, qword [', x, ']' # ; rax     = x
        print '  mov  rcx, qword [', y, ']' # ; rcx     = y
        print '  cqo'                       # ; rdx:rax = x
        print '  idiv rcx'                  # ; rax     = x / y
        print '  mov  qword [', dst,'], rax'

      elif opcode is 'cmp_eq_int64'
        print '  mov dword [', dst, '], 0'
        print '  mov rcx, qword [', x, ']'
        print '  cmp rcx, qword [', y, ']'
        print '  setz byte [', dst, ']'

      elif opcode is 'cmp_ne_int64'
        print '  mov dword [', dst, '], 0'
        print '  mov rcx, qword [', x, ']'
        print '  cmp rcx, qword [', y, ']'
        print '  setnz byte [', dst, ']'

      elif opcode is 'cmp_lt_int64'
        print '  mov dword [', dst, '], 0'
        print '  mov rcx, qword [', x, ']'
        print '  cmp rcx, qword [', y, ']'
        print '  setl byte [', dst, ']'

      elif opcode is 'cmp_le_int64'
        print '  mov dword [', dst, '], 0'
        print '  mov rcx, qword [', x, ']'
        print '  cmp rcx, qword [', y, ']'
        print '  setle byte [', dst, ']'

      elif opcode is 'cmp_gt_int64'
        print '  mov dword [', dst, '], 0'
        print '  mov rcx, qword [', x, ']'
        print '  cmp rcx, qword [', y, ']'
        print '  setg byte [', dst, ']'

      elif opcode is 'cmp_ge_int64'
        print '  mov dword [', dst, '], 0'
        print '  mov rcx, qword [', x, ']'
        print '  cmp rcx, qword [', y, ']'
        print '  setge byte [', dst, ']'

      #
      # int32 arithmetic
      #

      elif opcode is 'neg_int32'
        print '  mov eax, dword [', x, ']'
        print '  neg eax'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'add_int32'
        print '  mov eax, dword [', x, ']'
        print '  add eax, dword [', y, ']'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'sub_int32'
        print '  mov eax, dword [', x, ']'
        print '  sub eax, dword [', y, ']'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'mul_int32'
        print '  mov ecx, dword [', x, ']'
        print '  imul ecx, dword [', y, ']'
        print '  mov dword [', dst, '], ecx'

      elif opcode is 'div_int32'
        print '  cvtsi2sd  xmm0, dword [', x, ']'   # ; xmm0 = double(x)
        print '  cvtsi2sd  xmm1, dword [', y, ']'   # ; xmm1 = double(y)
        print '  divsd     xmm0, xmm1'              # ; xmm0 = x / y
        print '  movq      qword [', dst, '], xmm0' # ; dst  = x / y

      elif opcode is 'idiv_int32'
        print '  mov  eax, dword [', x, ']' # ; eax     = x
        print '  mov  ecx, dword [', y, ']' # ; ecx     = y
        print '  cdq'                       # ; edx:eax = x
        print '  idiv ecx'                  # ; eax     = x / y
        print '  mov  dword [', dst,'], eax'

      elif opcode is 'cmp_eq_int32'
        print '  mov dword [', dst, '], 0'
        print '  mov ecx, dword [', x, ']'
        print '  cmp ecx, dword [', y, ']'
        print '  setz byte [', dst, ']'

      elif opcode is 'cmp_ne_int32'
        print '  mov dword [', dst, '], 0'
        print '  mov ecx, dword [', x, ']'
        print '  cmp ecx, dword [', y, ']'
        print '  setnz byte [', dst, ']'

      elif opcode is 'cmp_lt_int32'
        print '  mov dword [', dst, '], 0'
        print '  mov ecx, dword [', x, ']'
        print '  cmp ecx, dword [', y, ']'
        print '  setl byte [', dst, ']'

      elif opcode is 'cmp_le_int32'
        print '  mov dword [', dst, '], 0'
        print '  mov ecx, dword [', x, ']'
        print '  cmp ecx, dword [', y, ']'
        print '  setle byte [', dst, ']'

      elif opcode is 'cmp_gt_int32'
        print '  mov dword [', dst, '], 0'
        print '  mov ecx, dword [', x, ']'
        print '  cmp ecx, dword [', y, ']'
        print '  setg byte [', dst, ']'

      elif opcode is 'cmp_ge_int32'
        print '  mov dword [', dst, '], 0'
        print '  mov ecx, dword [', x, ']'
        print '  cmp ecx, dword [', y, ']'
        print '  setge byte [', dst, ']'

      #
      # float64 arithmetic
      #

      elif opcode is 'neg_float64'
        print '  mov rax, qword [', x, ']'
        print '  xor rax, 0x8000000000000000'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'add_float64'
        print '  movq  xmm0, [', x, ']'
        print '  addsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'sub_float64'
        print '  movq  xmm0, [', x, ']'
        print '  subsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'mul_float64'
        print '  movq  xmm0, [', x, ']'
        print '  mulsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'div_float64'
        print '  movq  xmm0, [', x, ']'
        print '  divsd xmm0, qword [', y, ']'
        print '  movq  qword [', dst, '], xmm0'

      elif opcode is 'idiv_float64'
        print '  movq      xmm0, qword [', x, ']'  # xmm0 = x
        print '  movq      xmm1, qword [', y, ']'  # xmm1 = y
        print '  divsd     xmm0, xmm1'             # xmm0 = x / y
        print '  cvttsd2si rax, xmm0'              # rax  = int(x / y)
        print '  mov       qword [', dst, '], rax' # dst  = int(x / y)

      elif opcode is 'cmp_eq_float64'
        print '  xor eax, eax'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  setz al'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'cmp_ne_float64'
        print '  xor eax, eax'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  setnz al'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'cmp_lt_float64'
        print '  xor eax, eax'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  setb al'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'cmp_le_float64'
        print '  xor eax, eax'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  setbe al'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'cmp_gt_float64'
        print '  xor eax, eax'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  seta al'
        print '  mov dword [', dst, '], eax'

      elif opcode is 'cmp_ge_float64'
        print '  xor eax, eax'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  setae al'
        print '  mov dword [', dst, '], eax'

      #
      # Variant arithmetic.
      #

      elif opcode is 'add_variant'
        this.call3AndDestroy('__MOLD_VariantAdd', x, y, dst)

      elif opcode is 'sub_variant'
        this.call3AndDestroy('__MOLD_VariantSub', x, y, dst)

      elif opcode is 'mul_variant'
        this.call3AndDestroy('__MOLD_VariantMul', x, y, dst)

      elif opcode is 'div_variant'
        this.call3AndDestroy('__MOLD_VariantDiv', x, y, dst)

      elif opcode is 'idiv_variant'
        this.call3AndDestroy('__MOLD_VariantDivAsInteger', x, y, dst)

      elif opcode is 'cmp_eq_variant'
        this.call3AndDestroy('__MOLD_VariantCompareEQ', x, y, dst)

      elif opcode is 'cmp_ne_variant'
        this.call3AndDestroy('__MOLD_VariantCompareNE', x, y, dst)

      elif opcode is 'cmp_lt_variant'
        this.call3AndDestroy('__MOLD_VariantCompareLT', x, y, dst)

      elif opcode is 'cmp_le_variant'
        this.call3AndDestroy('__MOLD_VariantCompareLE', x, y, dst)

      elif opcode is 'cmp_gt_variant'
        this.call3AndDestroy('__MOLD_VariantCompareLT', y, x, dst)

      elif opcode is 'cmp_ge_variant'
        this.call3AndDestroy('__MOLD_VariantCompareLE', y, x, dst)

      #
      # indirect jumps
      #

      elif opcode is 'jmp_by_table_variant'
        print '  mov rax, [', x, '+ Variant_t.value]'
        print '  jmp qword [', dst, '+ rax * 8]'

      elif opcode is 'jmp_by_table_int32'
        print '  mov eax, dword [', x, ']'
        print '  jmp qword [', dst, '+ rax * 8]'

      #
      # jmp_if_xx_variant
      #

      elif opcode is 'jmp_if_eq_variant'
        print '  lea rcx, [', x, ']'
        print '  lea rdx, [', y, ']'
        print '  lea r8, [rsp + 16]' # Temp var in own shadow space
        print '  call __MOLD_VariantCompareEQ'
        print '  cmp dword [rsp + 16 + Variant_t.value], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_ne_variant'
        print '  lea rcx, [', x, ']'
        print '  lea rdx, [', y, ']'
        print '  lea r8, [rsp + 16]' # Temp var in own shadow space
        print '  call __MOLD_VariantCompareNE'
        print '  cmp dword [rsp + 16 + Variant_t.value], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_lt_variant'
        print '  lea rcx, [', x, ']'
        print '  lea rdx, [', y, ']'
        print '  lea r8, [rsp + 16]' # Temp var in own shadow space
        print '  call __MOLD_VariantCompareLT'
        print '  cmp dword [rsp + 16 + Variant_t.value], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_le_variant'
        print '  lea rcx, [', x, ']'
        print '  lea rdx, [', y, ']'
        print '  lea r8, [rsp + 16]' # Temp var in own shadow space
        print '  call __MOLD_VariantCompareLE'
        print '  cmp dword [rsp + 16 + Variant_t.value], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_gt_variant'
        print '  lea rcx, [', y, ']'
        print '  lea rdx, [', x, ']'
        print '  lea r8, [rsp + 16]' # Temp var in own shadow space
        print '  call __MOLD_VariantCompareLT'
        print '  cmp dword [rsp + 16 + Variant_t.value], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_ge_variant'
        print '  lea rcx, [', y, ']'
        print '  lea rdx, [', x, ']'
        print '  lea r8, [rsp + 16]' # Temp var in own shadow space
        print '  call __MOLD_VariantCompareLE'
        print '  cmp dword [rsp + 16 + Variant_t.value], 0'
        print '  jnz', dst

      #
      # load imm values
      #

      elif originalOpcode is 'load_int64'
        print '  mov qword [', dst, '],', x

      elif originalOpcode is 'load_int32'
        print '  mov dword [', dst, '],', x

      elif originalOpcode is 'load_bool32'
        if x is true
          print '  mov dword [', dst, '],', 1
        else
          print '  mov dword [', dst, '],', 0
        endif

      elif originalOpcode is 'load_float64'
        print '  db 0x48, 0xb8' # mov rax, float64
        print '  dq', x
        print '  mov qword [', dst, '], rax'

      #
      # jmp_if_xx_int64
      #

      elif opcode is 'jmp_if_eq_int64'
        print '  mov rax, qword [', x, ']'
        print '  cmp rax, qword [', y, ']'
        print '  je', dst

      elif opcode is 'jmp_if_ne_int64'
        print '  mov rax, qword [', x, ']'
        print '  cmp rax, qword [', y, ']'
        print '  jne', dst

      elif opcode is 'jmp_if_lt_int64'
        print '  mov rax, qword [', x, ']'
        print '  cmp rax, qword [', y, ']'
        print '  jl', dst

      elif opcode is 'jmp_if_le_int64'
        print '  mov rax, qword [', x, ']'
        print '  cmp rax, qword [', y, ']'
        print '  jle', dst

      elif opcode is 'jmp_if_gt_int64'
        print '  mov rax, qword [', x, ']'
        print '  cmp rax, qword [', y, ']'
        print '  jg', dst

      elif opcode is 'jmp_if_ge_int64'
        print '  mov rax, qword [', x, ']'
        print '  cmp rax, qword [', y, ']'
        print '  jge', dst

      #
      # jmp_if_xx_int32
      #

      elif opcode is 'jmp_if_eq_int32'
        print '  mov eax, dword [', x, ']'
        print '  cmp eax, dword [', y, ']'
        print '  je', dst

      elif opcode is 'jmp_if_ne_int32'
        print '  mov eax, dword [', x, ']'
        print '  cmp eax, dword [', y, ']'
        print '  jne', dst

      elif opcode is 'jmp_if_lt_int32'
        if typeof(y) is 'integer'
          print '  cmp dword [', x, '],', y
        else
          print '  mov eax, dword [', x, ']'
          print '  cmp eax, dword [', y, ']'
        endif

        print '  jl', dst

      elif opcode is 'jmp_if_le_int32'
        print '  mov eax, dword [', x, ']'
        print '  cmp eax, dword [', y, ']'
        print '  jle', dst

      elif opcode is 'jmp_if_gt_int32'
        if typeof(y) is 'integer'
          print '  cmp dword [', x, '],', y
        else
          print '  mov eax, dword [', x, ']'
          print '  cmp eax, dword [', y, ']'
        endif

        print '  jg', dst

      elif opcode is 'jmp_if_ge_int32'
        print '  mov eax, dword [', x, ']'
        print '  cmp eax, dword [', y, ']'
        print '  jge', dst

      #
      # jmp_if_true_bool32
      # jmp_if_false_bool32
      #

      elif opcode is 'jmp_if_true_bool32'
        print '  cmp dword [', x, '], 0'
        print '  jnz', dst

      elif opcode is 'jmp_if_false_bool32'
        print '  cmp dword [', x, '], 0'
        print '  jz', dst

      elif opcode is 'jmp_if_eq_bool32'
        print '  xor   eax, eax'
        print '  or    dword [', x, '], eax'
        print '  setnz cl'
        print '  or    dword [', y, '], eax'
        print '  setz  al'
        print '  xor   al, cl'
        print '  jnz', dst

      elif opcode is 'jmp_if_ne_bool32'
        print '  xor  eax, eax'
        print '  or   dword [', x, '], eax'
        print '  setz cl'
        print '  or   dword [', y, '], eax'
        print '  setz al'
        print '  xor  al, cl'
        print '  jnz', dst

      elif opcode is 'cmp_eq_bool32'
        print '  xor   eax, eax'
        print '  or    dword [', x, '], eax'
        print '  setnz cl'
        print '  or    dword [', y, '], eax'
        print '  setz  al'
        print '  xor   al, cl'
        print '  mov   dword [', dst, '], eax'

      elif opcode is 'cmp_ne_bool32'
        print '  xor  eax, eax'
        print '  or   dword [', x, '], eax'
        print '  setz cl'
        print '  or   dword [', y, '], eax'
        print '  setz al'
        print '  xor  al, cl'
        print '  mov  dword [', dst, '], eax'

      #
      # jmp_if_xx_float64
      #

      elif opcode is 'jmp_if_eq_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jz', dst

      elif opcode is 'jmp_if_ne_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jnz', dst

      elif opcode is 'jmp_if_lt_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jb', dst

      elif opcode is 'jmp_if_le_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jbe', dst

      elif opcode is 'jmp_if_gt_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  ja', dst

      elif opcode is 'jmp_if_ge_float64'
        print '  movq   xmm0, [', x, ']'
        print '  comisd xmm0, [', y, ']'
        print '  jae', dst

      #
      # Print functions.
      #

      elif opcode is 'print_array_of_variants_ln'
        params    = dst
        paramsCnt = len(params)

        if paramsCnt is 1
          this.call1('__MOLD_PrintVariantLn', params[0])
        else
          newParams = [paramsCnt]
          for idx in 0 .. paramsCnt
            newParams[idx + 1] = params[idx]
          endfor
          paramsCnt = paramsCnt + 1

          this.pushParametersBeforeCall(newParams)

          this.call('__MOLD_PrintArrayOfVariantsLn')

          if paramsCnt > 4
            print '  add rsp,', paramsCnt * 8 - 32
          endif
        endif

      elif opcode is 'print_err'
        this.call1('__MOLD_PrintVariantToStdError', dst)

      elif opcode is 'print_out'
        this.call1('__MOLD_PrintVariant', dst)

      elif opcode is 'print_out_newline'
        this.call('__MOLD_PrintNewLine')

      elif opcode is 'print_out_space'
        this.call('__MOLD_PrintSpace')

      elif opcode is 'str_variant'
        this.variantDestroy(dst)
        this.call2('__MOLD_VariantConvertToString', x, dst)

      elif opcode is 'str_int64'
        this.variantDestroy(dst)
        print '  mov r9, [', x, ']'
        print '  mov r10d, VARIANT_INTEGER'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertPrimitiveToString'

      elif opcode is 'str_int32'
        this.variantDestroy(dst)
        print '  mov r9d, [', x, ']'
        print '  mov r10d, VARIANT_INTEGER'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertPrimitiveToString'

      elif opcode is 'str_float64'
        this.variantDestroy(dst)
        print '  mov r9, [', x, ']'
        print '  mov r10d, VARIANT_DOUBLE'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertPrimitiveToString'

      elif opcode is 'str_bool32'
        this.variantDestroy(dst)
        print '  mov r9d, dword [', x, ']'
        print '  lea rdx, [', dst, ']'
        print '  call __MOLD_VariantConvertBool64ToString'

      elif opcode is 'call'
        rv        = item[1]
        name      = item[2]
        params    = item[3]
        paramsCnt = len(params)

        if name is 'bitwiseAnd'
          # TODO: Clean up this hack.
          this.variantDestroy(rv)
          print '  mov rax, [', params[0], '+ Variant_t.value]'
          print '  and rax, [', params[1], '+ Variant_t.value]'
          print '  mov [', rv, '+ Variant_t.type], VARIANT_INTEGER'
          print '  mov [', rv, '+ Variant_t.value], rax'

        elif name is '__mold_parseFloat'
          # TODO: Clean up this hack.
          this.variantDestroy(rv)
          print '  mov rcx, [', params[0], '+ Variant_t.value]' # rcx = text (Buffer_t)
          print '  mov rcx, [ rcx + Buffer_t.bytesPtr ]'        # rcx = text (String_t)
          print '  lea rcx, [ rcx + String_t.text ]'            # rcx = text (char*)
          print '  cinvoke atof'                                # rcx = atof(text)
          print '  mov [', rv, '+ Variant_t.type], VARIANT_DOUBLE'
          print '  movq [', rv, '+ Variant_t.value], xmm0'

        elif name is '__mold_parseInteger'
          # TODO: Clean up this hack.
          this.variantDestroy(rv)
          print '  mov rcx, [', params[0], '+ Variant_t.value]' # rcx = text (Buffer_t)
          print '  mov rcx, [ rcx + Buffer_t.bytesPtr ]'        # rcx = text (String_t)
          print '  lea rcx, [ rcx + String_t.text ]'            # rcx = text (char*)
          print '  cinvoke atoi'                                # rcx = int(text)
          print '  mov [', rv, '+ Variant_t.type], VARIANT_INTEGER'
          print '  mov [', rv, '+ Variant_t.value], rax'

        else
          # Generic call.
          if typeof(rv) isnt 'undefined'
            # Function has return value.
            # TODO: Clean up this mess.
            this.variantDestroy(rv)
            this.push('rdi')
            this.pushParametersBeforeCall(params)
            this.lea('rdi', rv)
            this.mov('[rdi + Variant_t.type]', 'VARIANT_UNDEFINED')
            this.call(name)
            this.pop('rdi')

          else
            # No return value.
            this.pushParametersBeforeCall(params)
            this.call(name)
          endif

          if paramsCnt > 4
            print '  add rsp,', paramsCnt * 8 - 32
          endif
        endif

      elif opcode is 'vcall'
        rv        = item[1]
        methodId  = item[2]
        params    = item[3]
        paramsCnt = len(params)

        if typeof(rv) isnt 'undefined'
          this.variantDestroy(rv)
          this.push('rdi')
          this.pushParametersBeforeCall(params)
          print '  lea  rdi, [', rv, ']'
          print '  mov [rdi + Variant_t.type], VARIANT_UNDEFINED'
        else
          this.pushParametersBeforeCall(params)
        endif

        print '  mov  rax, [rcx + Variant_t.value]'
        print '  mov  rax, [rax + Buffer_t.bytesPtr]'
        print '  mov  rax, [rax + Object_t.vtable]'
        print '  call qword [rax + 8*' + str(methodId) + ']'

        if paramsCnt > 4
          print '  add rsp,', paramsCnt * 8 - 32
        endif

        if typeof(rv) isnt 'undefined'
          this.pop('rdi')
        endif

      elif opcode is 'create_object'
        this.variantDestroy(dst)
        print '  lea  rcx, [', dst, ']'
        print '  lea  rdx, [vtable_' + x + ']'
        print '  call __MOLD_VariantObjectCreate'

      elif originalOpcode is 'conv_int32_to_float64'
        print '  cvtsi2sd xmm0, dword [', x, ']'
        print '  movq [', dst, '], xmm0'

      elif originalOpcode is 'conv_int64_to_float64'
        print '  cvtsi2sd xmm0, qword [', x, ']'
        print '  movq [', dst, '], xmm0'

      elif originalOpcode is 'conv_int32_to_variant'
        this.variantDestroy(dst)
        print '  mov [', dst, '+ Variant_t.type], VARIANT_INTEGER'

        if typeof(x) is 'integer'
          print '  mov [', dst, '+ Variant_t.value],', x
        else
          print '  movsxd rax, dword [', x, ']'
          print '  mov [', dst, '+ Variant_t.value], rax'
        endif

      elif originalOpcode is 'conv_int64_to_variant'
        this.variantDestroy(dst)
        print '  mov [', dst, '+ Variant_t.type], VARIANT_INTEGER'

        if typeof(x) is 'integer'
          print '  mov [', dst, '+ Variant_t.value],', x
        else
          print '  mov rax, qword [', x, ']'
          print '  mov [', dst, '+ Variant_t.value], rax'
        endif

      elif originalOpcode is 'conv_float64_to_variant'
        this.variantDestroy(dst)
        if typeof(x) is 'float'
          print '  db 0x48, 0xb8' # mov rax, float64
          print '  dq', x
        else
          print '  mov rax, qword [', x, ']'
        endif

        print '  mov [', dst, '+ Variant_t.type], VARIANT_DOUBLE'
        print '  mov [', dst, '+ Variant_t.value], rax'

      elif originalOpcode is 'conv_float64_to_int32'
        if typeof(x) is 'float'
          die('error: convert imm float64 to int32 not supported')
        else
          print '  cvttsd2si eax, [', x, ']'
          print '  mov dword [', dst, '], eax'
        endif

      elif originalOpcode is 'conv_float64_to_int64'
        if typeof(x) is 'float'
          die('error: convert imm float64 to int64 not supported')
        else
          print '  cvttsd2si rax, [', x, ']'
          print '  mov qword [', dst, '], rax'
        endif

      elif originalOpcode is 'conv_bool32_to_variant'
        this.variantDestroy(dst)

        if x is true
          print '  mov eax, 1'
        elif x is false
          print '  mov eax, 0'
        else
          print '  mov eax, dword [', x, ']'
        endif

        print '  mov [', dst, '+ Variant_t.type], VARIANT_BOOLEAN'
        print '  mov [', dst, '+ Variant_t.value], rax'

      elif originalOpcode is 'conv_variant_to_bool32'
        print '  mov eax, dword [', x, '+ Variant_t.value]'
        print '  mov dword [', dst, '], eax'

      elif (originalOpcode is 'conv_variant_to_int32') or (originalOpcode is 'conv_variant_to_int64') or (originalOpcode is 'conv_variant_to_float64')
        print '  mov rax, qword [', x, '+ Variant_t.value]'
        print '  mov qword [', dst, '], rax'

      elif opcode is 'jmp_if_true_variant'
        print '  cmp  [', x, ' + Variant_t.value], 0'
        print '  jnz ', dst

      elif opcode is 'jmp_if_false_variant'
        print '  cmp  [', x, ' + Variant_t.value], 0'
        print '  jz  ', dst

      elif opcode is 'jmp_if_variant_ge_int64'
        print '  cmp  [', x, ' + Variant_t.value],', y
        print '  jge ', dst

      elif opcode is 'halt'
        print '  mov  rcx, 0'
        print '  call __MOLD_Halt'

      elif opcode is 'inner_ret'
        # TODO: Better handling of nested procedures.
        print '  ret'

      elif opcode is 'ret'
        print ''
        print '  ; clean frame'
        print '  ; -----------'

        # TODO: Clean up this mess.
        symbols = currentSymbols

        for values oneItem in symbols
          if (oneItem.kind is SYMBOL_KIND_VAR_LOCAL) and ((oneItem.type is 'variant') or (typeof(oneItem.type) is 'undefined'))
            if oneItem.usedAsIterator is true
              # Symbol is used as loop iterator.
              # It's only dump reference for existing box values or keys.
              print '  ; Skipped loop iterator', oneItem.name

            else
              this.variantDestroy(oneItem.name)
            endif
          endif
        endfor

        if (currentProcName is 'start')
          for values oneItem in symbols
            if (oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and ((oneItem.type is 'variant') or (typeof(oneItem.type) is 'undefined'))
              this.variantDestroy(oneItem.name)
            endif
          endfor
        endif

        print ''
        print '  add  rsp,', currentFrameSize
        print '  pop  rbp'
        print '  ret'

      elif opcode is 'proc'
        proto            = item[1]
        currentProcProto = proto
        currentProcName  = proto['name']
        currentProcRv    = proto['rv']
        currentSymbols   = proto['symbols']
        print currentProcName + ':'

        arrayOfProcedures[len(arrayOfProcedures)] = currentProcName

      elif opcode is 'endp'
        print ''
        # TODO: Clean up this mess.
        for values oneItem in symbols
          if ((oneItem.kind is SYMBOL_KIND_VAR_LOCAL) or (oneItem.kind is SYMBOL_KIND_VAR_PARAM))
            print '  restore', oneItem.name
          endif
        endfor

      elif opcode is 'init_frame'
        currentFrame = dst
        symbols      = currentFrame['symbols']
        params       = currentFrame['params']
        paramsCnt    = currentFrame['paramsCnt']

        # Clean up this mess.
        this.symbols = symbols

        regParams = ['rcx','rdx', 'r8', 'r9']

        print '  ; init frame'
        print '  ; ----------'

        # Calculate frame size.
        currentFrameSize = 0
        paramsPassedCnt  = 0
        symbolsCnt       = len(symbols)

        # TODO: Clean up this mess.
        # TODO: Use reverse.
        symbolsIndex = []
        for values v in symbols
          symbolsIndex[len(symbolsIndex)] = v
        endfor
        symbolsCnt = len(symbolsIndex)

        # TODO: Use reverse when ready.
        for symbolIdx in 0 .. symbolsCnt
          symbol = symbolsIndex[symbolsCnt - symbolIdx - 1]

          if (symbol.kind is SYMBOL_KIND_VAR_LOCAL) or (symbol.kind is SYMBOL_KIND_VAR_PARAM)
            if (symbol.type is 'variant') or (typeof(symbol.type) is 'undefined')
              varSize = 16

            elif (symbol.type is 'int64') or (symbol.type is 'float64')
              varSize = 8

            elif (symbol.type is 'int32') or (symbol.type is 'bool32')
              varSize = 4

            else
              # TODO: Remove unneded assign.
              varSize = -1
              die('error: unhandled operand type while setting up frame: ' + str(symbol.type))
            endif

            currentFrameSize = currentFrameSize + varSize

            print ' ', symbol.name, 'EQU rbp -', 8 + currentFrameSize, ';', varSize, 'bytes'
          endif

          # TODO: Dirty fix to handle real number of stack parameters if 'this'
          # pointer is used.
          if symbol.kind is SYMBOL_KIND_VAR_PARAM
            paramsPassedCnt = paramsPassedCnt + 1
          endif
        endfor

        # Align to 16-bytes and add 32-byte shadow space.
        # TODO: Optimize it.
        if currentFrameSize > 0
          currentFrameSize = ((currentFrameSize + 32) // 16 + 1) * 16
        else
          currentFrameSize = 32
        endif

        print ''
        print '  push rbp'
        print '  mov  rbp, rsp'
        print '  sub  rsp,', currentFrameSize
        print ''

        paramIdx = 0

        for values oneItem in symbols
          if oneItem.kind is SYMBOL_KIND_VAR_LOCAL
            if (oneItem.type is 'variant') or (typeof(oneItem.type) is 'undefined')
              # Local Variant_t variable - init to undefined.
              if oneItem.usedAsIterator is true
                # Symbol is used as loop iterator.
                # It's only dump reference for existing box values or keys.
                print '  ; Skipped loop iterator', oneItem.item
              else
                print '  mov [' + oneItem.name + ' + Variant_t.type], VARIANT_UNDEFINED'
              endif
            endif

          elif oneItem.kind is SYMBOL_KIND_VAR_PARAM
            # Call parameter - copy to local var.
            if (oneItem.readHits > 0) or (oneItem.writeHits > 0)
              if paramIdx < 4
                print '  movdqu xmm0', ', [', regParams[paramIdx], ']'
              else
                print '  mov    rax, [rbp + 16 + 8 *', paramsPassedCnt - paramIdx - 1, ']'
                print '  movdqu xmm0', ', [rax]'
              endif

              print '  movdqu [', oneItem.name, '], xmm0'

              if oneItem.duplicateOnFirstWrite is true
                print '  or [', oneItem.name, ' + Variant_t.flags ], VARIANT_FLAG_DUPLICATE_ON_FIRST_WRITE'
              endif

            else
              print '  ; skipped unused param [', oneItem.name, ']'
            endif

            paramIdx = paramIdx  + 1
          endif
        endfor

        if (currentProcName is 'start')
          print ''
          for values oneItem in symbols
            # TODO: Better way to exclude external vars.
            if (oneItem.name is 'argv') or (oneItem.name is 'argc')
              # Do nothing.

            elif (oneItem.kind is SYMBOL_KIND_VAR_GLOBAL) and ((oneItem.type is 'variant') or (typeof(oneItem.type) is 'undefined'))
              print '  mov [' + oneItem.name + ' + Variant_t.type], VARIANT_UNDEFINED'
            endif

          endfor
        endif

        print ''
        print '  ; code'
        print '  ; ----'

      elif originalOpcode is 'create_array'
        this.variantDestroy(dst)
        this.call1('__MOLD_VariantArrayCreate', dst)

      elif originalOpcode is 'create_map'
        this.variantDestroy(dst)
        this.call1('__MOLD_VariantMapCreate', dst)

      elif originalOpcode is 'store_index'
        # dst[x] := y
        this.call3('__MOLD_VariantStoreAtIndex', dst, x, y)

      elif originalOpcode is 'load_index'
        # dst := x[y]
        this.call3AndDestroy('__MOLD_VariantLoadFromIndex', x, y, dst)

      elif originalOpcode is 'jmp'
       print '  jmp', dst

      else
        die('error: unhandled opcode "' + str(opcode) + '"')
      endif
    endfor

    print ''
    print 'endOfCodeSection:'

    #
    # Generate data section.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                                 Data section'
    print '; ------------------------------------------------------------------------------'
    print "section '.data' data readable writeable"

    print "include 'CommonData.asm'"
    print ''

    print ''
    print '; Global vars'
    print '; -----------'

    globals = codeObj.symbolTable.exportSymbols()

    for values oneItem in globals
      if oneItem.kind is SYMBOL_KIND_VAR_GLOBAL
        if (oneItem.type is 'variant') or (typeof(oneItem.type) is 'undefined')
          print oneItem.name, ' Variant_t 0, 0, 0'

        elif oneItem.type is 'int64'
          print oneItem.name, ' dq 0'

        elif oneItem.type is 'int32'
          print oneItem.name, ' dd 0'

        elif oneItem.type is 'float64'
          print oneItem.name, ' dq 0'

        elif oneItem.type is 'bool32'
          print oneItem.name, ' dd 0'

        else
          die('error: unhandled global type: ' + str(oneItem.type))
        endif
      endif
    endfor

    #
    # Dump constant data to another section to catch access
    # violation on write attemp.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                           Constant data section'
    print '; ------------------------------------------------------------------------------'
    print "section '.cdata' data readable"

    print ''
    print '; Constants'
    print '; ---------'

    print 'db ?'

    # TODO: Optimize it.
    for deepIdx in 0 .. 16
      print '; iter', deepIdx

      for values symbolInfo in globals
        if symbolInfo.kind is SYMBOL_KIND_CONST
          name  = symbolInfo.name
          value = symbolInfo.value
          this.emitConstant(name, value, deepIdx, 0)
        endif
      endfor
    endfor

    # Jump tables
    print ''
    print '; Jump tables'
    print '; -----------'

    for values symbolInfo in globals
      if symbolInfo.kind is SYMBOL_KIND_JMP_TABLE
        name         = symbolInfo.name
        labels       = symbolInfo.labels
        defaultLabel = symbolInfo.defaultLabel

        print name + ':'

        for labelIdx in 0 .. len(labels)
          nextLabel = labels[labelIdx]
          if typeof(nextLabel) is 'undefined'
            nextLabel = defaultLabel
          endif

          print '  dq ', nextLabel, ';', labelIdx
        endfor
      endif
    endfor

    # Build vtables.
    print ''
    print '; vtables'
    print '; -------'

    classListCnt   = codeObj.classListCnt
    classList      = codeObj.classList
    classMap       = codeObj.classMap
    methodsMap     = codeObj.methodsMap
    methodsList    = codeObj.methodsList
    methodsListCnt = codeObj.methodsListCnt

    for classIdx in 0 .. classListCnt
      classProto = classList[classIdx]
      className  = classProto['name']
      vtable     = classProto['vtable']

      print 'vtable_' + className + ':'

      for methodIdx in 0 .. methodsListCnt
        methodName  = methodsList[methodIdx]
        methodProto = vtable[methodName]

        if typeof(methodProto) is 'undefined'
          methodPtr = '__MOLD_NullMethodCalled'
        else
          methodPtr = methodProto['fullName']
        endif

        print '  dq', methodPtr, ';', methodName
      endfor

      print ''
    endfor

    #
    # Generate imports section.
    #

    print '; ------------------------------------------------------------------------------'
    print ';                               Imports section'
    print '; ------------------------------------------------------------------------------'

    print "section '.idata' import data readable writeable"
    print "  include 'CommonImports.asm'"
    print ''

    #
    # Generate debug section with symbols.
    #

    procedures     = codeObj.procedures
    proceduresCnt  = codeObj.proceduresCnt

    print '; ------------------------------------------------------------------------------'
    print ';                                Debug section'
    print '; ------------------------------------------------------------------------------'

    print "section '.debug' data readable"

    # Dump symbols.
    print 'SymbolTable:'
    print 'dq 0, 0'
    print "include 'SymbolTableCommon.asm'"

    for procIdx in 0 .. len(arrayOfProcedures)
      procName = arrayOfProcedures[procIdx]
      print 'dq ', procName, ',', 'name_' + procName
    endfor

    print 'dq endOfCodeSection, name_endOfCodeSection'
    print 'SymbolTableEnd:'
    print 'dq 0, 0'
    print ''

    print 'SymbolTableNames:'
    print "include 'SymbolTableCommonNames.asm'"

    for procIdx in 0 .. len(arrayOfProcedures)
      procName = arrayOfProcedures[procIdx]
      print 'name_' + procName, 'db', "'" + procName + "', 0"
    endfor

    print "name_endOfCodeSection db 'out of code section', 0"

  endmethod
endclass
