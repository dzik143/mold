################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2020 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'Utils/PipeAbstract.mold'

class MIRQuadOptimizer extends PipeAbstract

  # ----------------------------------------------------------------------------
  #                         Init functions (constructor)
  # ----------------------------------------------------------------------------

  method constructor()
    super()
    this.bufferingEnabled = true
    this.lastOpcode       = 'nop'
    this.lastDst          = '[error]'
    this.lastSrc1         = '[error]'
    this.lastSrc2         = '[error]'
    this.currentFrame     = {}

    this.cmpXxJmpIfFalseMap = {
      'cmp_eq': 'jmp_if_ne',
      'cmp_ne': 'jmp_if_eq',
      'cmp_lt': 'jmp_if_ge',
      'cmp_le': 'jmp_if_gt',
      'cmp_gt': 'jmp_if_le',
      'cmp_ge': 'jmp_if_lt'
    }

    this.cmpXxJmpIfTrueMap = {
      'cmp_eq': 'jmp_if_eq',
      'cmp_ne': 'jmp_if_ne',
      'cmp_lt': 'jmp_if_lt',
      'cmp_le': 'jmp_if_le',
      'cmp_gt': 'jmp_if_gt',
      'cmp_ge': 'jmp_if_ge'
    }
  endmethod

  # ----------------------------------------------------------------------------
  #                        Internal helpers (private)
  # ----------------------------------------------------------------------------

  method _decreaseReadAndWriteHits(src)
    srcInfo = this.currentFrame.symbols{src}
    srcInfo.writeHits = srcInfo.writeHits - 1
    srcInfo.readHits  = srcInfo.readHits - 1
  endmethod

  # ----------------------------------------------------------------------------
  #                                  Public API
  # ----------------------------------------------------------------------------

  method processOneItem(item)
    opcode = item[0]
    dst    = item[1]
    src    = item[2]

    # print '[ MIRQuadOptimizer ]', opcode

    if (this.lastOpcode is 'store_index') or (this.lastOpcode is 'store_key')
      this._emitOneItem(item)

    elif this.lastOpcode is 'call'
      # Temporary fix for x = foo(x).
      this._emitOneItem(item)

    elif this.lastOpcode is 'vcall'
      # Temporary fix for x = x.foo().
      this._emitOneItem(item)

    elif ((opcode is 'print_array_of_variants_ln') and
          (this.lastOpcode is 'print_array_of_variants_ln'))
      # TODO: Use if x,y are ... ?
      this.lastDst[@afterlast] = '__EOL'
      for values oneItem in dst
        this.lastDst[@afterlast] = oneItem
      endfor

      dst = this.lastDst

    elif ((opcode is 'move') and
          (this.lastOpcode isnt 'move') and
          (typeof(this.lastDst) is 'string') and
          (this.lastDst is src))

      # tmp := x + y
      # z   := tmp
      buffer      = this.buffer
      lastItem    = buffer[@last]
      lastItem[1] = dst

    elif opcode is 'jmp_if_false'
      newOpcode = this.cmpXxJmpIfFalseMap{this.lastOpcode}

      if newOpcode is defined
        # cmp_xx       tmp, x, y
        # jmp_if_false label
        #this._decreaseReadAndWriteHits(src)
        this._replaceLastItem([newOpcode, dst, this.lastSrc1, this.lastSrc2])
      else
        # Not a cmp/jmp pattern. Do nothing.
        this._emitOneItem(item)
      endif

    elif opcode is 'jmp_if_true'
      newOpcode = this.cmpXxJmpIfTrueMap{this.lastOpcode}

      if newOpcode is defined
        # cmp_xx      tmp, x, y
        # jmp_if_true label
        #this._decreaseReadAndWriteHits(src)
        this._replaceLastItem([newOpcode, dst, this.lastSrc1, this.lastSrc2])
      else
        # Not a cmp/jmp pattern. Do nothing.
        this._emitOneItem(item)
      endif

    else
      this._emitOneItem(item)
    endif

    if opcode is 'proc'
      this.currentFrame = item[1]
    elif opcode is 'endp'
      this.flush()
    endif

    this.lastOpcode = opcode
    this.lastDst    = dst
    this.lastSrc1   = item[2]
    this.lastSrc2   = item[3]
  endmethod
endclass
