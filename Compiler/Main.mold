################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

DEBUG_AST_OPTIMIZER = false

import 'AST/AST.mold'
import 'Parser/ParserMold.mold'

import 'AppMold.mold'
import 'AST/ASTSymbolsCollector.mold'

import 'AST/ASTPrinterText.mold'
import 'AST/ASTPrinterHtml.mold'
import 'AST/ASTTranslatorMIR1.mold'
import 'MIR/MIRQuadCollector.mold'
import 'CodeGenerator/CodeGeneratorX64.mold'

#import 'AST/ASTTranslator.mold'
#import 'AST/ASTTranslatorMIR0.mold'
#import 'AST/ASTTranslatorMIR1.mold'

#import 'MIR/MIRQuadCollector.mold'
#import 'MIR/MIRQuadTypeGuess.mold'
#import 'MIR/MIRQuadTypeConvert.mold'
#import 'MIR/MIRQuadOptimizer.mold'

#import 'CodeGenerator/CodeGeneratorX64.mold'
import 'VM/VMachineStack.mold'

# ------------------------------------------------------------------------------
#                              Helper functions
# ------------------------------------------------------------------------------

function BadUsageError()
  print 'Usage:'
  print '  mold [-c] [--asm] [--mir0] [--mir] <input.mold>'
  exit()
endfunction

# ------------------------------------------------------------------------------
#                                Entry point
# ------------------------------------------------------------------------------

#
# Parse command line parameters.
#

mode = 'interpreter'
path = ''
optimizationLevel = 0

for idx in 1 .. argc
  if argv[idx] is '-c'
    # Compiler mode
    # mold -c <file.mold>
    mode = 'compiler'
    print 'Error: compiler mode not implemented yet.'
    print 'Try --asm option and assemble result on by own instead.'
    exit()

  elif argv[idx] is '--asm'
    # Generate assembler
    mode = 'asm'

  elif argv[idx] is '--mir0'
    # Generate assembler
    mode = 'mir0'

  elif (argv[idx] is '--mir') or (argv[idx] is '--mir1')
    # Generate assembler
    mode = 'mir1'

  elif argv[idx] is '--ast'
    # Show AST tree
    mode = 'ast'

  elif argv[idx] is '--astjson'
    # Show AST tree as JSON.
    mode = 'astjson'

  elif argv[idx] is '--prettyPrinter'
    # Show parsed mold code
    mode = 'prettyPrinter'

  elif argv[idx] is '--debug-parser'
    # Enable debug logs
    UNICC_DEBUG = true

  elif argv[idx] is '--debug'
    DEBUG_AST_OPTIMIZER = true
    DEBUG_MOLD          = true

  elif argv[idx] is '-O0'
    optimizationLevel = 0

  elif argv[idx] is '-O1'
    optimizationLevel = 1

  elif argv[idx] is '-O2'
    optimizationLevel = 2

  elif argv[idx] is '-O3'
    optimizationLevel = 3

  elif argv[idx][0] is '-'
    # Unknown -x switch.
    BadUsageError()

  else
    # Unkown option - treat as filename.
    path = argv[idx]
  endif
endfor

if path is ''
  BadUsageError()
endif

#
# Load input file and build Abstract Syntax Tree (AST)
#

app    = new AppMold()

app._debug('Creating parser object...')
parser = new Parser()

app._debug('Parsing source...')
ast    = parser.parseFile(path)

#
# Dispatch working mode.
#

if mode is 'ast'
  # Print AST only.
  ast.print()

elif mode is 'astjson'
  # Print AST, but in importable JSON format.
  ast = ast.convert()
  print ast

else
  # Convert AST to understood by translator format.
  # TODO: Remove this step.
  app._debug('Converting AST...')
  ast = ast.convert()

  # Resolve imports if any.
  app._debug('Resolving imports...')
  astModuleResolver = app.getAstModuleResolver()
  astModuleResolver.resolveImports(ast)

  # Build symbol table.
  app._debug('Building symbol table...')
  astSymbolsCollector = app.getAstSymbolsCollector()
  astSymbolsCollector.buildSymbolTable(ast)

  # Optimize AST if needed.
  app._debug('Optimizing AST...')

  if optimizationLevel is 0
    # No optimization - do nothing.
    # TODO: Why we need call evaluate here?
    # (Newton method test failed without it)
    app._debug('Evaluating AST nodes...')
    app.getAstEvaluator().processNode(ast)

  elif optimizationLevel is 1
    # Optimization level #1 (basic AST optimizations):
    # - constant folding,
    # - dead code elimination,
    # - common subexpression elimination (CSE).

    # Common preprocess before go-on with any AST optimization.
    app._debug('Evaluating AST nodes...')
    app.getAstEvaluator().processNode(ast)

    # TODO: More generic way to apply selected optimizations.
    app._debug('Constant folding...')
    app.getAstOptimizerConstantFolding().processNode(ast)

    app._debug('Dead code elimination...')
    app.getAstOptimizerDeadCodeRemove().processNode(ast)

    app._debug('Common subexpression elimination (CSE)...')
    app.getAstOptimizerCSE().processNode(ast)
  else
    die('error: optimization level #' + str(optimizationLevel) + ' is not implemented yet')
  endif

  if (mode is 'mir0') or (mode is 'interpreter')
    die('error: mir0 based modes are temporary disabled')

    # Translate program to MIR0 (stack based).
#    astTranslator = new ASTTranslatorMIR0()
#    astTranslator.run(ast)
#    code = astTranslator.code

    # Load MIR0 code into virtual machine.
#    vm = new VMachineStack()
#    vm.loadCode(code)
#
#    if mode is 'mir0'
#      # Dump stack MIR0 only.
#      vm.dumpCode()
#
#    elif mode is 'interpreter'
#      # Run virtual machine (stack based).
#      vm.run()
#    endif

  else
    # Prepare quads process toolchain.
    # [AST] -> [MIR1] -> [Collector]
    # Translate program to MIR1 (register based).
    astTranslator    = new ASTTranslatorMIR1(app)
    mirQuadCollector = new MIRQuadCollector()

    if mode is 'prettyPrinter'
      # Show formatted mold code.
      astPrinterText = new ASTPrinterText()
      astPrinterText.printNode(ast)

    else
      # Go on with further code processing.
      # Pass translated AST to MIR1.
      astTranslator.connectTo(mirQuadCollector)

      app._debug('Type cast...')
      app.getAstTypeCast().processNode(ast)

      # Run build quads process.
      app._debug('Translating AST...')
      astTranslator.run(ast)

      # TODO
      #if optimizationLevel >= 1
      #  # TODO: Auto flush on stream end.
      #  mirQuadTypeGuess.flush()
      #endif

      if mode is 'mir1'
        # Print MIR quads only
        mirQuadCollector.printQuads()

      elif mode is 'asm'
        # TODO: Better way to pass quads + meta.
        code             = astTranslator.code
        code.quads       = mirQuadCollector.getQuads()
        code.symbolTable = app.getSymbolTable()

        # Generate x64 code.
        app._debug('Generating x64 code...')
        codeGenerator = new CodeGeneratorX64()
        codeGenerator.run(code)

      else
        BadUsageError()
      endif
    endif
  endif
endif
