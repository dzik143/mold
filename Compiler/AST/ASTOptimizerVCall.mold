################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

import 'AST/AST.mold'
import 'AST/ASTUtils.mold'

class ASTOptimizerVCall
  method constructor(app)
    this.app         = app
    this.symbolTable = app.getSymbolTable()
  endmethod

  method _debug(msg)
    global DEBUG_AST_OPTIMIZER
    if DEBUG_AST_OPTIMIZER is true
      print '[ ASTOptimizerVCall ]', msg
    endif
  endmethod

  method _processNode(node)
    global AST_OPCODE_INVOKE_METHOD
    global AST_OPCODE_BLOCK
    global AST_OPCODE_CALL

    opcode      = node.opcode
    children    = node.children
    childrenCnt = node.childrenCnt

    if opcode is AST_OPCODE_INVOKE_METHOD
      # obj.foo(...)
      thiz           = children[0]
      symbolInfoThiz = thiz.symbolInfo

      if typeof(symbolInfoThiz) isnt 'undefined'
        classProto = thiz.symbolInfo.classProto

        if (typeof(classProto) isnt 'undefined') and (typeof(classProto.vtable) isnt 'undefined')
          # We already know class proto.
          # Convert vcall to ordinary call.
          methodProto = classProto.vtable[node.value]

          if typeof(methodProto) isnt 'undefined'
            if methodProto.isOverloaded is true
              # Method is overloaded by another class.
              # Keep virtual call.
              this._debug('Skipped vcall [' + node.value + '] at node #' + str(node.id))

            else
              node.value      = methodProto.fullName
              node.opcode     = AST_OPCODE_CALL
              node.symbolInfo = this.symbolTable.lookupForCall(methodProto.fullName)
              this._debug('Changed vcall [' + node.value + '] to ordinary call at node #' + str(node.id))

              # TODO: Optimize it.
              # Detect recursive calls. We use it in further optimizations.
              blockNode   = AST_GetParentBlock(node)
              symbolTable = blockNode.symbolTable

              if symbolTable.getCurrentFunctionName() is methodProto.fullName
                this._debug('Recursive call detected at node #' + str(node.id) + ' (' + methodProto.fullName + ')')
                node.symbolInfo.proto.isRecursive = true
              endif
            endif
          endif
        endif
      endif

    else
      # Process child nodes recursively.
      for values oneChild in children
        this._processNode(oneChild)
      endfor
    endif
  endmethod

  method processNode(node)
    this._processNode(node)
  endmethod
endclass
