################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

class ASTAnalyzer

  method constructor(app)
    this.app = app
  endmethod

  # ----------------------------------------------------------------------------
  #                                  Public API
  # ----------------------------------------------------------------------------

  method collectGlobals(ast) -> rv
    global AST_OPCODE_DECLARE
    global AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_FUNCTION
    global AST_OPCODE_CLASS
    global AST_OPCODE_NOP
    global AST_OPCODE_VARIABLE

    vars          = []
    functionNodes = []
    classNodes    = []

    varsCnt          = 0
    functionNodesCnt = 0
    classNodesCnt    = 0

    # Search for variable, function and class declarations.
    program     = ast['children'][0]
    children    = program['children']
    childrenCnt = program['childrenCnt']

    for idx in 0 .. childrenCnt
      child  = children[idx]
      opcode = child['opcode']

      if (opcode is AST_OPCODE_DECLARE) or (opcode is AST_OPCODE_DECLARE_OR_ASSIGN)
        # Variable declaration - move to top.
        lval = child['children'][0]

        if lval['opcode'] is AST_OPCODE_VARIABLE
          # Direct variable usage, declare it at the top of emited code.
          vars[varsCnt] = lval['value']
          varsCnt       = varsCnt + 1
        endif

      elif opcode is AST_OPCODE_FUNCTION
        # Function declaration.
        child['opcode']                 = AST_OPCODE_NOP
        functionNodes[functionNodesCnt] = child
        functionNodesCnt                = functionNodesCnt + 1

      elif opcode is AST_OPCODE_CLASS
        # Create new slot for class vtable.
        child['opcode']           = AST_OPCODE_NOP
        classNodes[classNodesCnt] = child
        classNodesCnt             = classNodesCnt + 1
      endif
    endfor

    # Build result object.
    rv = {
      'vars': vars,
      'varsCnt': varsCnt,
      'functionNodes': functionNodes,
      'functionNodesCnt': functionNodesCnt,
      'classNodes': classNodes,
      'classNodesCnt': classNodesCnt
    }
  endmethod

  method analyzeClassNode(ast) -> rv
    global AST_OPCODE_CLASS_METHOD

    app = this.app

    # Collect members.
    # TODO: Avoid redundant methodsAsArray when map iteration will work.
    className             = ast['name']
    baseName              = ast['baseName']
    children              = ast['children']
    childrenCnt           = ast['childrenCnt']
    vtable                = {}
    baseMethods           = {}
    methodsAsFlatArray    = []
    methodsAsFlatArrayCnt = 0

    # Import base class if any.
    if typeof(baseName) isnt 'undefined'
      # Derived class, build class by applying derived over base one.
      baseProto = app._getClassProto(baseName)

      # TODO: Rewrite it when map merge will be ready.
      baseMethodsAsFlatArray    = baseProto['methodsAsFlatArray']
      baseMethodsAsFlatArrayCnt = baseProto['methodsAsFlatArrayCnt']
      baseMethods               = baseProto['vtable']

      # Merge base class first.
      for idx in 0 .. baseMethodsAsFlatArrayCnt
        methodName      = baseMethodsAsFlatArray[idx]
        methodProto     = baseMethods[methodName]
        methodParamsCnt = methodProto['paramsCnt']
        methodFullName  = '__' + className + '_' + methodName + '$' + str(methodParamsCnt)

        newMethodProto = {
          'value': methodProto['value'],
          'name': methodName,
          'fullName': methodFullName,
          'params': methodProto['params'],
          'paramsCnt': methodParamsCnt,
          'children': methodProto['children'],
          'childrenCnt': methodProto['childrenCnt'],
          'opcode': methodProto['opcode'],
          'baseMethod': methodProto['baseMethod'],
          'rv': methodProto['rv']
        }

        vtable[methodName] = newMethodProto
        methodsAsFlatArray[methodsAsFlatArrayCnt] = methodName
        methodsAsFlatArrayCnt = methodsAsFlatArrayCnt + 1
      endfor
    endif

    # Apply current declared class.
    for idx in 0 .. childrenCnt
      child  = children[idx]
      opcode = child['opcode']

      if opcode is AST_OPCODE_CLASS_METHOD
        methodName      = child['name']
        methodParamsCnt = child['paramsCnt']
        methodFullName  = '__' + className + '_' + methodName + '$' + str(methodParamsCnt)

        child['fullName']  = methodFullName

        if typeof(vtable[methodName]) is 'undefined'
          # Method seen first time.
          methodsAsFlatArray[methodsAsFlatArrayCnt] = methodName
          methodsAsFlatArrayCnt = methodsAsFlatArrayCnt + 1
        endif

        if typeof(baseMethods[methodName]) isnt 'undefined'
          # Save proto of base method if any.
          child['baseMethod'] = baseMethods[methodName]
        endif

        vtable[methodName] = child
      endif
    endfor

    # Build result object.
    rv = {
      'name': className,
      'baseName': ast['baseName'],
      'vtable': vtable,
      'methodsAsFlatArray': methodsAsFlatArray,
      'methodsAsFlatArrayCnt': methodsAsFlatArrayCnt
    }
  endmethod
endclass
