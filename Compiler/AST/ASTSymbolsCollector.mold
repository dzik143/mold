################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

import 'AST/AST.mold'
import 'AST/ASTUtils.mold'

class ASTSymbolsCollector

  method constructor(app)
    this.app = app

    # TODO: Remove redundant array if map iteration will work.
    this.vtable        = {}
    this.vtableKeys    = []
    this.vtableKeysCnt = 0
  endmethod

  # ----------------------------------------------------------------------------
  #                          Internal API (private)
  # ----------------------------------------------------------------------------

  method _debug(msg)
    global DEBUG_AST_OPTIMIZER
    if DEBUG_AST_OPTIMIZER is true
      print '[ ASTSymbolsCollector ]', msg
    endif
  endmethod

  method _collectSymbolsFromLeftNode(symbolTable, node)
    this._collectSymbols(symbolTable, node, true)
  endmethod

  method _collectSymbolsFromRightNode(symbolTable, node)
    this._collectSymbols(symbolTable, node, false)
  endmethod

  method _updateVariableSymbolInfo(node, variableName, newSymbolInfo)
    global AST_OPCODE_VARIABLE

    # TODO: Clean up this mess.
    if node.opcode is AST_OPCODE_VARIABLE
      if node.value is variableName
        node.symbolInfo = newSymbolInfo
      endif

    else
      childrenCnt = node.childrenCnt
      children    = node.children

      for idx in 0 .. childrenCnt
        this._updateVariableSymbolInfo(children[idx], variableName, newSymbolInfo)
      endfor
    endif
  endmethod

  method _collectSymbols(symbolTable, node, isLeftNode)
    global AST_OPCODE_PROGRAM
    global AST_OPCODE_BLOCK
    global AST_OPCODE_VARIABLE
    global AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_CALL
    global AST_OPCODE_IF
    global AST_OPCODE_WHILE
    global AST_OPCODE_FOR_VALUES_RANGE
    global AST_OPCODE_INVOKE_METHOD
    global AST_OPCODE_REFERENCE
    global AST_OPCODE_FUNCTION
    global AST_OPCODE_CLASS
    global AST_OPCODE_CLASS_METHOD
    global AST_OPCODE_NOP
    global AST_OPCODE_TYPE_CAST
    global AST_OPCODE_COMPARE_EQ
    global AST_OPCODE_COMPARE_LE
    global AST_OPCODE_BOOL_NOT
    global AST_OPCODE_CALL_NEW
    global AST_DATA_BOOL
    global AST_DATA_OBJECT
    global AST_DATA_ARRAY
    global AST_DATA_STRING
    global SYMBOL_KIND_VAR_GLOBAL, SYMBOL_KIND_VAR_RETVAL, SYMBOL_KIND_CONST
    global AST_OPCODE_ADD, AST_OPCODE_MUL, AST_OPCODE_SUB, AST_OPCODE_DIV, AST_OPCODE_IDIV
    global AST_DATA_DOUBLE, AST_DATA_INTEGER

    opcode      = node.opcode
    children    = node.children
    childrenCnt = node.childrenCnt

    # TODO: Remove it.
    # We use it to work-around problem with emitting [object] to
    # external source.ast file.
    for idx in 0 .. childrenCnt
      children[idx].parent = node
    endfor

    # TODO: Clean up this mess.
    if (opcode is AST_OPCODE_VARIABLE) and (node.value is '__this_placeholder__')
      # Do nothing.

    elif opcode is AST_OPCODE_PROGRAM
      symbolTable      = this.app.getSymbolTable()
      node.symbolTable = symbolTable

      for idx in 0 .. childrenCnt
        this._collectSymbolsFromLeftNode(node.symbolTable, children[idx])
      endfor

    elif opcode is AST_DATA_STRING
      if isLeftNode is true
        die('error: string type cannot be modified')
      endif

      symbolInfo = symbolTable.insertLiteral(node.value)

      node.opcode     = AST_OPCODE_VARIABLE
      node.value      = symbolInfo.name
      node.symbolInfo = symbolInfo

    elif opcode is AST_OPCODE_CLASS
      # Collect members.
      # TODO: Avoid redundant methodsAsArray when map iteration will work.
      className             = node['name']
      baseName              = node['baseName']
      vtable                = {}
      baseMethods           = {}
      methodsAsFlatArray    = []
      methodsAsFlatArrayCnt = 0
      classProto            = {}

      # Import base class if any.
      if typeof(baseName) isnt 'undefined'
        # Derived class, build class by applying derived over base one.
        baseProto = symbolTable.lookupClass(baseName)['proto']

        # TODO: Rewrite it when map merge will be ready.
        baseMethodsAsFlatArray    = baseProto['methodsAsFlatArray']
        baseMethodsAsFlatArrayCnt = baseProto['methodsAsFlatArrayCnt']
        baseMethods               = baseProto['vtable']

        # Merge base class first.
        for idx in 0 .. baseMethodsAsFlatArrayCnt
          methodName      = baseMethodsAsFlatArray[idx]
          methodProto     = baseMethods[methodName]
          methodParamsCnt = methodProto['paramsCnt']
          methodFullName  = '__' + className + '_' + methodName + '$' + str(methodParamsCnt)

          this.vtable[methodFullName]         = baseMethods[methodName]['fullName']
          this.vtableKeys[this.vtableKeysCnt] = methodFullName
          this.vtableKeysCnt                  = this.vtableKeysCnt + 1

          vtable[methodName] = methodProto
          methodsAsFlatArray[methodsAsFlatArrayCnt] = methodName
          methodsAsFlatArrayCnt = methodsAsFlatArrayCnt + 1
        endfor
      endif

      # Apply current declared class.
      for idx in 0 .. childrenCnt
        child  = children[idx]
        opcode = child['opcode']

        if opcode is AST_OPCODE_CLASS_METHOD
          methodName      = child['name']
          methodParamsCnt = child['paramsCnt']
          methodFullName  = '__' + className + '_' + methodName + '$' + str(methodParamsCnt)

          child['fullName']  = methodFullName

          this.vtable[methodFullName] = methodFullName

          if typeof(vtable[methodName]) is 'undefined'
            # Method seen first time.
            methodsAsFlatArray[methodsAsFlatArrayCnt] = methodName
            methodsAsFlatArrayCnt = methodsAsFlatArrayCnt + 1
          endif

          child['className']  = className
          child['classProto'] = classProto

          if typeof(baseMethods[methodName]) isnt 'undefined'
            # Save proto of base method if any.
            baseMethodProto     = baseMethods[methodName]
            child['baseMethod'] = baseMethodProto
            baseMethodProto.isOverloaded = true

          else
            this.vtableKeys[this.vtableKeysCnt] = methodFullName
            this.vtableKeysCnt                  = this.vtableKeysCnt + 1
          endif

          vtable[methodName] = child

          this._collectSymbolsFromLeftNode(symbolTable, child)
        endif
      endfor

      # Declare new class.
      classProto.name                  = className
      classProto.baseName              = node['baseName']
      classProto.vtable                = vtable
      classProto.methodsAsFlatArray    = methodsAsFlatArray
      classProto.methodsAsFlatArrayCnt = methodsAsFlatArrayCnt
      classProto.propertyClassNames    = {}

      node['proto'] = classProto

      symbolTable.insertClass(className, classProto)

    elif (opcode is AST_OPCODE_FUNCTION) or (opcode is AST_OPCODE_CLASS_METHOD)
      nodeBody  = children[0]
      funcProto = node
      value     = node.value
      params    = value['parameters']

      funcProto['params']    = params
      funcProto['paramsCnt'] = len(params)
      funcProto['name']      = value['name']
      funcProto['rv']        = value['rv']

      if typeof(node['fullName']) isnt 'undefined'
        funcName = node['fullName']
      else
        funcName = value['name']
      endif

      funcProto['fullName'] = funcName

      symbolTable.insertFunction(funcName, funcProto)

      if typeof(nodeBody.symbolTable) is 'undefined'
        # Init new symbol table if not existing yet.
        nodeBody.symbolTable = symbolTable.enterScopeForProcedure(funcName)

        paramShift = 0

        # TODO: Why we need to add this param by hand?
        if opcode is AST_OPCODE_CLASS_METHOD
          # Optimize it.
          symbolInfo = nodeBody.symbolTable.insertParam('this', 0)
          symbolInfo.classProto = funcProto.classProto
          nodeBody.symbolTable.assignType('this', AST_DATA_OBJECT)

          paramShift = 1
        endif

        for idx in 0 .. funcProto.paramsCnt
          paramName = funcProto.params[idx]
          nodeBody.symbolTable.insertParam(paramName, paramShift + idx)

          # TODO: Handle non-variant parameters.
          nodeBody.symbolTable.assignType(paramName, -1)
        endfor
      endif

      this._collectSymbolsFromLeftNode(nodeBody.symbolTable, nodeBody)

      # Verify is return value set after function end if needed.
      if typeof(funcProto.rv) isnt 'undefined'
        if nodeBody.symbolTable.isset(funcProto.rv) is true
          # Return value is set inside all branches. Go on.
          # Change variable kind to RETVAL and force variant type.
          # TODO: Handle non-variant return values.
          symbolInfo         = nodeBody.symbolTable.lookup(funcProto.rv)
          symbolInfo.kind    = SYMBOL_KIND_VAR_RETVAL
          symbolInfo.astType = -1

          # TODO: Clean up this mess.
          symbolInfo.name     = '__rv'
          symbolInfo.alias    = funcProto.rv
          symbolInfo.readHits = symbolInfo.readHits + 1
          nodeBody.symbolTable.symbols['__rv'] = symbolInfo

        else
          # Error - there is at least one branch, where return value is
          # not set.
          die("error: unset return variable '" + funcProto.rv + "' in '" + funcName + "' function")
        endif
      endif

    elif opcode is AST_OPCODE_BLOCK
      if typeof(node.symbolTable) is 'undefined'
        # Init new symbol table if not existing yet.
        node.symbolTable = symbolTable.enterScope()

        # TODO: Review it.
        if node.symbolTable.deepIdx is 1
          node.symbolTable.importExternalVariable('argv')
          node.symbolTable.importExternalVariable('argc')
        endif
      endif

      for idx in 0 .. childrenCnt
        this._collectSymbolsFromLeftNode(node.symbolTable, children[idx])
      endfor
      node.symbolTable.leaveScope()

    elif opcode is AST_OPCODE_VARIABLE
      if isLeftNode is true
        # x = ...
        symbolInfo = symbolTable.lookupForWrite(node.value)
      else
        # ... = x
        symbolInfo = symbolTable.lookupForRead(node.value)
      endif

      # Track data type.
      node.symbolInfo = symbolInfo

    elif opcode is AST_OPCODE_REFERENCE
       # There are two cases:
       # 1. x[i] = ...  : x is left , i is right
       # 2. ...  = x[i] : x is right, i is right
       # Rule:
       # - x always save L/R context,
       # - index (i) has always R context (lookup for read).

       this._collectSymbols(symbolTable, children[0], isLeftNode)
       this._collectSymbolsFromRightNode(symbolTable, children[1])

       # TODO: Review it.
       # It's not needed - we already accessed box container.
       if children[0].opcode is AST_OPCODE_VARIABLE
         # x[i] = ... is read for x too.
         symbolTable.lookupForRead(children[0].value)
       endif

    elif opcode is AST_OPCODE_DECLARE_OR_ASSIGN
      # lval = rval
      lval = children[0]
      rval = children[1]

      if lval.opcode is AST_OPCODE_VARIABLE
        # TODO: Review it.
        # Handle constant arrays.
        if (rval.opcode is AST_DATA_ARRAY) and (typeof(rval.value) is 'array')
          # Insert new constant.
          symbolInfo  = symbolTable.insertConst(lval.value, rval.value)
          node.opcode = AST_OPCODE_NOP
        else
          # Simple lval (single variable) - insert into symbol table.
          symbolInfo = symbolTable.lookupForWriteOrInsert(lval.value)
        endif

        lval.symbolInfo = symbolInfo

        # Scan rval.
        this._collectSymbolsFromRightNode(symbolTable, rval)

        # Save value node for constant propagation.
        symbolTable.assignNode(lval.value, lval)

        if AST_IsImm(rval)
          symbolTable.assignValue(lval.value, rval.value)
        endif

        # Handle well-known types.
        if rval.opcode is AST_OPCODE_CALL_NEW
          # lval = new Xxx(...)
          if symbolTable.isset(rval.value) is true
            oldClassProto = symbolInfo.classProto
            newClassProto = symbolTable.lookupClass(rval.value).proto

            if (typeof(oldClassProto) isnt 'undefined') and (oldClassProto isnt newClassProto)
              # Class mismatch.
              # obj = new A()
              # obj = new B()
              #
              # TODO: Clean up this mess.
              this._debug('Class mismatch while assigning new object at node #' + str(node.id))
              x = []
              symbolInfo.classProto = x[0]
            else
              symbolInfo.classProto = newClassProto
            endif
          endif
        endif

        # TODO: Review it.
        symbolTable.assignType(lval.value, AST_GetDataType(rval))

        # TODO?
        # Handle overwrite one object by instance of another one.
        # objA = new A()
        # objB = new B()
        # obj = objA
        # obj = objB

      else
        # Complex lval - go on deeper.
        this._collectSymbolsFromLeftNode(symbolTable, lval)
        this._collectSymbolsFromRightNode(symbolTable, rval)
      endif

    elif opcode is AST_OPCODE_IF
      # if cond then x else y
      # cond is rval,
      # x,y are lval.

      # Scan condition (rval)
      this._collectSymbolsFromRightNode(symbolTable, children[0])

      # Scan condition (lval)
      this._collectSymbolsFromLeftNode(symbolTable, children[1])

      if childrenCnt is 3
        # Optional else block (lval).
        this._collectSymbolsFromLeftNode(symbolTable, children[2])

        # Merge symbols defined in both nodes. We know it's always set.
        # if cond
        #   x = 1
        # else
        #   x = 2
        # endif

        symbolTable1 = children[1].symbolTable
        symbolTable2 = children[2].symbolTable

        symbols1 = symbolTable1.exportSymbols()
        symbols2 = symbolTable2.exportSymbols()

        symbolsIndex1 = symbols1._index
        symbolsIndex2 = symbols2._index

        for idx in 0 .. len(symbolsIndex1)
          symbolInfo1 = symbolsIndex1[idx]
          symbolInfo2 = symbols2[symbolInfo1.name]

          if typeof(symbolInfo2) isnt 'undefined'
            # Symbol defined in both nodes - move into parent node.
            # TODO: Use max(x, y) or x+y?
            readHits  = symbolInfo1.readHits  + symbolInfo2.readHits
            writeHits = symbolInfo1.writeHits + symbolInfo2.writeHits

            # Remove from child true/false node.
            symbolTable1.remove(symbolInfo1.name)
            symbolTable2.remove(symbolInfo1.name)

            if symbolTable.isset(symbolInfo1.name) is false
              symbolTable.insert(symbolInfo1.name, symbolInfo1)
            endif

            symbolInfo1.readHits  = readHits
            symbolInfo1.writeHits = writeHits

            # Merge AST data type.
            astType1 = symbolTable1.astType
            astType2 = symbolTable2.astType

            if astType1 isnt astType2
              # Type mismatch.
              astType = -1

              if (astType1 is AST_DATA_DOUBLE) and (astType2 is AST_DATA_INTEGER)
                astType = AST_DATA_DOUBLE

              elif (astType1 is AST_DATA_INTEGER) and (astType2 is AST_DATA_DOUBLE)
                astType = AST_DATA_DOUBLE
              endif

              symbolInfo1.astType = astType

            else
              classProto1 = symbolInfo1.classProto
              classProto2 = symbolInfo2.classProto

              if classProto1 isnt classProto2
                # Object class mismatch. Keep virtual call.
                # TODO: Clean up this mess.
                x = []
                symbolInfo1.classProto = x[0]
              endif
            endif

            # TODO: Optimize it.
            this._updateVariableSymbolInfo(children[1], symbolInfo1.name, symbolInfo1)
            this._updateVariableSymbolInfo(children[2], symbolInfo1.name, symbolInfo1)
          endif
        endfor
      endif

      # TODO: Better way to merge symbols from IF branches recursively.
      if typeof(node.symbolTable) is 'undefined'
        node.symbolTable = symbolTable
      endif

    elif opcode is AST_OPCODE_FOR_VALUES_RANGE
      # for idx in idxStart .. idxEnd by step
      iterNode     = children[0]
      idxStartNode = children[1]
      idxEndNode   = children[2]
      idxStepNode  = children[3]
      bodyNode     = children[4]

      if symbolTable.isset(iterNode.value) is true
        die('error: "' + iterNode.value + '" is already defined in another context')
      endif

      # TODO: Optimize it.
      bodyNode.symbolTable = symbolTable.enterScopeForLoop()
      bodyNode.symbolTable.insertLocal(iterNode.value)
      iterNode.symbolInfo = bodyNode.symbolTable.lookupForReadAndWrite(iterNode.value)
      bodyNode.symbolTable.assignType(iterNode.value, AST_DATA_INTEGER)

      this._collectSymbolsFromRightNode(symbolTable, idxStartNode)
      this._collectSymbolsFromRightNode(symbolTable, idxEndNode)
      this._collectSymbolsFromRightNode(symbolTable, idxStepNode)
      this._collectSymbolsFromLeftNode(symbolTable, bodyNode)

    elif opcode is AST_OPCODE_WHILE
      # while (cond) body
      condNode = children[0]
      bodyNode = children[1]

      bodyNode.symbolTable = symbolTable.enterScopeForLoop()

      this._collectSymbolsFromRightNode(symbolTable, condNode)
      this._collectSymbolsFromLeftNode(symbolTable, bodyNode)

    else
      goOnIntoChildren = true

      if opcode is AST_OPCODE_CALL
        funcName = node.value
        if (funcName is 'typeof') or (funcName is 'print') or (funcName is 'super') or (funcName is 'len') or (funcName is 'str') or (funcName is 'strescape') or (funcName is 'exit') or (funcName is 'die') or (funcName is '__mold_createObject') or (funcName is '__mold_getClassName') or (funcName is '__mold_warning') or (funcName is '__mold_printToStdOutput') or (funcName is '__mold_parseFile') or (funcName is 'moldParseFile') or (funcName is 'global')
        # or (funcName is '__mold_openExternalModule') or (funcName is '__mold_loadExternalFunction') or (funcName is '__mold_peek') or (funcName is '__mold_loadFile')
          # One of built-in function - declaration is not needed.
          if symbolTable.isset(funcName) is false
            # TODO: Fill up proto?
            symbolTable.insertFunction(funcName, {'builtIn': true})
          endif
        endif

        # Mark that function was called.
        node.symbolInfo = symbolTable.lookupForCall(node.value)
        isLeftNode      = false

        # Mark recursive calls. We use it in further optizations.
        if (node.symbolInfo.proto.isRecursive isnt true) and (symbolTable.getCurrentFunctionName() is funcName)
          this._debug('Recursive call detected at node #' + str(node.id) + ' (' + funcName + ')')
          node.symbolInfo.proto.isRecursive = true
        endif

        # Import global symbol.
        if funcName is 'global'
          for idx in 0 .. childrenCnt
            symbolTable.importGlobal(children[idx].value)
          endfor
          goOnIntoChildren = false
        endif

      elif opcode is AST_OPCODE_INVOKE_METHOD
        isLeftNode = false
      endif

      if goOnIntoChildren is true
        for idx in 0 .. childrenCnt
          this._collectSymbols(symbolTable, children[idx], isLeftNode)
        endfor
      endif
    endif
  endmethod

  # ----------------------------------------------------------------------------
  #                                Public API
  # ----------------------------------------------------------------------------

  method buildSymbolTable(node)
    global AST_OPCODE_PROGRAM
    global AST_OPCODE_BLOCK

    # Only code blocks should store symbol table.
    if (node.opcode isnt AST_OPCODE_BLOCK) and (node.opcode isnt AST_OPCODE_PROGRAM)
      die('error: only block or program nodes can own symbol table')
    endif

    this._collectSymbolsFromLeftNode(node.symbolTable, node)
  endmethod
endclass
