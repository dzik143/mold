################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'AST/ASTTranslator.mold'
import 'MIR/MIR.mold'
import 'Utils/Stack.mold'

class ASTTranslatorMIR1 extends ASTTranslator

  # ----------------------------------------------------------------------------
  #                                Init code
  # ----------------------------------------------------------------------------

  method constructor(app)
    super(app)
    # TODO: Remove codeObj.
    this.app          = app
    # TODO: Clean up this mess.
    this.code         = app.getMir1Code()
    this.stack        = new Stack()
    this.outputObject = false

    # TODO: Remove this mess.
    this.arrayOfCalledMethods = []
    this.mapOfCalledMethods   = {}
    this.methodEmitted        = {}
  endmethod

  # ----------------------------------------------------------------------------
  #                              Internal helpers
  # ----------------------------------------------------------------------------

  method _emitOneItem(item)
    this.outputObject.processOneItem(item)
  endmethod

  method emitZeroArgsOpcode(opcode)
    newQuad = [opcode]
    this._emitOneItem(newQuad)
  endmethod

  method emitTargetOnlyOpcode(opcode, rv)
    newQuad = [opcode, rv]
    this._emitOneItem(newQuad)
  endmethod

  method emitOneArgOpcode(opcode, rv, x)
    newQuad = [opcode, rv, x]
    this._emitOneItem(newQuad)
    # TODO: Review it.
    # TODO: Simplify it.
    #if typeof(x) is 'string'
    #  this.symbolTable.releaseTempVar(x)
    #endif
  endmethod

  method emitTwoArgsOpcode(opcode, rv, x, y)
    newQuad = [opcode, rv, x, y]
    this._emitOneItem(newQuad)
    # TODO: Review it.
    # TODO: Simplify it.
    #if typeof(x) is 'string'
    #  this.symbolTable.releaseTempVar(x)
    #endif

    #if typeof(y) is 'string'
    #  this.symbolTable.releaseTempVar(y)
    #endif
  endmethod

  method emitComment(comment)
    this.emitTargetOnlyOpcode('comment', comment)
  endmethod

  method emitLabel(label)
    this.emitTargetOnlyOpcode('label', label)
  endmethod

  method emitJmp(label)
    this.emitTargetOnlyOpcode('jmp', label)
  endmethod

  method emitJmpByTable(jmpTable, labelIdx)
    newQuad = ['jmp_by_table', jmpTable, labelIdx]
    this._emitOneItem(newQuad)
  endmethod

  method emitMoveVariantOpcode(dst, src)
    this.emitOneArgOpcode('move', dst, src)
  endmethod

  method popForRead() -> rv
    rv = this.stack.pop()
    # TODO: Is it really needed at translation stage?
    # this.symbolTable.lookupForRead(rv)
    # TODO: Review it.
    #this.symbolTable.releaseTempVar(rv)
  endmethod

  method popForWrite() -> rv
    rv = this.stack.pop()
    # TODO: Is it really needed at translation stage?
    # this.symbolTable.lookupForWrite(rv)
    # TODO: Review it.
    #this.symbolTable.releaseTempVar(rv)
  endmethod

  method push(x)
    this.stack.push(x)
  endmethod

  method popOneArgAndEmitOpcode(opcode, rv)
    x = this.popForRead()
    this.push(rv)
    this.emitOneArgOpcode(opcode, rv, x)
  endmethod

  method popTwoArgsAndEmitOpcode(opcode, rv)
    y = this.popForRead()
    x = this.popForRead()
    this.push(rv)
    this.emitTwoArgsOpcode(opcode, rv, x, y)
  endmethod

  method popParametersBeforeCall(paramsCnt) -> params
    params = []

    for idx in 0 .. paramsCnt
      item        = this.stack.peekN(paramsCnt - idx)
      params[idx] = item

      # TODO: Is it really needed at translation stage?
      #this.symbolTable.lookup(item)
      # TODO: Review it.
      #this.symbolTable.releaseTempVar(item)
    endfor

    this.stack.eatN(paramsCnt)
  endmethod

  method emitProcBegin(procMeta)
    this.emitTargetOnlyOpcode('proc', procMeta)
    this.emitTargetOnlyOpcode('init_frame', procMeta)
  endmethod

  method emitProcEnd()
    this.emitZeroArgsOpcode('endp')
  endmethod

  method emitRet()
    this.emitZeroArgsOpcode('ret')
  endmethod

  method emitMoveBackVariant()
    src = this.popForRead()
    dst = this.popForWrite()
    this.emitMoveVariantOpcode(dst, src)
    this.push(dst)
  endmethod

  # ----------------------------------------------------------------------------
  #                         Implement built-in functions
  # ----------------------------------------------------------------------------

  method _callStr(rv, x)
    this.popOneArgAndEmitOpcode('str', rv)
  endmethod

  method _callStrEscape(rv, x)
    this._error('_callStrEscape() is not implemented')
  endmethod

  method _callLen(rv, x)
    this.popOneArgAndEmitOpcode('len', rv)
  endmethod

  method _callExit()
    this.emitZeroArgsOpcode('halt')
    this.push('<error:unused_rv>')
  endmethod

  method _callMoldWarning(msg)
    this.emitTargetOnlyOpcode('print_err', this.popForRead())
    this.push('<print:unused_rv>')
  endmethod

  method _callMoldPrintToStdOut(msg)
    this.emitTargetOnlyOpcode('print_out', this.popForRead())
    this.push('<print:unused_rv>')
  endmethod

  method _callDie(msg)
    this._callMoldWarning(msg)
    this._callExit()
  endmethod

  method _callMoldCreateObject(rv, classProto)
    this._error('__mold_createObject() is not implemented')
  endmethod

  method _callMoldGetClassName(rv, thiz)
    this._error('_callMoldGetClassName() is not implemented')
  endmethod

  method _callMoldParseFile(rv, filePath)
    this._error('_callMoldParseFile() is obsolete')
  endmethod

  method _loadArgsVector(rv)
    # TODO: Avoid move here?
    this.emitMoveVariantOpcode(rv, 'argv')
    this.push(rv)
  endmethod

  method _loadArgsCount(rv)
    # TODO: Avoid move here?
    this.emitMoveVariantOpcode(rv, 'argc')
    this.push(rv)
  endmethod

  # ----------------------------------------------------------------------------
  #                     Implement ASTTranslator interface
  # ----------------------------------------------------------------------------

  method _neg(rv, value)
    this.popOneArgAndEmitOpcode('neg', rv)
  endmethod

  method _add(rv, x, y)
    this.popTwoArgsAndEmitOpcode('add', rv)
  endmethod

  method _sub(rv, x, y)
    this.popTwoArgsAndEmitOpcode('sub', rv)
  endmethod

  method _mul(rv, x, y)
    this.popTwoArgsAndEmitOpcode('mul', rv)
  endmethod

  method _div(rv, x, y)
    this.popTwoArgsAndEmitOpcode('div', rv)
  endmethod

  method _idiv(rv, x, y)
    this.popTwoArgsAndEmitOpcode('idiv', rv)
  endmethod

  method _loadArray(rv)
    this.emitTargetOnlyOpcode('create_array', rv)
    this.push(rv)
  endmethod

  method _loadMap(rv)
    this.emitTargetOnlyOpcode('create_map', rv)
    this.push(rv)
  endmethod

  method _loadImm(rv, value)
    type = typeof(value)

    if type is 'integer'
      if (value >= -2147483648) and (value <= 2147483647)
        # 32-bit integer
        # TODO: Review it: this.emitOneArgOpcode('conv_int32_to_variant', rv, value)
        this.emitOneArgOpcode('load_int32', rv, value)
      else
        # 64-bit integer
        # TODO: Review it: this.emitOneArgOpcode('conv_int64_to_variant', rv, value)
        this.emitOneArgOpcode('load_int64', rv, value)
      endif

    elif type is 'float'
      # TODO: Review it: this.emitOneArgOpcode('conv_float64_to_variant', rv, value)
      this.emitOneArgOpcode('load_float64', rv, value)

    elif type is 'boolean'
      # TODO: Review it: this.emitOneArgOpcode('conv_bool32_to_variant', rv, value)
      this.emitOneArgOpcode('load_bool32', rv, value)

    elif (type is 'string') or (type is 'array')
      # TODO: Review it.
      # TODO: Avoid move here?
      newConst = this.symbolTable.createConstFromValue(value)
      this.emitMoveVariantOpcode(rv, newConst)

    else
      # TODO: Handle terminal nodes.
      die('error: unhandled imm type: ' + str(type))
    endif

    this.push(rv)
  endmethod

  method _loadImmAsVariant(rv, value)
    type = typeof(value)

    if type is 'integer'
      if (value >= -2147483648) and (value <= 2147483647)
        # 32-bit integer
        this.emitOneArgOpcode('conv_int32_to_variant', rv, value)
      else
        # 64-bit integer
        this.emitOneArgOpcode('conv_int64_to_variant', rv, value)
      endif

    elif type is 'float'
      this.emitOneArgOpcode('conv_float64_to_variant', rv, value)

    elif type is 'boolean'
      this.emitOneArgOpcode('conv_bool32_to_variant', rv, value)

    elif (type is 'string') or (type is 'array')
      # TODO: Review it.
      # TODO: Avoid move here?
      newConst = this.symbolTable.createConstFromValue(value)
      this.emitMoveVariantOpcode(rv, newConst)

    else
      # TODO: Handle terminal nodes.
      die('error: unhandled imm type: ' + str(type))
    endif

    this.push(rv)
  endmethod

  method _convert(rv, unusedSrc, srcType, dstType)
    srcTypeMIR = AST_ConvertDataTypeToMIR(srcType)
    dstTypeMIR = AST_ConvertDataTypeToMIR(dstType)


    if srcTypeMIR is dstTypeMIR
      # TODO: Avoid move here?
      this.popOneArgAndEmitOpcode('move', rv)

    else
      opcode = 'conv_' + srcTypeMIR + '_to_' + dstTypeMIR
      this.popOneArgAndEmitOpcode(opcode, rv)
    endif
  endmethod

  method _compareEQ(rv, x, y)
    this.popTwoArgsAndEmitOpcode('cmp_eq', rv)
  endmethod

  method _compareNEQ(rv, x, y)
    this.popTwoArgsAndEmitOpcode('cmp_ne', rv)
  endmethod

  method _compareLT(rv, x, y)
    this.popTwoArgsAndEmitOpcode('cmp_lt', rv)
  endmethod

  method _compareLE(rv, x, y)
    this.popTwoArgsAndEmitOpcode('cmp_le', rv)
  endmethod

  method _compareGT(rv, x, y)
    this.popTwoArgsAndEmitOpcode('cmp_gt', rv)
  endmethod

  method _compareGE(rv, x, y)
    this.popTwoArgsAndEmitOpcode('cmp_ge', rv)
  endmethod

  method _loadVariable(rv, name)
    global SYMBOL_KIND_VAR_RETVAL
    global SYMBOL_KIND_VAR_LOCAL
    global SYMBOL_KIND_VAR_PARAM

    #symbolInfo = this.symbolTable.lookup(name)
    #
    #if symbolInfo.kind is SYMBOL_KIND_VAR_RETVAL
    #  name = '__rv'
    #endif

    # TODO: Avoid move here?
    this.emitMoveVariantOpcode(rv, name)
    this.push(rv)
  endmethod

  method _assign(name, unusedValue)
    global SYMBOL_KIND_VAR_RETVAL
    symbolInfo = this.symbolTable.lookup(name)
    #if symbolInfo.kind is SYMBOL_KIND_VAR_RETVAL
    #  name = '__rv'
    #else
      # TODO: Is it really needed?
      symbolInfo.type = AST_ConvertDataTypeToMIR(symbolInfo.astType)
    #endif

    this.emitMoveVariantOpcode(name, this.popForRead())
  endmethod

  method _call(rv, proto, unusedParams, paramsCnt)
    params = this.popParametersBeforeCall(paramsCnt)
    name   = proto['fullName']

    if name is undefined
      name = proto['name']
    endif

    # TODO: Use emitTwoArgsOpcode() after fix.
    this._emitOneItem(['call', rv, name, params])

    if proto['isConstructor'] is true
      # TODO: Handle it in better way.
      # We need it to avoid eating new result (this pointer)
      # when constructor called just after.
      this.push(params[0])

    else
      this.push(rv)
    endif
  endmethod

  method _callPrint(unusedParams, paramsCnt)
    params = this.popParametersBeforeCall(paramsCnt)
    this.emitTargetOnlyOpcode('print_array_of_variants_ln', params)
    this.push('<print:unused_rv>')
  endmethod

  method _typeof(rv, value)
    this.popOneArgAndEmitOpcode('typeof', rv)
  endmethod

  method _loadFromIndex(rv, unusedBox, unusedIdx)
    this.popTwoArgsAndEmitOpcode('load_index', rv)
  endmethod

  method _storeAtIndex(unusedBox, unusedIdx, unusedValue)
    val = this.popForRead()
    idx = this.popForRead()
    box = this.popForRead()
    this.emitTwoArgsOpcode('store_index', box, idx, val)
    this.push(box)
  endmethod

  method _storeAtIndexAndDrop(unusedBox, unusedIdx, unusedValue)
    val = this.popForRead()
    idx = this.popForRead()
    box = this.popForRead()
    this.emitTwoArgsOpcode('store_index', box, idx, val)
  endmethod

  method _createObject(rv, classProto)
    if classProto is false
      # Dynamic code, adjust class proto at run-time.
      this._error('error: missing classProto in MIR_OPCODE_CREATE_OBJECT')

    else
      # Static code, we got class proto inside MIR opcode.
      this.emitOneArgOpcode('create_object', rv, classProto.name)
      this.push(rv)
    endif
  endmethod

  method _evaluateNodeLazyBoolAnd(rv, leftAst, rightAst)
    endLabel = this.symbolTable.createLabel()
    #   rv = left()
    #   if not rv goto .done
    #   rv = right()
    # .done:

    this._loadImm(rv, false)                                           # [false]
    x = this._evaluateNode(leftAst)                                    # [false x]
    this.emitOneArgOpcode('jmp_if_false', endLabel, this.popForRead()) # [false]

    # TODO: Review it?
    # TODO: Simplify it.
    this.symbolTable.releaseTempVar(x)
    this.symbolTable.assignMirType(rv, 'bool32')

    # Evaluate right node only if left is true.
    y = this._evaluateNode(rightAst) # [y]
    this.emitMoveBackVariant()       # []
    this.emitLabel(endLabel)

    # TODO: Simplify it.
    this.symbolTable.releaseTempVar(y)
  endmethod

  method _evaluateNodeLazyBoolOr(rv, leftAst, rightAst)
    endLabel = this.symbolTable.createLabel()
    #   rv = left()
    #   if rv goto .done
    #   rv = right()
    # .done:

    this._loadImm(rv, true)                                           # [true]
    x = this._evaluateNode(leftAst)                                   # [true x]
    this.emitOneArgOpcode('jmp_if_true', endLabel, this.popForRead()) # [true]

    # TODO: Simplify it.
    this.symbolTable.releaseTempVar(x)
    this.symbolTable.assignMirType(rv, 'bool32')

    # Evaluate right node only if left is false.
    y = this._evaluateNode(rightAst) # [y]
    this.emitMoveBackVariant()       # []
    this.emitLabel(endLabel)

    # TODO: Simplify it.
    this.symbolTable.releaseTempVar(y)
  endmethod

  method _invokeMethod(rv, methodName, unusedParams, paramsCnt)
    # TODO: Remove paramsCnt
    # TODO: Remove codeObj
    methodId = this.code.methodsMap[methodName]

    if methodId is undefined
      # Forward declaration.
      methodId = this.code.createMethod(methodName)
    endif

    if this.mapOfCalledMethods[methodName] is undefined
      this.arrayOfCalledMethods[len(this.arrayOfCalledMethods)] = methodName
    endif

    this.mapOfCalledMethods[methodName] = true

    params = this.popParametersBeforeCall(paramsCnt)

    # TODO: Use emitTwoArgsOpcode() if fixed.
    this._emitOneItem(['vcall', rv, methodId, params])
    this.push(rv)
  endmethod

  method _executeNodeFor(iterName, idxStart, idxEnd, idxStep, bodyAst)
    labelForBegin = this.symbolTable.createLabel()
    labelForEnd   = this.symbolTable.createLabel()

    # Init iterator with start value (inside loop scope).
    this.emitMoveVariantOpcode(iterName, idxStart)

    # idx = valueStart
    # begin:
    #   if not (idx < valueEnd) goto end
    #   ...
    #   add idx, valueStep
    #   jmp begin
    # end:

    this.emitLabel(labelForBegin)

      # Is it the end?
      # if not (idx < idxEnd) goto end
      this.emitTwoArgsOpcode('jmp_if_ge', labelForEnd, iterName, idxEnd)

      # Loop body.
      for values oneChild in bodyAst.children
        this._executeNode(oneChild)
      endfor

      # Update iterator value and jmp to loop begin.
      # idx += step
      # goto begin
      this.emitTwoArgsOpcode('add', iterName, iterName, idxStep)
      this.emitTargetOnlyOpcode('jmp', labelForBegin)

    this.emitLabel(labelForEnd)
  endmethod

  method _executeNodeForEach(iteratorKey, iteratorValue, box, bodyAst)
    labelForBegin = this.symbolTable.createLabel()
    labelForEnd   = this.symbolTable.createLabel()

    this.emitComment('')
    this.emitComment('-----------------------------')
    this.emitComment('BEGIN: for keys ' + str(iteratorKey) + ' values ' + str(iteratorValue))
    this.emitComment('')

    # Avoid direct exeution of loop body.
    # TODO: Handle inner functions in better way.
    this.emitTargetOnlyOpcode('jmp', labelForEnd)

      # Translate loop body as inner function.
      this.emitLabel(labelForBegin)
      this._executeNode(bodyAst)
      this.emitZeroArgsOpcode('inner_ret')

    this.emitLabel(labelForEnd)

    # TODO: Clean up this mess.
    if iteratorKey is -1
      iteratorKey = '__TrashBin'
    endif

    if iteratorValue is -1
      iteratorValue = '__TrashBin'
    endif

    # Emit call to loop handler.
    params = [box, iteratorKey, iteratorValue, labelForBegin]
    # TODO: Use null
    x = []
    rv = x[0]
    this._emitOneItem(['call', rv, '__MOLD_ForDriver_Generic', params])

    this.emitComment('')
    this.emitComment('END: for keys ' + str(iteratorKey) + ' values ' + str(iteratorValue))
    this.emitComment('-----------------------------')
    this.emitComment('')
  endmethod

  method _executeNodeWhile(condAst, bodyAst)
    loopLabel = this.symbolTable.createLabel()
    endLabel  = this.symbolTable.createLabel()

    this.emitLabel(loopLabel)
      # if (not cond) goto end
      this._evaluateNode(condAst)
      this.emitOneArgOpcode('jmp_if_false', endLabel, this.popForRead())

      # Loop body
      this._executeNode(bodyAst)
      this.emitJmp(loopLabel)

    this.emitLabel(endLabel)
  endmethod

  method _executeNodeIf(cond, codeIfTrue, codeIfFalse)
    falseLabel = this.symbolTable.createLabel()
    endLabel   = this.symbolTable.createLabel()

    # if (not cond) goto falseLabel
    #   codeIfTrue
    #   goto endLabel
    #
    # falseLabel:
    #   codeIfFalse
    #
    # endLabel:
    this.emitOneArgOpcode('jmp_if_false', falseLabel, this.popForRead())

    this._executeNode(codeIfTrue)

    if codeIfFalse is defined
      this.emitJmp(endLabel)
      this.emitLabel(falseLabel)
      this._executeNode(codeIfFalse)
    else
      this.emitLabel(falseLabel)
    endif

    this.emitLabel(endLabel)
  endmethod

  method _executeNodeSwitch(node)
    children    = node.children
    childrenCnt = node.childrenCnt
    varName     = this._evaluateNode(children[0])

    doneLabel    = this.symbolTable.createLabel()
    defaultLabel = this.symbolTable.createLabel()
    jmpTable     = []

    symbolInfo = this.symbolTable.insertJmpTable(jmpTable)
    symbolInfo.defaultLabel = defaultLabel

    # Handle out-of-range
    this.emitTwoArgsOpcode('jmp_if_lt', defaultLabel, varName, node.valueMin)
    this.emitTwoArgsOpcode('jmp_if_gt', defaultLabel, varName, node.valueMax)

    # Value is in-range, use jump table.
    this.emitJmpByTable(symbolInfo.name, varName)

    caseDefaultIdx = -1

    # Emit case bodies.
    for idx in 1 .. childrenCnt
      values = children[idx].arrayOfValues

      if values is defined
        if AST_IsEmpty(children[idx]) is true
          # Nop code. Just jump to done label.
          caseLabel = doneLabel

        else
          # There is some work to do.
          caseLabel = this.symbolTable.createLabel()
          this.emitLabel(caseLabel)
          this._executeNode(children[idx])
          this.emitJmp(doneLabel)
        endif

        valuesCnt = len(values)
        for valueIdx in 0 .. valuesCnt
          jmpTable[values[valueIdx]] = caseLabel
        endfor
      else
        caseDefaultIdx = idx
      endif
    endfor

    # Emit otherwise (default) case code if any.
    this.emitLabel(defaultLabel)
    if caseDefaultIdx isnt -1
      this._executeNode(children[caseDefaultIdx])
    endif

    this.emitLabel(doneLabel)
  endmethod

  method _declareFunction(funcName, funcProto)
    # TODO: More elegant way.
    if funcProto.name isnt funcProto.fullName
      this.code.createMethod(funcProto.name)
    endif
  endmethod

  method _declareClass(className, classProto)
    this.code.createClass(classProto)
  endmethod

  method _emitFunctionBody(funcName, funcProto)
    params      = funcProto['params']
    paramsCnt   = funcProto['paramsCnt']
    children    = funcProto['children']
    childrenCnt = funcProto['childrenCnt']
    codeAst     = children[0]
    rvName      = funcProto['rv']

    this.methodEmitted[funcProto.name] = true

    symbolTable = this.symbolTable

    this.emitComment('-----------------------------------------------')
    this.emitComment('function ' + funcName)
    this.emitComment('-----------------------------------------------')

    # TODO: Simplify it.
    oldSymbolTable   = this.symbolTable
    this.symbolTable = codeAst.symbolTable

    # TODO: Simplify it.
    this.emitProcBegin({
      'name': funcName,
      'symbols': this.symbolTable.exportSymbols(),
      'symbolTable': this.symbolTable,
      'params': params,
      'paramsCnt': paramsCnt,
      'rv': rvName
    })

    # Translate function code.
    codeNodes    = codeAst['children']
    codeNodesCnt = codeAst['childrenCnt']

    for idx in 0 .. codeNodesCnt
      this._executeNode(codeNodes[idx])
    endfor

    this.emitRet()
    this.emitProcEnd()

    this.symbolTable = oldSymbolTable
  endmethod

  method _dropRetVal()
    this.stack.eat()
  endmethod

  # ----------------------------------------------------------------------------
  #                                Public API
  # ----------------------------------------------------------------------------

  method run(ast)
    code = this.code

    # TODO: Review it.
    this.symbolTable = ast.symbolTable

    this._emitGlobals()

    # Translate main code behind entry point.
    this.emitComment('-----------------------------------------------')
    this.emitComment('entry point')
    this.emitComment('-----------------------------------------------')

    this._executeNode(ast)

    # TODO: Clean up this mess.
    this.code.symbolTable = this.symbolTable

    for idx in 0 .. len(this.arrayOfCalledMethods)
      methodName = this.arrayOfCalledMethods[idx]
      if this.methodEmitted[methodName] isnt true
        die("error: object has no method '" + methodName + "'")
      endif
    endfor
  endmethod

  method connectTo(obj) -> rv
    this.outputObject = obj
    rv = obj
  endmethod
endclass
