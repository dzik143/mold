################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

import 'AST/AST.mold'
import 'AST/ASTUtils.mold'

class ASTEvaluator
  method constructor(app)
    this.app = app
  endmethod

  method _debug(msg)
    global DEBUG_AST_OPTIMIZER
    if DEBUG_AST_OPTIMIZER is true
      print '[ ASTEvaluator ]', msg
    endif
  endmethod

  method _assignValue(valuesMap, lval, rval)
    name     = lval.value
    oldValue = valuesMap[name]
    newValue = rval

    valuesMap[name]  = newValue
    lval.storedValue = newValue
  endmethod

  method _getValue(valuesMap, name) -> rv
    rv = valuesMap[name]
    while (typeof(rv) is 'undefined') and (typeof(valuesMap.parent) isnt 'undefined')
      valuesMap = valuesMap.parent
      rv        = valuesMap[name]
    endwhile
  endmethod

  method _mergeValues(x, y) -> rv
    rv = []

    # TODO: Optimize it.
    # Merge in first array if any.
    if typeof(x) isnt 'undefined'
      if typeof(x) is 'array'
        for i in 0 .. len(x)
          rv[len(rv)] = x[i]
        endfor
      else
        rv[len(rv)] = x
      endif
    endif

    # Merge in second array if any.
    if typeof(y) isnt 'undefined'
      if typeof(y) is 'array'
        for i in 0 .. len(y)
          rv[len(rv)] = y[i]
        endfor
      else
        rv[len(rv)] = y
      endif
    endif
  endmethod

  method _processConditionalNode(valuesMap, node)
    newValuesMap  = {'__parent': valuesMap}
    alreadyMerged = {}

    this._processNode(newValuesMap, node)

    for keys varId in newValuesMap
      # TODO: Remove this hack:
      if varId isnt '__parent'
        oldValue         = this._getValue(valuesMap, varId)
        newValue         = newValuesMap[varId]
        valuesMap[varId] = this._mergeValues(oldValue, newValue)
      endif
    endfor
  endmethod

  method _processTwoAlternativeNodes(valuesMap, node1, node2)
    newValuesMap1 = {'__parent': valuesMap}
    newValuesMap2 = {'__parent': valuesMap}

    this._processNode(newValuesMap1, node1)
    this._processNode(newValuesMap2, node2)

    for keys varId in newValuesMap1
      # TODO: Remove this hack.
      if varId isnt '__parent'
        oldValue         = this._getValue(valuesMap, varId)
        value1           = newValuesMap1[varId]
        value2           = newValuesMap2[varId]
        valuesMap[varId] = this._mergeValues(value1, value2)
      endif
    endfor

    for keys varId in newValuesMap2
      # TODO: Remove this hack.
      if varId isnt '__parent'
        oldValue         = this._getValue(valuesMap, varId)
        value1           = newValuesMap1[varId]
        value2           = newValuesMap2[varId]
        valuesMap[varId] = this._mergeValues(value1, value2)
      endif
    endfor
  endmethod

  method _getArrayOfValueNodes(node) -> rv
    storedValue = node.storedValue
    rv = []

    if typeof(storedValue) is 'undefined'

    elif typeof(storedValue) is 'array'
      for idx in 0 .. len(storedValue)
        rv[len(rv)] = storedValue[idx].id
      endfor
    else
      rv = [storedValue.id]
    endif
  endmethod

  method _processNode(valuesMap, node)
    global AST_OPCODE_PROGRAM
    global AST_OPCODE_FUNCTION
    global AST_OPCODE_CLASS_METHOD
    global AST_OPCODE_BLOCK
    global AST_OPCODE_VARIABLE
    global AST_OPCODE_IF
    global AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_CALL
    global AST_OPCODE_CALL_NEW
    global AST_OPCODE_FOR_VALUES_RANGE
    global AST_OPCODE_FOR_VALUES
    global AST_OPCODE_WHILE
    global AST_OPCODE_NEG
    global AST_OPCODE_NOP
    global AST_OPCODE_COMPARE_EQ, AST_OPCODE_COMPARE_NEQ
    global AST_OPCODE_COMPARE_LT, AST_OPCODE_COMPARE_LE
    global AST_OPCODE_COMPARE_GT, AST_OPCODE_COMPARE_GE
    global AST_OPCODE_BOOL_NOT
    global AST_OPCODE_ADD, AST_OPCODE_SUB, AST_OPCODE_MUL, AST_OPCODE_DIV, AST_OPCODE_IDIV
    global AST_DATA_BOOL, AST_DATA_INTEGER, AST_DATA_DOUBLE, AST_DATA_STRING
    global AST_DATA_ARRAY, AST_DATA_MAP, AST_DATA_UNDEFINED, AST_DATA_OBJECT
    global AST_OPCODE_BOOL_AND, AST_OPCODE_BOOL_OR
    global AST_OPCODE_REFERENCE
    global AST_OPCODE_CALL, AST_OPCODE_INVOKE_METHOD
    global SYMBOL_KIND_VAR_GLOBAL
    global AST_OPCODE_TYPE_CAST

    # TODO: Use null if ready?
    opcode      = node.opcode
    value       = node.value
    childrenCnt = node.childrenCnt
    children    = node.children

    #
    # Evaluate value.
    #

    if opcode is AST_OPCODE_VARIABLE
      symbolInfo = node.symbolInfo
      if (typeof(symbolInfo) isnt 'undefined') and (symbolInfo.kind is SYMBOL_KIND_VAR_GLOBAL) and (symbolInfo.writeHits > 1)
        # Non-constant global. Treat as unique.
        node.storedValue = node

      else
        node.storedValue = this._getValue(valuesMap, node.value)
        # print "GET VALUE at node #" + str(node.id), node.value, this._getArrayOfValueNodes(node)
      endif

    elif opcode is AST_OPCODE_DECLARE_OR_ASSIGN
      lval = children[0]
      rval = children[1]

      this._processNode(valuesMap, rval)

      if rval.opcode is AST_OPCODE_INVOKE_METHOD
        # x = obj.foo()
        symbolInfo = rval.children[0].symbolInfo

        if typeof(symbolInfo) isnt 'undefined'
          classProto = symbolInfo.classProto

          if typeof(classProto) isnt 'undefined'
            methodProto = classProto.vtable[rval.value]

            if typeof(methodProto) isnt 'undefined'
              if typeof(methodProto.rv) is 'undefined'
                die('error: method "' + classProto.name + '.' + methodProto.name + '" has no return value')
              endif
            endif
          endif
        endif

      elif rval.opcode is AST_OPCODE_INVOKE_METHOD
        # x = obj.foo()
        symbolInfo = rval.children[0].symbolInfo

        if typeof(symbolInfo) isnt 'undefined'
          classProto = symbolInfo.classProto

          if typeof(classProto) isnt 'undefined'
            methodProto = classProto.vtable[rval.value]

            if typeof(methodProto) isnt 'undefined'
              if typeof(methodProto.rv) is 'undefined'
                die('error: method "' + classProto.name + '.' + methodProto.name + '" has no return value')
              endif
            endif
          endif
        endif
      endif

      if lval.opcode is AST_OPCODE_VARIABLE
        this._assignValue(valuesMap, lval, rval)

      elif lval.opcode is AST_OPCODE_REFERENCE
        # TODO: Review it.
        boxOpcode = lval.children[0].opcode

        if (boxOpcode isnt AST_OPCODE_VARIABLE) and (boxOpcode isnt AST_OPCODE_REFERENCE)
          # Error - lval should stores variable name.
          # box[i] = ...
          die('error: array or map expected')
        endif

        this._assignValue(valuesMap, lval, lval)
        this._processNode(valuesMap, lval)
      endif

    elif opcode is AST_OPCODE_IF
      this._processNode(valuesMap, children[0])

      if childrenCnt is 2
        this._processConditionalNode(valuesMap, children[1])
      else
        this._processTwoAlternativeNodes(valuesMap, children[1], children[2])
      endif

    elif opcode is AST_OPCODE_FOR_VALUES_RANGE
      # for idx in valueStart .. valueEnd by step valueStep
      iter           = children[0]
      iterBeginValue = children[1]
      body           = children[4]

      this._assignValue(valuesMap, iter, iter)
      iter.storedValue = [iterBeginValue, iter]

      # First loop rotate.
      this._processConditionalNode(valuesMap, body)

      # N-th loop rotate.
      this._processConditionalNode(valuesMap, body)

    elif opcode is AST_OPCODE_FOR_VALUES
      # for values v in box
      body = children[2]
      # First loop rotate.
      this._processConditionalNode(valuesMap, body)
      # N-th loop rotate.
      this._processConditionalNode(valuesMap, body)

    elif opcode is AST_OPCODE_WHILE
      cond = children[0]
      body = children[1]

      # First loop rotate.
      this._processNode(valuesMap, cond)
      this._processConditionalNode(valuesMap, body)

      # N-th loop rotate.
      this._processConditionalNode(valuesMap, cond)
      this._processConditionalNode(valuesMap, body)

    elif (opcode is AST_OPCODE_CALL) or (opcode is AST_OPCODE_INVOKE_METHOD)
      # foo(a, b, c, ...)
      # obj.foo(a,b, c, ...)
      # Parameter may be changed inside call.
      # TODO: Track real in/out parameters intent.
      for values childNode in children #idx in 0 .. childrenCnt
        if childNode.opcode is AST_OPCODE_VARIABLE
          symbolInfo = childNode.symbolInfo

          # TODO: Review it.
          # global(x) gives undefined symbolInfo.
          if typeof(symbolInfo) isnt 'undefined'
            astType = symbolInfo.astType

            if (typeof(astType) is 'undefined') or (astType is -1) or (astType is AST_DATA_OBJECT) or (astType is AST_DATA_MAP) or (astType is AST_DATA_ARRAY)
              # Unknown or box like variable is passed as call parameter.
              # We assume that it may be changed inside function.
              this._assignValue(valuesMap, childNode, childNode)
            endif
          endif
        endif

        this._processNode(valuesMap, childNode)
      endfor

    else
      if (opcode is AST_OPCODE_FUNCTION) or (opcode is AST_OPCODE_CLASS_METHOD)
        valuesMap = {}
      endif

      # Process children one-by-one recursively.
      for values childNode in children
        this._processNode(valuesMap, childNode)
      endfor
    endif
  endmethod

  method processNode(node)
    valuesMap = {}
    this._processNode(valuesMap, node)
  endmethod
endclass
