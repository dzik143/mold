################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

import 'AST/AST.mold'
import 'AST/ASTUtils.mold'

class ASTEvaluator
  method constructor(app)
    this.app    = app
    this.values = {}
  endmethod

  method _debug(msg)
    global DEBUG_AST_OPTIMIZER
    if DEBUG_AST_OPTIMIZER is true
      print '[ ASTEvaluator ]', msg
    endif
  endmethod

  method _assignValue(values, lval, rval)
    name     = lval.value
    oldValue = values[name]
    newValue = rval

    values[name]     = newValue
    lval.storedValue = newValue

    # TODO: Remove it when map iteration will be ready.
    if typeof(oldValue) is 'undefined'
      values._index[len(values._index)] = name
    endif
  endmethod

  method _getValue(values, name) -> rv
    rv = values[name]
    while (typeof(rv) is 'undefined') and (typeof(values.parent) isnt 'undefined')
      values = values.parent
      rv     = values[name]
    endwhile
  endmethod

  method _mergeValues(x, y) -> rv
    rv = []

    # TODO: Optimize it.
    # Merge in first array if any.
    if typeof(x) isnt 'undefined'
      if typeof(x) is 'array'
        for i in 0 .. len(x)
          rv[len(rv)] = x[i]
        endfor
      else
        rv[len(rv)] = x
      endif
    endif

    # Merge in second array if any.
    if typeof(y) isnt 'undefined'
      if typeof(y) is 'array'
        for i in 0 .. len(y)
          rv[len(rv)] = y[i]
        endfor
      else
        rv[len(rv)] = y
      endif
    endif
  endmethod

  method _processConditionalNode(values, node)
    newValues     = {'_index': [], 'parent': values}
    alreadyMerged = {}

    this._processNode(newValues, node)

    for idx in 0 .. len(newValues._index)
      varId    = newValues._index[idx]
      oldValue = this._getValue(values, varId)
      newValue = newValues[varId]

      if typeof(values[varId]) is 'undefined'
        values._index[len(values._index)] = varId
      endif

      values[varId] = this._mergeValues(oldValue, newValue)
    endfor
  endmethod

  method _processTwoAlternativeNodes(values, node1, node2)
    newValues1 = {'_index': [], 'parent': values}
    newValues2 = {'_index': [], 'parent': values}

    this._processNode(newValues1, node1)
    this._processNode(newValues2, node2)

    for idx in 0 .. len(newValues1._index)
      varId    = newValues1._index[idx]
      oldValue = this._getValue(values, varId)
      value1   = newValues1[varId]
      value2   = newValues2[varId]

      if typeof(values[varId]) is 'undefined'
        values._index[len(values._index)] = varId
      endif

      values[varId] = this._mergeValues(value1, value2)
    endfor

    for idx in 0 .. len(newValues2._index)
      varId    = newValues2._index[idx]
      oldValue = this._getValue(values, varId)
      value1   = newValues1[varId]
      value2   = newValues2[varId]

      if typeof(values[varId]) is 'undefined'
        values._index[len(values._index)] = varId
      endif

      values[varId] = this._mergeValues(value1, value2)
    endfor
  endmethod

  method _getArrayOfValueNodes(node) -> rv
    storedValue = node.storedValue
    rv = []

    if typeof(storedValue) is 'undefined'

    elif typeof(storedValue) is 'array'
      for idx in 0 .. len(storedValue)
        rv[len(rv)] = storedValue[idx].id
      endfor
    else
      rv = [storedValue.id]
    endif
  endmethod

  method _processNode(values, node)
    global AST_OPCODE_PROGRAM
    global AST_OPCODE_FUNCTION
    global AST_OPCODE_CLASS_METHOD
    global AST_OPCODE_BLOCK
    global AST_OPCODE_VARIABLE
    global AST_OPCODE_IF
    global AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_CALL
    global AST_OPCODE_CALL_NEW
    global AST_OPCODE_FOR_VALUES_RANGE
    global AST_OPCODE_WHILE
    global AST_OPCODE_NEG
    global AST_OPCODE_NOP
    global AST_OPCODE_COMPARE_EQ, AST_OPCODE_COMPARE_NEQ
    global AST_OPCODE_COMPARE_LT, AST_OPCODE_COMPARE_LE
    global AST_OPCODE_COMPARE_GT, AST_OPCODE_COMPARE_GE
    global AST_OPCODE_BOOL_NOT
    global AST_OPCODE_ADD, AST_OPCODE_SUB, AST_OPCODE_MUL, AST_OPCODE_DIV, AST_OPCODE_IDIV
    global AST_DATA_BOOL, AST_DATA_INTEGER, AST_DATA_DOUBLE, AST_DATA_STRING
    global AST_DATA_ARRAY, AST_DATA_MAP, AST_DATA_UNDEFINED, AST_DATA_OBJECT
    global AST_OPCODE_BOOL_AND, AST_OPCODE_BOOL_OR
    global AST_OPCODE_REFERENCE
    global AST_OPCODE_CALL, AST_OPCODE_INVOKE_METHOD
    global SYMBOL_KIND_VAR_GLOBAL
    global AST_OPCODE_TYPE_CAST

    # TODO: Use null if ready?
    opcode      = node.opcode
    value       = node.value
    childrenCnt = node.childrenCnt
    children    = node.children

    #
    # Evaluate value.
    #

    if opcode is AST_OPCODE_VARIABLE
      symbolInfo = node.symbolInfo
      if (typeof(symbolInfo) isnt 'undefined') and (symbolInfo.kind is SYMBOL_KIND_VAR_GLOBAL) and (symbolInfo.writeHits > 1)
        # Non-constant global. Treat as unique.
        node.storedValue = node

      else
        node.storedValue = this._getValue(values, node.value)
        # print "GET VALUE at node #" + str(node.id), node.value, this._getArrayOfValueNodes(node)
      endif

    elif opcode is AST_OPCODE_DECLARE_OR_ASSIGN
      lval = children[0]
      rval = children[1]

      this._processNode(values, rval)

      if rval.opcode is AST_OPCODE_INVOKE_METHOD
        # x = obj.foo()
        symbolInfo = rval.children[0].symbolInfo

        if typeof(symbolInfo) isnt 'undefined'
          classProto = symbolInfo.classProto

          if typeof(classProto) isnt 'undefined'
            methodProto = classProto.vtable[rval.value]

            if typeof(methodProto) isnt 'undefined'
              if typeof(methodProto.rv) is 'undefined'
                die('error: method "' + classProto.name + '.' + methodProto.name + '" has no return value')
              endif
            endif
          endif
        endif

      elif rval.opcode is AST_OPCODE_INVOKE_METHOD
        # x = obj.foo()
        symbolInfo = rval.children[0].symbolInfo

        if typeof(symbolInfo) isnt 'undefined'
          classProto = symbolInfo.classProto

          if typeof(classProto) isnt 'undefined'
            methodProto = classProto.vtable[rval.value]

            if typeof(methodProto) isnt 'undefined'
              if typeof(methodProto.rv) is 'undefined'
                die('error: method "' + classProto.name + '.' + methodProto.name + '" has no return value')
              endif
            endif
          endif
        endif
      endif

      if lval.opcode is AST_OPCODE_VARIABLE
        this._assignValue(values, lval, rval)

      elif lval.opcode is AST_OPCODE_REFERENCE
        # TODO: Review it.
        boxOpcode = lval.children[0].opcode

        if (boxOpcode isnt AST_OPCODE_VARIABLE) and (boxOpcode isnt AST_OPCODE_REFERENCE)
          # Error - lval should stores variable name.
          # box[i] = ...
          die('error: array or map expected')
        endif

        this._assignValue(values, lval, lval)
        this._processNode(values, lval)
      endif

    elif opcode is AST_OPCODE_IF
      this._processNode(values, children[0])

      if childrenCnt is 2
        this._processConditionalNode(values, children[1])
      else
        this._processTwoAlternativeNodes(values, children[1], children[2])
      endif

    elif opcode is AST_OPCODE_FOR_VALUES_RANGE
      iter           = children[0]
      iterBeginValue = children[1]
      body           = children[4]

      this._assignValue(values, iter, iter)
      iter.storedValue = [iterBeginValue, iter]

      # First loop rotate.
      this._processConditionalNode(values, body)

      # N-th loop rotate.
      this._processConditionalNode(values, body)

    elif opcode is AST_OPCODE_WHILE
      cond = children[0]
      body = children[1]

      # First loop rotate.
      this._processNode(values, cond)
      this._processConditionalNode(values, body)

      # N-th loop rotate.
      this._processConditionalNode(values, cond)
      this._processConditionalNode(values, body)

    elif (opcode is AST_OPCODE_CALL) or (opcode is AST_OPCODE_INVOKE_METHOD)
      # foo(a, b, c, ...)
      # obj.foo(a,b, c, ...)
      # Parameter may be changed inside call.
      # TODO: Track real in/out parameters intent.
      for idx in 0 .. childrenCnt
        childNode = children[idx]

        if childNode.opcode is AST_OPCODE_VARIABLE
          symbolInfo = childNode.symbolInfo

          # TODO: Review it.
          # global(x) gives undefined symbolInfo.
          if typeof(symbolInfo) isnt 'undefined'
            astType = symbolInfo.astType

            if (typeof(astType) is 'undefined') or (astType is -1) or (astType is AST_DATA_OBJECT) or (astType is AST_DATA_MAP) or (astType is AST_DATA_ARRAY)
              # Unknown or box like variable is passed as call parameter.
              # We assume that it may be changed inside function.
              this._assignValue(values, childNode, childNode)
            endif
          endif
        endif

        this._processNode(values, childNode)
      endfor

    else
      if (opcode is AST_OPCODE_FUNCTION) or (opcode is AST_OPCODE_CLASS_METHOD)
        values = {'_index': []}
      endif

      # Process children one-by-one recursively.
      for idx in 0 .. childrenCnt
        this._processNode(values, children[idx])
      endfor
    endif
  endmethod

  method processNode(node)
    values = {'_index': []}
    this._processNode(values, node)
  endmethod
endclass
