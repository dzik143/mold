################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

import 'AST/AST.mold'

class ASTOptimizer
  method constructor(app)
    this.app         = app
    this.astAnalyzer = app.getAstAnalyzer()
  endmethod

  method _debug(msg)
    print '[ ASTOptimizer ]', msg
  endmethod  
  
  method _setToNop(dst)
    global AST_OPCODE_NOP
    
    this._debug('Set to node #' + str(dst.id) + ' to NOP')
    
    dst.opcode      = AST_OPCODE_NOP
    dst.childrenCnt = 0
    dst.children    = []
  endmethod

  method _setToImm(dst, value)
    global AST_DATA_BOOL, AST_DATA_INTEGER, AST_DATA_DOUBLE, AST_DATA_STRING
    global AST_DATA_ARRAY, AST_DATA_MAP, AST_DATA_UNDEFINED

    type = typeof(value)

    this._debug('Set node #' + str(dst.id) + ' to imm [' + str(value) + '] (' + type + ')')

    if type is 'boolean'
      newOpcode = AST_DATA_BOOL

    elif type is 'integer'
      newOpcode = AST_DATA_INTEGER

    elif type is 'float'
      newOpcode = AST_DATA_DOUBLE

    elif type is 'string'
      newOpcode = AST_DATA_STRING

    elif type is 'array'
      newOpcode = AST_DATA_ARRAY

    elif type is 'map'
      newOpcode = AST_DATA_MAP

    elif type is 'undefined'
      newOpcode = AST_DATA_UNDEFINED

    else
      die('error: unhandled result in constant folding: ' + type)
    endif
    
    dst.childrenCnt = 0
    dst.children    = []
    dst.opcode      = newOpcode
    dst.value       = value
  endmethod
  
  method _copyNode(dst, src)
    this._debug('Replacing node #' + str(dst.id) + ' with #' + str(src.id))
    dst.opcode      = src.opcode
    dst.value       = src.value
    dst.childrenCnt = src.childrenCnt
    dst.children    = src.children
  endmethod
                    
  method _processNodeUntilNotChanged(ctx, node) -> isAnyChangedDone
    isAnyChangedDone = false
    while this._processNode(ctx, node) is true
      # Repeat as long as node changed.
      isAnyChangedDone = true
    endwhile
  endmethod
  
  method _processNode(ctx, node) -> isNodeChanged
    global AST_OPCODE_PROGRAM
    global AST_OPCODE_BLOCK
    global AST_OPCODE_VARIABLE
    global AST_OPCODE_IF
    global AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_CALL
    global AST_OPCODE_NEG
    global AST_OPCODE_NOP
    global AST_OPCODE_COMPARE_EQ, AST_OPCODE_COMPARE_NEQ
    global AST_OPCODE_COMPARE_LT, AST_OPCODE_COMPARE_LE
    global AST_OPCODE_COMPARE_GT, AST_OPCODE_COMPARE_GE
    global AST_OPCODE_ADD, AST_OPCODE_SUB, AST_OPCODE_MUL, AST_OPCODE_DIV, AST_OPCODE_IDIV
    global AST_DATA_BOOL, AST_DATA_INTEGER, AST_DATA_DOUBLE, AST_DATA_STRING
    global AST_DATA_ARRAY, AST_DATA_MAP, AST_DATA_UNDEFINED
    global AST_OPCODE_BOOL_AND, AST_OPCODE_BOOL_OR
    global AST_OPCODE_REFERENCE
    global SYMBOL_KIND_CONST
    
    isNodeChanged = false

    opcode      = node.opcode
    value       = node.value
    children    = node.children
    childrenCnt = node.childrenCnt
    lval        = children[0]
    rval        = children[1]
    x           = lval
    y           = rval

    # Preprocess args first.
    for idx in 0 .. childrenCnt
      # Share one node for variable nodes.
      if (children[idx].opcode is AST_OPCODE_VARIABLE) and (ctx.isset(children[idx].value))

        symbolInfo = ctx.lookup(children[idx].value)

        if symbolInfo.kind is SYMBOL_KIND_CONST
          # Convert var to const.
          
          if node.opcode is AST_OPCODE_DECLARE_OR_ASSIGN
            # Remove unneded assign opcode - it's constant from now.
            this._setToNop(node)
          endif
          
          if (typeof(symbolInfo.value) isnt 'array') and (typeof(symbolInfo.value) isnt 'map')
            # Primitive constant.
#            isNodeChanged = true
            this._setToImm(children[idx], symbolInfo.value)
          else
            # Share one node for the same variable.
            children[idx] = symbolInfo.node
          endif
        endif
            
          # Variable was written only once - use rvalue directly.
          #children[idx] = symbolInfo.value
          

        #  if (node.opcode is AST_OPCODE_DECLARE_OR_ASSIGN)
        #    this._setToNop(node)
            #symbolInfo.readHits  = 0
            #symbolInfo.writeHits = 0
        #  endif          
        #endif

      endif
    endfor

    # Dispatch opcode.    
    if (opcode is AST_OPCODE_BLOCK) and (x.opcode is AST_OPCODE_BLOCK) and (childrenCnt is 1)
      # Unneded block wrapper.
      isNodeChanged = true
      this._copyNode(node, children[0])

    elif opcode is AST_OPCODE_CALL
      # Process all function params.
      for idx in 0 .. childrenCnt
        this._processNodeUntilNotChanged(ctx, children[idx])
      endfor
    
      if value is 'typeof'
        if this.astAnalyzer.isImmNode(x)
          # typeof(imm) gives string
          this._setToImm(node, typeof(x.value))
          isNodeChanged = true
        
        elif x.opcode is AST_OPCODE_VARIABLE
          xInfo = ctx.lookup(x.value)
          if xInfo.kind is SYMBOL_KIND_CONST
            this._setToImm(node, typeof(xInfo.value))
          endif
        endif

      elif value is 'print'
        # Special case: print(x,y,z,...) function.
        newParams  = []
        lastWasImm = false

        for idx in 0 .. childrenCnt
          # Convert imm to strings.
          if (children[idx].opcode >= AST_OPCODE_PROGRAM) or (children[idx].opcode is AST_DATA_ARRAY) or (children[idx].opcode is AST_DATA_MAP)
            # Stay non-imm params as is.
            lastWasImm = false
            newParams[len(newParams)] = children[idx]

          else                        
            # Join string imms.
            if lastWasImm is true
              newParams[len(newParams) - 1].value = newParams[len(newParams) - 1].value + ' ' + str(children[idx].value)
            
            elif children[idx].opcode is AST_DATA_STRING
              newParams[len(newParams)] = children[idx]
            
            else
              this._setToImm(children[idx], str(children[idx].value))
              newParams[len(newParams)] = children[idx]
            endif
            
            lastWasImm = true
          endif
        endfor
        
        node.children    = newParams
        node.childrenCnt = len(newParams)
      endif

    elif opcode is AST_OPCODE_NEG
      if x.opcode is AST_OPCODE_NEG
        # TODO: Control types: -(-[]))
        # -(-x)) gives x
        this._copyNode(node, x.children[0])
        isNodeChanged = true

      elif x.opcode < AST_OPCODE_PROGRAM
        # -imm: calculate at compile at time.
        this._setToImm(node, -x.value)
        isNodeChanged = true
        
      else
        # Complex argument - go on deeper.
        isNodeChanged = this._processNodeUntilNotChanged(ctx, x)
      endif

    elif opcode is AST_OPCODE_REFERENCE
      this._processNodeUntilNotChanged(ctx, x)
      this._processNodeUntilNotChanged(ctx, y)
      
      xInfo = ctx.lookup(x.value)
      
      if xInfo.kind is SYMBOL_KIND_CONST
        # imm[y]
        this._setToImm(node, xInfo.value[y.value])
      endif
    
    elif (childrenCnt is 2) and this.astAnalyzer.isImmNode(x) and this.astAnalyzer.isImmNode(y)
      
      # Constant folding: x op y
      isNodeChanged = true

      if opcode is AST_OPCODE_ADD
        newValue  = x.value + y.value

      elif opcode is AST_OPCODE_SUB
        newValue  = x.value - y.value

      elif opcode is AST_OPCODE_MUL
        newValue  = x.value * y.value

      elif opcode is AST_OPCODE_DIV
        newValue  = x.value / y.value

      elif opcode is AST_OPCODE_IDIV
        newValue  = x.value // y.value

      elif opcode is AST_OPCODE_COMPARE_EQ
        newValue = x.value is y.value

      elif opcode is AST_OPCODE_COMPARE_NEQ
        newValue = x.value isnt y.value

      elif opcode is AST_OPCODE_COMPARE_LT
        if x.value < y.value
          newValue = true
        else
          newValue = false
        endif

      elif opcode is AST_OPCODE_COMPARE_LE
        if x.value <= y.value
          newValue = true
        else
          newValue = false
        endif

      elif opcode is AST_OPCODE_COMPARE_GT
        if x.value > y.value
          newValue = true
        else
          newValue = false
        endif

      elif opcode is AST_OPCODE_COMPARE_GE
        if x.value >= y.value
          newValue = true
        else
          newValue = false
        endif

      elif opcode is AST_OPCODE_BOOL_AND
        if (x.value is true) and (y.value is true)
          newValue = true
        else
          newValue = false
        endif

      elif opcode is AST_OPCODE_BOOL_OR
        if (x.value is true) or (y.value is true)
          newValue = true
        else
          newValue = false
        endif
        
      elif opcode is AST_OPCODE_REFERENCE
        # x[y]
        newValue = x.value[y.value]
      
      else
        die('error: unhandled opcode in x op y optimization: ' + str(opcode))
      endif

      this._setToImm(node, newValue)
      
    elif opcode is AST_OPCODE_IF
      condNode        = children[0]
      codeIfTrueNode  = children[1]
      codeIfFalseNode = children[2]

      this._processNodeUntilNotChanged(ctx, condNode)

      if condNode.opcode is AST_DATA_BOOL
        if condNode.value is true
          this._copyNode(node, codeIfTrueNode)
          isNodeChanged = true

        elif typeof(codeIfFalseNode) isnt 'undefined'
          this._copyNode(node, codeIfFalseNode)
          isNodeChanged = true

        endif
      endif

    else

      if opcode is AST_OPCODE_BLOCK
        ctx = this.astAnalyzer.getNodeSymbols(node)
      endif

      for idx in 0 .. childrenCnt
        if this._processNodeUntilNotChanged(ctx, children[idx]) is true
          isNodeChanged = true
        endif
      endfor
    endif
  endmethod
  
  method process(node)
    this._processNode(false, node)
  endmethod
endclass
