################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

import 'AST/AST.mold'
import 'AST/ASTUtils.mold'

class ASTAnalyzer

  method constructor(app)
    this.app               = app
    this.astEvaluator      = app.getAstEvaluator()
    this.astConstantFolder = app.getAstConstantFolder()
  endmethod
  
  # ----------------------------------------------------------------------------
  #                          Internal API (private)
  # ----------------------------------------------------------------------------

  method _collectSymbolsFromLeftNode(symbolTable, node)
    this._collectSymbols(symbolTable, node, true)
  endmethod

  method _collectSymbolsFromRightNode(symbolTable, node)
    this._collectSymbols(symbolTable, node, false)
  endmethod
  
  method _collectSymbols(symbolTable, node, isLeftNode)
    global AST_OPCODE_PROGRAM
    global AST_OPCODE_BLOCK
    global AST_OPCODE_VARIABLE
    global AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_CALL
    global AST_OPCODE_IF
    global AST_OPCODE_WHILE
    global AST_OPCODE_FOR_VALUES_RANGE
    global AST_OPCODE_INVOKE_METHOD
    global AST_OPCODE_REFERENCE

    #this.astConstantFolder.processNodeUntilNotChanged(node)
    
    opcode      = node.opcode
    children    = node.children
    childrenCnt = node.childrenCnt
    
    if opcode is AST_OPCODE_PROGRAM
      symbolTable      = this.app.getSymbolTable()
      node.symbolTable = symbolTable

      for idx in 0 .. childrenCnt
        this._collectSymbolsFromLeftNode(node.symbolTable, children[idx])
      endfor      
    
    elif opcode is AST_OPCODE_BLOCK
      if typeof(node.symbolTable) is 'undefined'
        # Init new symbol table if not existing yet.
        node.symbolTable = symbolTable.enterScope()
      endif
      
      for idx in 0 .. childrenCnt
        this._collectSymbolsFromLeftNode(node.symbolTable, children[idx])
      endfor
      node.symbolTable.leaveScope()

    
    elif opcode is AST_OPCODE_VARIABLE
      if isLeftNode is true
        # x = ...
        symbolTable.lookupForWrite(node.value)
      else
        # ... = x
        symbolTable.lookupForRead(node.value)
      endif

    elif opcode is AST_OPCODE_REFERENCE
       # Thera are two cases:
       # 1. x[i] = ...  : x is left , i is right
       # 2. ...  = x[i] : x is right, i is right
       # Rule:
       # - x always save L/R context,
       # - i has always R context (lookup for read).
      
       this._collectSymbols(symbolTable, children[0], isLeftNode)
       this._collectSymbolsFromRightNode(symbolTable, children[1])

    elif opcode is AST_OPCODE_DECLARE_OR_ASSIGN
      # lval = rval
      lval = children[0]
      rval = children[1]
      
      if lval.opcode is AST_OPCODE_VARIABLE
        # Simple lval (single variable) - insert into symbol table.
        symbolInfo = symbolTable.lookupForWriteOrInsert(lval.value)
        readHits   = symbolInfo.readHits
      
        # Save value node for constant propagation.
        symbolTable.assignNode(lval.value, lval)
        
        if AST_IsImm(rval)
          symbolTable.assignValue(lval.value, rval.value)
        endif
        
        # Scan rval.
        this._collectSymbolsFromRightNode(symbolTable, rval)
        
        # Restore read stats for lval variable to avoid false x = x + 1 usage.
        # It's not useful read.
        symbolInfo.readHits = readHits

      else
        # Complex lval - go on deeper.
        this._collectSymbolsFromLeftNode(symbolTable, lval)
        this._collectSymbolsFromRightNode(symbolTable, rval)
      endif
      
    elif opcode is AST_OPCODE_IF
      # if cond then x else y
      # cond is rval,
      # x,y are lval.
      
      # Scan condition (rval)
      this._collectSymbolsFromRightNode(symbolTable, children[0])

      # Scan condition (lval)
      this._collectSymbolsFromLeftNode(symbolTable, children[1])

      if childrenCnt is 3
        # Optional else block (lval).
        this._collectSymbolsFromLeftNode(symbolTable, children[2])
        
        # Merge symbols defined in both nodes. We know it's always set.
        # if cond
        #   x = 1
        # else
        #   x = 2
        # endif
        
        symbolTable1 = children[1].symbolTable
        symbolTable2 = children[2].symbolTable
        
        symbols1 = symbolTable1.exportSymbols()
        symbols2 = symbolTable2.exportSymbols()

        symbolsIndex1 = symbols1._index
        symbolsIndex2 = symbols2._index

        for idx in 0 .. len(symbolsIndex1)
          symbolInfo1 = symbolsIndex1[idx]
          symbolInfo2 = symbols2[symbolInfo1.name]
          
          if typeof(symbolInfo2) isnt 'undefined'
            # Symbol defined in both nodes - move into parent node.
            # TODO: Use max(x, y) if ready.
            if symbolInfo1.readHits > symbolInfo2.readHits
              readHits = symbolInfo1.readHits
            else
              readHits = symbolInfo2.readHits
            endif

            if symbolInfo1.writeHits > symbolInfo2.writeHits
              writeHits = symbolInfo1.writeHits
            else
              writeHits = symbolInfo2.writeHits
            endif
                                           
            symbolTable.insert(symbolInfo1.name, symbolInfo1)

            symbolInfo1.readHits  = readHits
            symbolInfo1.writeHits = writeHits
            
            # And remove from child true/false node.
            symbolTable1.remove(symbolInfo1.name)
            symbolTable2.remove(symbolInfo1.name)
          endif
        endfor
      endif
      
    elif opcode is AST_OPCODE_FOR_VALUES_RANGE
      # for idx in idxStart .. idxEnd by step
      iterNode     = children[0]
      idxStartNode = children[1]
      idxEndNode   = children[2]
      idxStepNode  = children[3]
      bodyNode     = children[4]
      
      bodyNode.symbolTable = symbolTable.enterScopeForLoop()
      bodyNode.symbolTable.insertLocal(iterNode.value)
      
      #this._collectSymbolsFromLeftNode(symbolTable, iterNode)
      this._collectSymbolsFromRightNode(symbolTable, idxStartNode)
      this._collectSymbolsFromRightNode(symbolTable, idxEndNode)
      this._collectSymbolsFromRightNode(symbolTable, idxStepNode)
      this._collectSymbolsFromLeftNode(symbolTable, bodyNode)

    elif opcode is AST_OPCODE_WHILE           
      # while (cond) body
      condNode = children[0]
      bodyNode = children[1]
      
      bodyNode.symbolTable = symbolTable.enterScopeForLoop()
      
      this._collectSymbolsFromRightNode(symbolTable, condNode)
      this._collectSymbolsFromLeftNode(symbolTable, bodyNode)
    
    else
      if (opcode is AST_OPCODE_CALL) or (opcode is AST_OPCODE_INVOKE_METHOD)
        isLeftNode = false
      endif
      
      for idx in 0 .. childrenCnt
        this._collectSymbols(symbolTable, children[idx], isLeftNode)
      endfor
    endif   
  endmethod
  
  method _buildSymbolTable(node) -> rv
    # Create new empty symbol table and save it for furher use.
    rv = this.app.getSymbolTable().enterScope()
    node.symbolTable = rv
    
    # Fill up table with symbols used within node.
    children    = node.children
    childrenCnt = node.childrenCnt
    
    for idx in 0 .. childrenCnt
      this._collectSymbolsFromLeftNode(rv, children[idx])
    endfor
    
    # TODO: Review it.
    rv.vacuum()
  endmethod
  
  # ----------------------------------------------------------------------------
  #                                Public API
  # ----------------------------------------------------------------------------

  method getNodeSymbols(node) -> rv
    global AST_OPCODE_BLOCK
    
    # Only code blocks should store symbol table.
    if node.opcode isnt AST_OPCODE_BLOCK
      die('error: only block nodes can own symbol table')
    endif
    
    # Is symbol table already built for this node?
    rv = node.symbolTable
    
    if typeof(rv) is 'undefined'
      # There is no symbol table for this node yet - build it now and save
      # inside node data for further use.
      rv = this._buildSymbolTable(node)
    endif
  endmethod
  
  method processNode(node)
    this._buildSymbolTable(node)
  endmethod
endclass
