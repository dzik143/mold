################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'AST/AST.mold'
import 'AST/ASTUtils.mold'

MOLD_SYSCALL_ZERO_ARGS = 0x0000
MOLD_SYSCALL_ONE_ARG   = 0x1000
MOLD_SYSCALL_TWO_ARGS  = 0x2000

MOLD_SYSCALL_MAP = {
  'FileOpenForRead':   MOLD_SYSCALL_ONE_ARG + 1,
  'FileOpenForWrite':  MOLD_SYSCALL_ONE_ARG + 2,
  'FileOpenForCreate': MOLD_SYSCALL_ONE_ARG + 3,
  'FileClose':         MOLD_SYSCALL_ONE_ARG + 4,

  'FileReadInt8':    MOLD_SYSCALL_ONE_ARG + 8,
  'FileReadInt16':   MOLD_SYSCALL_ONE_ARG + 9,
  'FileReadInt32':   MOLD_SYSCALL_ONE_ARG + 10,
  'FileReadInt64':   MOLD_SYSCALL_ONE_ARG + 11,
  'FileReadFloat32': MOLD_SYSCALL_ONE_ARG + 14,
  'FileReadFloat64': MOLD_SYSCALL_ONE_ARG + 15,
  'FileReadBool8':   MOLD_SYSCALL_ONE_ARG + 16,
  'FileReadBool16':  MOLD_SYSCALL_ONE_ARG + 17,
  'FileReadBool32':  MOLD_SYSCALL_ONE_ARG + 18,
  'FileReadBool64':  MOLD_SYSCALL_ONE_ARG + 19,
  'FileReadChar':    MOLD_SYSCALL_ONE_ARG + 20,

  'FileWriteInt8':    MOLD_SYSCALL_TWO_ARGS + 21,
  'FileWriteChar':    MOLD_SYSCALL_TWO_ARGS + 21,
  'FileWriteInt16':   MOLD_SYSCALL_TWO_ARGS + 22,
  'FileWriteInt32':   MOLD_SYSCALL_TWO_ARGS + 23,
  'FileWriteInt64':   MOLD_SYSCALL_TWO_ARGS + 24,
  'FileWriteFloat64': MOLD_SYSCALL_TWO_ARGS + 24,

  'FileLoad': MOLD_SYSCALL_ONE_ARG + 29,

  'ord':          MOLD_SYSCALL_ONE_ARG + 31,
  'asc':          MOLD_SYSCALL_ONE_ARG + 32,
  'ParseInteger': MOLD_SYSCALL_ONE_ARG + 33,
  'ParseFloat':   MOLD_SYSCALL_ONE_ARG + 34,

  'bitand': MOLD_SYSCALL_TWO_ARGS + 35,
  'bitor':  MOLD_SYSCALL_TWO_ARGS + 36,
  'bitxor': MOLD_SYSCALL_TWO_ARGS + 37,
  'bitnot': MOLD_SYSCALL_ONE_ARG  + 38,

  'exit':   MOLD_SYSCALL_ZERO_ARGS + 40,
  'die':    MOLD_SYSCALL_ONE_ARG + 41,
  'str':    MOLD_SYSCALL_ONE_ARG + 42,
  'len':    MOLD_SYSCALL_ONE_ARG + 43,
  'typeof': MOLD_SYSCALL_ONE_ARG + 44,

  '__mold_printToStdOutput': MOLD_SYSCALL_ONE_ARG + 45,
  '__mold_warning': MOLD_SYSCALL_ONE_ARG + 46
}

class ASTPreprocessor
  method constructor(app)
    this.app = app
  endmethod

  method _debug(msg)
    global DEBUG_AST_OPTIMIZER
    if DEBUG_AST_OPTIMIZER is true
      print '[ ASTPreprocessor ]', msg
    endif
  endmethod

  method _processNode(node)
    global AST_OPCODE_VARIABLE
    global AST_OPCODE_CALL
    global AST_DATA_STRING
    global AST_OPCODE_COMPARE_EQ, AST_OPCODE_COMPARE_NEQ
    global MOLD_SYSCALL_MAP

    opcode   = node.opcode
    children = node.children

    # Process children recursively.
    for values oneChild in children
      this._processNode(oneChild)
    endfor

    # Process current node.
    if opcode is AST_OPCODE_COMPARE_EQ
      # TODO: Review it.
      # x is y
      x = children[0]
      y = children[1]

      if y.opcode is AST_OPCODE_VARIABLE
        # Expand special built-in conditions:
        # - x is defined,
        # - x is odd,
        # - etc.
        name = y.value

        if name is 'defined'
          # x is defined => x isnt undefined
          name = 'undefined'
          node.opcode = AST_OPCODE_COMPARE_NEQ
        endif

        if (name is 'undefined')
          # TODO: Optimize it.
          children[0] = {
            'id': AST_GetNextId(),
            'opcode': AST_OPCODE_CALL,
            'value': '__mold_syscall',
            'sysCallId': 44, # TODO: Don't use hardcoded value ('typeof')
            'children': [x],
            'childrenCnt': 1
          }
          y.opcode = AST_DATA_STRING
          y.value  = 'undefined'
        endif
      endif

    elif opcode is AST_OPCODE_CALL
      funcName  = node.value
      sysCallId = MOLD_SYSCALL_MAP[funcName]

      if sysCallId is defined
        # One of built-in functions.
        # Verify number of passed parameters.
        paramsExpectedCnt = sysCallId // 0x1000
        paramsPassedCnt   = node.childrenCnt
        if paramsExpectedCnt isnt paramsPassedCnt
          # TODO: Clean up this mess.
          # TODO: Better way to pass current line/column to error
          # handler.
          this.app.setLogContext(node)
          this.app.logError('built-in ' + funcName + ' function requires exactly ' + str(paramsExpectedCnt) + ' parameter(s), but ' + str(paramsPassedCnt) + ' were passed')
        endif

        # Map to related syscall routine.
        node.value      = '__mold_syscall'
        node.sysCallId  = bitand(sysCallId, 0xff)

      elif funcName is '__mold_syscall'
        # TODO: Clean up this mess.
        # Treat first parameter as hard-coded integer syscall id.
        node.sysCallId = children[0].value
        newChildren    = []
        childrenCnt    = node.childrenCnt

        for idx in 1 .. childrenCnt
          newChildren[idx - 1] = children[idx]
        endfor

        node.children    = newChildren
        node.childrenCnt = childrenCnt - 1
      endif
    endif
  endmethod

  method processNode(node)
    this._processNode(node)
  endmethod
endclass
