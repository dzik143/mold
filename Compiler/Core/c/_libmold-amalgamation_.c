// File generated by 01-build-amalgamation.js from original *.c and *.h files.
// DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!

// Generated on: 2025-07-12T17:31:28.952Z

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldCore.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldCore_H
#define _MoldCore_H

#include <stdint.h>
#include <stdlib.h>

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldMemory.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldMemory_H
#define _MoldMemory_H

#include <stdlib.h>
#include <stdint.h>

// -----------------------------------------------------------------------------
//                              Type definitions
// -----------------------------------------------------------------------------

typedef struct Buffer
{
  uint64_t capacity;
   int64_t refCnt;
  uint64_t flags;
  void* bytesPtr;
} Buffer_t;

// -----------------------------------------------------------------------------
//                                 Functions
// -----------------------------------------------------------------------------

Buffer_t *__MOLD_MemoryAlloc(uint32_t sizeInBytes);

void __MOLD_MemoryAddRef(Buffer_t *buf);
void __MOLD_MemoryRelease(Buffer_t *buf);
void __MOLD_MemoryRealloc(Buffer_t *buf, uint64_t newCapacity);
void __MOLD_MemoryIncreaseBufferTwice(Buffer_t *buf);
void __MOLD_MemoryDieIfMemoryLeak();

#endif /* _MoldMemory_H */


// -----------------------------------------------------------------------------
//                              Type definitions
// -----------------------------------------------------------------------------

typedef int32_t bool32_t;
typedef float   float32_t;
typedef double  float64_t;

typedef struct Variant
{
  uint32_t type;
  uint32_t flags;
  union
  {
    uint64_t  value;
    uint8_t   valueAsUInt8;
    int8_t    valueAsInt8;
    int32_t   valueAsInt32;
    int64_t   valueAsInt64;
    float32_t valueAsFloat32;
    float64_t valueAsFloat64;
    char      valueAsChar;
    struct Buffer *valueAsBufferPtr;
  };
} Variant_t;

// -----------------------------------------------------------------------------
//                                 Constants
// -----------------------------------------------------------------------------

#define true  1
#define false 0

// Special cases - undefined and null.
#define VARIANT_UNDEFINED 0
#define VARIANT_NULL      1

// Primitives.
#define VARIANT_INTEGER   2
#define VARIANT_FLOAT     3
#define VARIANT_DOUBLE    4
#define VARIANT_STRING    5
#define VARIANT_BOOLEAN   6

// Complex containers.
#define VARIANT_ARRAY     7
#define VARIANT_MAP       8
#define VARIANT_OBJECT    9
#define VARIANT_TYPE_MAX  9

#define VARIANT_FLAG_DUPLICATE_ON_FIRST_WRITE 1
#define VARIANT_FLAG_ONE_CHARACTER            2
// Used to avoid circular references during print.
#define VARIANT_FLAG_NODE_VISITED             4

// Size in Variant_t objects.
#define MOLD_DEFAULT_STACK_SIZE (1024 * 64)
#define MOLD_DEFAULT_STACK_SIZE (1024 * 64)

// -----------------------------------------------------------------------------
//                             Global variables
// -----------------------------------------------------------------------------

extern Variant_t argc;
extern Variant_t argv;
extern Variant_t __TrashBin;
extern Variant_t *__MOLD_StackPtr;

// -----------------------------------------------------------------------------
//                Convert: create variant from primitives
// -----------------------------------------------------------------------------

Variant_t __MOLD_VariantCreateFrom_int32(int32_t x);
Variant_t __MOLD_VariantCreateFrom_int64(int64_t x);
Variant_t __MOLD_VariantCreateFrom_bool32(bool32_t x);
Variant_t __MOLD_VariantCreateFrom_float32(float32_t x);
Variant_t __MOLD_VariantCreateFrom_float64(float64_t x);

// -----------------------------------------------------------------------------
//                    Assign: apply new value
// -----------------------------------------------------------------------------

void __MOLD_VariantAssign_int32(Variant_t *rv, int32_t x);
void __MOLD_VariantAssign_int64(Variant_t *rv, int64_t x);
void __MOLD_VariantAssign_bool32(Variant_t *rv, bool32_t x);
void __MOLD_VariantAssign_float32(Variant_t *rv, float32_t x);
void __MOLD_VariantAssign_float64(Variant_t *rv, float64_t x);

// -----------------------------------------------------------------------------
//                     Arithmetic: in32 vs int32
// -----------------------------------------------------------------------------

int32_t   __MOLD_neg_int32 (int32_t x);
int32_t   __MOLD_add_int32 (int32_t x, int32_t y);
int32_t   __MOLD_sub_int32 (int32_t x, int32_t y);
int32_t   __MOLD_mul_int32 (int32_t x, int32_t y);
int32_t   __MOLD_imul_int32(int32_t x, int32_t y);
float64_t __MOLD_div_int32 (int32_t x, int32_t y);
int32_t   __MOLD_idiv_int32(int32_t x, int32_t y);

// -----------------------------------------------------------------------------
//                     Arithmetic: int64 vs int64
// -----------------------------------------------------------------------------

int64_t   __MOLD_neg_int64 (int64_t x);
int64_t   __MOLD_add_int64 (int64_t x, int64_t y);
int64_t   __MOLD_sub_int64 (int64_t x, int64_t y);
int64_t   __MOLD_mul_int64 (int64_t x, int64_t y);
int64_t   __MOLD_imul_int64(int64_t x, int64_t y);
float64_t __MOLD_div_int64 (int64_t x, int64_t y);
int64_t   __MOLD_idiv_int64(int64_t x, int64_t y);

// -----------------------------------------------------------------------------
//                     Arithmetic: float64 vs float64
// -----------------------------------------------------------------------------

float64_t __MOLD_neg_float64 (float64_t x);
float64_t __MOLD_add_float64 (float64_t x, float64_t y);
float64_t __MOLD_sub_float64 (float64_t x, float64_t y);
float64_t __MOLD_mul_float64 (float64_t x, float64_t y);
float64_t __MOLD_imul_float64(float64_t x, float64_t y);
float64_t __MOLD_div_float64 (float64_t x, float64_t y);
int64_t   __MOLD_idiv_float64(float64_t x, float64_t y);

// -----------------------------------------------------------------------------
//                    Arithmetic: variant vs variant
// -----------------------------------------------------------------------------

Variant_t __MOLD_neg_variant (const Variant_t *x);
Variant_t __MOLD_add_variant (const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_sub_variant (const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_mul_variant (const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_imul_variant(const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_div_variant (const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_idiv_variant(const Variant_t *x, const Variant_t *y);

void __MOLD_negAndAssign_variant (Variant_t *rv, const Variant_t *x);
void __MOLD_addAndAssign_variant (Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_subAndAssign_variant (Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_mulAndAssign_variant (Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_imulAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_divAndAssign_variant (Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_idivAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y);

// -----------------------------------------------------------------------------
//                         Compare: int32 vs int32
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_int32(int32_t x, int32_t y);
bool32_t __MOLD_cmp_ne_int32(int32_t x, int32_t y);
bool32_t __MOLD_cmp_lt_int32(int32_t x, int32_t y);
bool32_t __MOLD_cmp_gt_int32(int32_t x, int32_t y);
bool32_t __MOLD_cmp_le_int32(int32_t x, int32_t y);
bool32_t __MOLD_cmp_ge_int32(int32_t x, int32_t y);

// -----------------------------------------------------------------------------
//                         Compare: int64 vs int64
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_int64(int64_t x, int64_t y);
bool32_t __MOLD_cmp_ne_int64(int64_t x, int64_t y);
bool32_t __MOLD_cmp_lt_int64(int64_t x, int64_t y);
bool32_t __MOLD_cmp_gt_int64(int64_t x, int64_t y);
bool32_t __MOLD_cmp_le_int64(int64_t x, int64_t y);
bool32_t __MOLD_cmp_ge_int64(int64_t x, int64_t y);

// -----------------------------------------------------------------------------
//                       Compare: float64 vs float64
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_float64(float64_t x, float64_t y);
bool32_t __MOLD_cmp_ne_float64(float64_t x, float64_t y);
bool32_t __MOLD_cmp_lt_float64(float64_t x, float64_t y);
bool32_t __MOLD_cmp_gt_float64(float64_t x, float64_t y);
bool32_t __MOLD_cmp_le_float64(float64_t x, float64_t y);
bool32_t __MOLD_cmp_ge_float64(float64_t x, float64_t y);

// -----------------------------------------------------------------------------
//                        Compare: bool32 vs bool32
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_bool32(bool32_t x, bool32_t y);
bool32_t __MOLD_cmp_ne_bool32(bool32_t x, bool32_t y);

// -----------------------------------------------------------------------------
//                       Compare: variant vs variant
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_variant(const Variant_t *x, const Variant_t *y);
bool32_t __MOLD_cmp_ne_variant(const Variant_t *x, const Variant_t *y);
bool32_t __MOLD_cmp_lt_variant(const Variant_t *x, const Variant_t *y);
bool32_t __MOLD_cmp_gt_variant(const Variant_t *x, const Variant_t *y);
bool32_t __MOLD_cmp_le_variant(const Variant_t *x, const Variant_t *y);
bool32_t __MOLD_cmp_ge_variant(const Variant_t *x, const Variant_t *y);

// -----------------------------------------------------------------------------
//                       Cast variant into primitives
// -----------------------------------------------------------------------------

int32_t   __MOLD_VariantCastTo_int32  (Variant_t *x);
int64_t   __MOLD_VariantCastTo_int64  (Variant_t *x);
float32_t __MOLD_VariantCastTo_float32(Variant_t *x);
float64_t __MOLD_VariantCastTo_float64(Variant_t *x);
bool32_t  __MOLD_VariantCastTo_bool32 (Variant_t *x);

// -----------------------------------------------------------------------------
//                       Bitwise: variant vs variant
// -----------------------------------------------------------------------------

Variant_t __MOLD_Bitand(const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_Bitor (const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_Bitxor(const Variant_t *x, const Variant_t *y);
Variant_t __MOLD_Bitnot(const Variant_t *x);

void __MOLD_BitandAndAssign(Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_BitorAndAssign (Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_BitxorAndAssign(Variant_t *rv, const Variant_t *x, const Variant_t *y);
void __MOLD_BitnotAndAssign(Variant_t *rv, const Variant_t *x);

// -----------------------------------------------------------------------------
//                                    Utils
// -----------------------------------------------------------------------------

void __MOLD_Exit();

void __MOLD_SysCall(uint32_t id, Variant_t *rv, ...);

uint64_t  __MOLD_Len(const Variant_t *x);
Variant_t __MOLD_ParseInteger(const Variant_t *x);
float64_t __MOLD_ParseFloat(const Variant_t *x);
Variant_t __MOLD_Typeof(const Variant_t *x);
Variant_t __MOLD_FileLoad(const Variant_t *path);

void __MOLD_ParseIntegerAndAssign(Variant_t *rv, const Variant_t *x);
void __MOLD_TypeofAndAssign(Variant_t *rv, const Variant_t *x);
void __MOLD_FileLoadAndAssign(Variant_t *rv, const Variant_t *path);

void __MOLD_VariantAddRef(const Variant_t *x);
void __MOLD_VariantDestroy(Variant_t *x);
void __MOLD_VariantDestroyMany(Variant_t *x, uint32_t n);

void __MOLD_InitArgv(int _argc, char **_argv);

Variant_t __MOLD_GetTypeId(const Variant_t *x);

void  __MOLD_GetTypeIdAndAssign(Variant_t *rv, const Variant_t *x);

void __MOLD_VariantMove(Variant_t *dst, Variant_t *src);

void __MOLD_StackFree(uint32_t n);
void __MOLD_StackAlloc(uint32_t n);

#endif /* _MoldCore_H */

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldError.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldError_H
#define _MoldError_H

#include <assert.h>

void __MOLD_Die(const Variant_t *msg);
void __MOLD_PrintErrorAndDie(const char *msg);
void __MOLD_InitExceptions();

void __MOLD_PrintErrorAndDie_generic();
void __MOLD_PrintErrorAndDie_integerExpected();
void __MOLD_PrintErrorAndDie_integerIndexExpected();
void __MOLD_PrintErrorAndDie_booleanExpected();
void __MOLD_PrintErrorAndDie_floatExpected();
void __MOLD_PrintErrorAndDie_stringKeyExpected();
void __MOLD_PrintErrorAndDie_stringExpected();
void __MOLD_PrintErrorAndDie_mapOrObjectExpected();
void __MOLD_PrintErrorAndDie_objectExpected();
void __MOLD_PrintErrorAndDie_arrayExpected();
void __MOLD_PrintErrorAndDie_arrayOrStringExpected();
void __MOLD_PrintErrorAndDie_arrayStringOrMapExpected();
void __MOLD_PrintErrorAndDie_negativeIndex();
void __MOLD_PrintErrorAndDie_indexOutOfRange();
void __MOLD_PrintErrorAndDie_outOfMemory();
void __MOLD_PrintErrorAndDie_badType();
void __MOLD_PrintErrorAndDie_notImplemented();
void __MOLD_PrintErrorAndDie_implicitConversion();
void __MOLD_PrintErrorAndDie_notComparable();
void __MOLD_PrintErrorAndDie_divideByZero();
void __MOLD_PrintErrorAndDie_floatOverflow();
void __MOLD_PrintErrorAndDie_floatUnderflow();
void __MOLD_PrintErrorAndDie_notIterable();
void __MOLD_PrintErrorAndDie_nullMethodCalled();
void __MOLD_PrintErrorAndDie_vcallOnNonObject();

#define ASSERT_VARIANT_ENABLED

#ifdef ASSERT_VARIANT_ENABLED

# define ASSERT_VARIANT_PTR_ANY(x) \
  assert((x) != NULL); \
  assert((x) -> type >= 0); \
  assert((x) -> type <= VARIANT_TYPE_MAX); \
  assert((x) -> flags != 0xdeadbeef); \
  assert((x) -> flags >> 3 == 0); \
  assert((x) -> valueAsInt64 != 0xdeadbeef); \
  assert((x) -> valueAsInt64 != 0xfeeefeeefeeefeee);

# define ASSERT_VARIANT_PTR_INTEGER(x) \
  ASSERT_VARIANT_PTR_ANY(x) \
  assert((x) -> type == VARIANT_INTEGER);

# define ASSERT_VARIANT_PTR_COMPLEX(x) \
  ASSERT_VARIANT_PTR_ANY(x) \
  assert(((x) -> type == VARIANT_STRING) || ((x) -> type >= VARIANT_ARRAY)); \
  assert((x) -> valueAsBufferPtr != NULL); \
  assert((x) -> valueAsBufferPtr -> refCnt != 0); \
  assert((x) -> valueAsBufferPtr -> bytesPtr != NULL); \
  assert((int64_t)((x) -> valueAsBufferPtr -> bytesPtr) != 0xdeadbeef); \
  assert((int64_t)((x) -> valueAsBufferPtr -> bytesPtr) != 0xfeeefeeefeeefeee);

# define ASSERT_VARIANT_PTR_ARRAY(x) \
  ASSERT_VARIANT_PTR_COMPLEX(x) \
  assert((x) -> type == VARIANT_ARRAY); \

# define ASSERT_VARIANT_PTR_MAP_OR_OBJECT(x) \
  ASSERT_VARIANT_PTR_COMPLEX(x) \
  assert(((x) -> type == VARIANT_MAP) || ((x) -> type == VARIANT_OBJECT)); \
  assert(((Map_t*)(x) -> valueAsBufferPtr -> bytesPtr) -> bucketsCnt >= 2);

# define ASSERT_VARIANT_PTR_MAP(x) \
  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(x) \
  assert((x) -> type == VARIANT_MAP);

# define ASSERT_VARIANT_PTR_OBJECT(x) \
  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(x) \
  assert((x) -> type == VARIANT_OBJECT);

# define ASSERT_VARIANT_PTR_STRING(x) \
  ASSERT_VARIANT_PTR_ANY(x) \
  assert((x) -> type == VARIANT_STRING); \
  if (((x) -> flags & VARIANT_FLAG_ONE_CHARACTER) == 0) { \
    assert((x) -> valueAsBufferPtr != NULL); \
    assert((x) -> valueAsBufferPtr -> refCnt != 0); \
    assert((x) -> valueAsBufferPtr -> bytesPtr != NULL); \
    assert((uint64_t)((x) -> valueAsBufferPtr -> bytesPtr) != 0xdeadbeef); \
    assert((uint64_t)((x) -> valueAsBufferPtr -> bytesPtr) != 0xfeeefeeefeeefeee); \
  }

# define ASSERT_VARIANT_PTR_ARRAY_OR_STRING(x) \
  ASSERT_VARIANT_PTR_ANY(x) \
  assert(((x) -> type == VARIANT_ARRAY) || ((x) -> type == VARIANT_STRING)); \
  if ((x) -> type == VARIANT_ARRAY)  { ASSERT_VARIANT_PTR_ARRAY(x); } \
  if ((x) -> type == VARIANT_STRING) { ASSERT_VARIANT_PTR_STRING(x); }

#else

# define ASSERT_VARIANT_PTR_ANY(x)
# define ASSERT_VARIANT_PTR_INTEGER(x)
# define ASSERT_VARIANT_PTR_COMPLEX(x)
# define ASSERT_VARIANT_PTR_ARRAY(x)
# define ASSERT_VARIANT_PTR_MAP_OR_OBJECT(x)
# define ASSERT_VARIANT_PTR_MAP(x)
# define ASSERT_VARIANT_PTR_OBJECT(x)
# define ASSERT_VARIANT_PTR_STRING(x)
# define ASSERT_VARIANT_PTR_ARRAY_OR_STRING(x)

#endif /* VARIANT_ASSERT_ENABLED */

#endif /* _Mold_Error_H */

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldForDriver.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MOLD_ForDriver_
#define _MOLD_ForDriver_

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantString.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldVariantString_H
#define _MoldVariantString_H


typedef struct String
{
  uint64_t length;
  char text[];
} String_t;

Variant_t __MOLD_VariantStringCreateFromCString(const char *text);

void __MOLD_VariantStringRelease(Variant_t *x);

void __MOLD_VariantStringJoin(Variant_t *dst,
                              const Variant_t *x,
                              const Variant_t *y);

bool32_t __MOLD_cmp_eq_string(const Variant_t *x, const Variant_t *y);
bool32_t __MOLD_cmp_ne_string(const Variant_t *x, const Variant_t *y);

Variant_t __MOLD_Str(Variant_t *x);

Variant_t __MOLD_SubStr(const Variant_t *x,
                        const Variant_t *idx,
                        const Variant_t *len);

uint32_t __MOLD_Ord(const Variant_t *x);

Variant_t __MOLD_Asc(const Variant_t *x);

void __MOLD_StrAndAssign(Variant_t *rv, Variant_t *x);

void __MOLD_SubStrAndAssign(Variant_t *rv,
                            const Variant_t *x,
                            const Variant_t *idx,
                            const Variant_t *len);

void __MOLD_AscAndAssign(Variant_t *rv, const Variant_t *x);

#endif /* _MoldVariantString_H */

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantArray.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldVariantArray_H
#define _MoldVariantArray_H


// -----------------------------------------------------------------------------
//                    Type definition: array of variants
// -----------------------------------------------------------------------------

typedef struct Array
{
  uint32_t innerType;
  uint8_t itemSize;
  uint8_t reserved1;
  uint8_t reserved2;
  uint8_t reserved3;
  uint64_t itemsCnt;
  Variant_t items[];
} Array_t;

// -----------------------------------------------------------------------------
//                      Type definition: array of int8
// -----------------------------------------------------------------------------

typedef struct Array_int8
{
  uint32_t innerType;
  uint8_t itemSize;
  uint8_t reserved1;
  uint8_t reserved2;
  uint8_t reserved3;
  uint64_t itemsCnt;
  int8_t items[];
} Array_int8_t;

// -----------------------------------------------------------------------------
//                     Type definition: array of int16
// -----------------------------------------------------------------------------

typedef struct Array_int16
{
  uint32_t innerType;
  uint8_t itemSize;
  uint8_t reserved1;
  uint8_t reserved2;
  uint8_t reserved3;
  uint64_t itemsCnt;
  int16_t items[];
} Array_int16_t;

// -----------------------------------------------------------------------------
//                     Type definition: array of int32
// -----------------------------------------------------------------------------

typedef struct Array_int32
{
  uint32_t innerType;
  uint8_t itemSize;
  uint8_t reserved1;
  uint8_t reserved2;
  uint8_t reserved3;
  uint64_t itemsCnt;
  int32_t items[];
} Array_int32_t;

// -----------------------------------------------------------------------------
//                      Type definition: array of int64
// -----------------------------------------------------------------------------

typedef struct Array_int64
{
  uint32_t innerType;
  uint8_t itemSize;
  uint8_t reserved1;
  uint8_t reserved2;
  uint8_t reserved3;
  uint64_t itemsCnt;
  int64_t items[];
} Array_int64_t;

// -----------------------------------------------------------------------------
//                                  Functions
// -----------------------------------------------------------------------------

void __MOLD_VariantArrayCreate(Variant_t *dst);
void __MOLD_VariantArrayCreateFromInitList(Variant_t *dst, const Variant_t *initArray);

void __MOLD_VariantArrayRelease(Variant_t *x);

void __MOLD_VariantLoadFromIndexAndAssign_variant(Variant_t *rv, const Variant_t *box, int32_t idx);
void __MOLD_VariantLoadFromIndexAndAssign_string (Variant_t *rv, const Variant_t *box, int32_t idx);

Variant_t __MOLD_VariantLoadFromIndex        (const Variant_t *box, int32_t idx);
Variant_t __MOLD_VariantLoadFromIndex_variant(const Variant_t *box, int32_t idx);
Variant_t __MOLD_VariantLoadFromIndex_string (const Variant_t *box, int32_t idx);
int32_t   __MOLD_VariantLoadFromIndex_int32  (const Variant_t *box, int32_t idx);
int64_t   __MOLD_VariantLoadFromIndex_int64  (const Variant_t *box, int32_t idx);
bool32_t  __MOLD_VariantLoadFromIndex_bool32 (const Variant_t *box, int32_t idx);
float64_t __MOLD_VariantLoadFromIndex_float64(const Variant_t *box, int32_t idx);

void __MOLD_VariantStoreAtIndex_variant(Variant_t *box, int32_t idx, Variant_t *value);
void __MOLD_VariantStoreAtIndex_string (Variant_t *box, int32_t idx, Variant_t *value);
void __MOLD_VariantStoreAtIndex_int32  (Variant_t *box, int32_t idx, int32_t value);
void __MOLD_VariantStoreAtIndex_int64  (Variant_t *box, int32_t idx, int64_t value);
void __MOLD_VariantStoreAtIndex_bool32 (Variant_t *box, int32_t idx, bool32_t value);
void __MOLD_VariantStoreAtIndex_float64(Variant_t *box, int32_t idx, float64_t value);

void __MOLD_ArrayInsertAfterLast(Variant_t *box, Variant_t *value);

#endif /* _MoldVariantArray_H */

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantMap.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldVariantMap_H
#define _MoldVariantMap_H


// -----------------------------------------------------------------------------
//                                  Defines
// -----------------------------------------------------------------------------

#define VARIANT_MAP_DEFAULT_BUCKETS_CNT 16

// -----------------------------------------------------------------------------
//                              Type definitions
// -----------------------------------------------------------------------------

typedef struct MapBucket
{
  Variant_t key;
  Variant_t value;
  struct MapBucket *nextBucket;
} MapBucket_t;

typedef struct Map
{
  uint64_t reserved;
  uint64_t bucketsUsedCnt;
  uint64_t bucketsCnt;

  MapBucket_t *firstBucket;
  MapBucket_t *lastBucket;
  MapBucket_t buckets[];
} Map_t;

// -----------------------------------------------------------------------------
//                                Functions
// -----------------------------------------------------------------------------

uint32_t __MOLD_hashDJB2(const Variant_t *x);

void __MOLD_VariantMapCreate(Variant_t *dst);
void __MOLD_VariantMapCreateWithCustomSize(Variant_t *dst, uint32_t bucketsCnt);

void __MOLD_VariantMapCreateFromInitList(Variant_t *dst,
                                         const Variant_t *keys,
                                         const Variant_t *values);

void __MOLD_VariantMapRelease(Variant_t *x);

Variant_t __MOLD_VariantLoadFromKey_variant(Variant_t *box, Variant_t *key);
Variant_t __MOLD_VariantLoadFromKey_string(Variant_t *box, Variant_t *key);

void __MOLD_VariantLoadFromKeyAndAssign_variant(Variant_t *rv,
                                                Variant_t *box,
                                                Variant_t *key);

void __MOLD_VariantLoadFromKeyAndAssign_string(Variant_t *rv,
                                               Variant_t *box,
                                               Variant_t *key);

void __MOLD_VariantStoreAtKey_variant(Variant_t *box, const Variant_t *key, const Variant_t *value);
void __MOLD_VariantStoreAtKey_string(Variant_t *box, const Variant_t *key, const Variant_t *value);
void __MOLD_VariantStoreAtKey_int32(Variant_t *box, const Variant_t *key, int32_t value);
void __MOLD_VariantStoreAtKey_int64(Variant_t *box, const Variant_t *key, int64_t value);
void __MOLD_VariantStoreAtKey_float64(Variant_t *box, const Variant_t *key, float64_t value);
void __MOLD_VariantStoreAtKey_bool32(Variant_t *box, const Variant_t *key, bool32_t value);

#endif /* _MoldVariantMap_H */


typedef void (*LoopBodyCbProto)();

void __MOLD_ForDriver_IndexesAndValuesInArray(Array_t *array,
                                              uint32_t *iteratorIndex,
                                              Variant_t *iteratorValue,
                                              LoopBodyCbProto cb);

void __MOLD_ForDriver_IndexesAndValuesInString(Variant_t *box,
                                               uint32_t *iteratorIndex,
                                               Variant_t *iteratorValue,
                                               LoopBodyCbProto cb);

void __MOLD_ForDriver_IndexesAndValuesInArrayOrString(Variant_t *box,
                                                      void *iteratorIndexOrKey,
                                                      Variant_t *iteratorValue,
                                                      LoopBodyCbProto cb);

void __MOLD_ForDriver_KeysAndValuesInMap(Variant_t *box,
                                         Variant_t *iteratorKey,
                                         Variant_t *iteratorValue,
                                         LoopBodyCbProto cb);

void __MOLD_ForDriver_Generic(Variant_t *box, void *iteratorIndexOrKey,
                              Variant_t *iteratorValue, LoopBodyCbProto cb);

#endif /* _MOLD_ForDriver */

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldPrint.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldPrint_H
#define _MoldPrint_H

#include <stdio.h>

void __MOLD_PrintToFile_variant(FILE *f, Variant_t *x);

void __MOLD_VariantPrint(Variant_t *x);
void __MOLD_Print_space();
void __MOLD_Print_EOL();
void __MOLD_PrintFormat(const char *fmt, ...);

void __MOLD_Print_variant(Variant_t *x);
void __MOLD_Print_string(Variant_t *x);
void __MOLD_Print_bool32(int32_t x);
void __MOLD_Print_int32(int32_t x);
void __MOLD_Print_int64(int64_t x);
void __MOLD_Print_float64(float64_t x);
void __MOLD_Print_char(char x);
void __MOLD_Print_raw(const char *buf, uint32_t bufSize);

Variant_t __MOLD_PrintToString_variant(Variant_t *x);
Variant_t __MOLD_BuildString(const char *fmt, ...);

#endif /* _MoldPrint_H */

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantObject.h <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#ifndef _MoldVariantObject_H
#define _MoldVariantObject_H


typedef struct Object
{
  void **vtable;
  uint64_t bucketsUsedCnt;
  uint64_t bucketsCnt;

  MapBucket_t *firstBucket;
  MapBucket_t *lastBucket;

  MapBucket_t buckets[1];
} Object_t;

void __MOLD_VariantObjectCreate(Variant_t *dst, void **vtable);

#endif /* _MoldVariantMap_H */

// File generated by 01-build-amalgamation.js from original *.c and *.h files.
// DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!

// Generated on: 2025-07-12T17:31:28.952Z

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldCore.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <inttypes.h>


// -----------------------------------------------------------------------------
//                             Global variables
// -----------------------------------------------------------------------------

Variant_t argc       = { VARIANT_UNDEFINED };
Variant_t argv       = { VARIANT_UNDEFINED };
Variant_t __TrashBin = { VARIANT_UNDEFINED };

// Custom stack to allocatable variant vars.
static Variant_t __MOLD_Stack[MOLD_DEFAULT_STACK_SIZE];
Variant_t *__MOLD_StackPtr = &__MOLD_Stack[MOLD_DEFAULT_STACK_SIZE - 1];

// -----------------------------------------------------------------------------
//                Convert: create variant from primitives
// -----------------------------------------------------------------------------

Variant_t __MOLD_VariantCreateFrom_int32(int32_t x)
{
  Variant_t rv = { type: VARIANT_INTEGER, valueAsInt64: x, flags: 0 };
  return rv;
}

Variant_t __MOLD_VariantCreateFrom_int64(int64_t x)
{
  Variant_t rv = { type: VARIANT_INTEGER, valueAsInt64: x, flags: 0 };
  return rv;
}

Variant_t __MOLD_VariantCreateFrom_bool32(bool32_t x)
{
  Variant_t rv = { type: VARIANT_BOOLEAN, valueAsInt64: x, flags: 0 };
  return rv;
}

Variant_t __MOLD_VariantCreateFrom_float32(float32_t x)
{
  Variant_t rv = { type: VARIANT_FLOAT, valueAsFloat32: x, flags: 0 };
  return rv;
}

Variant_t __MOLD_VariantCreateFrom_float64(float64_t x)
{
  Variant_t rv = { type: VARIANT_DOUBLE, valueAsFloat64: x, flags: 0 };
  return rv;
}

// -----------------------------------------------------------------------------
//                    Assign: apply new value
// -----------------------------------------------------------------------------

void __MOLD_VariantAssign_int32(Variant_t *rv, int32_t x)
{
  __MOLD_VariantDestroy(rv);
  rv -> type         = VARIANT_INTEGER;
  rv -> valueAsInt64 = x;
  rv -> flags        = 0;
}

void __MOLD_VariantAssign_int64(Variant_t *rv, int64_t x)
{
  __MOLD_VariantDestroy(rv);
  rv -> type         = VARIANT_INTEGER;
  rv -> valueAsInt64 = x;
  rv -> flags        = 0;
}

void __MOLD_VariantAssign_bool32(Variant_t *rv, bool32_t x)
{
  __MOLD_VariantDestroy(rv);
  rv -> type         = VARIANT_BOOLEAN;
  rv -> valueAsInt32 = x;
  rv -> flags        = 0;
}

void __MOLD_VariantAssign_float32(Variant_t *rv, float32_t x)
{
  __MOLD_VariantDestroy(rv);

  rv -> type           = VARIANT_FLOAT;
  rv -> valueAsFloat32 = x;
  rv -> flags          = 0;
}

void __MOLD_VariantAssign_float64(Variant_t *rv, float64_t x)
{
  __MOLD_VariantDestroy(rv);

  rv -> type           = VARIANT_DOUBLE;
  rv -> valueAsFloat64 = x;
  rv -> flags          = 0;
}

// -----------------------------------------------------------------------------
//                     Arithmetic: in32 vs int32
// -----------------------------------------------------------------------------

int32_t   __MOLD_neg_int32 (int32_t x )           { return - x; }
int32_t   __MOLD_add_int32 (int32_t x, int32_t y) { return x + y; };
int32_t   __MOLD_sub_int32 (int32_t x, int32_t y) { return x - y; };
int32_t   __MOLD_mul_int32 (int32_t x, int32_t y) { return x * y; };
int32_t   __MOLD_imul_int32(int32_t x, int32_t y) { return x * y; };
float64_t __MOLD_div_int32 (int32_t x, int32_t y) { return (float64_t) x / y; };
int32_t   __MOLD_idiv_int32(int32_t x, int32_t y) { return x / y; };

// -----------------------------------------------------------------------------
//                     Arithmetic: int64 vs int64
// -----------------------------------------------------------------------------

int64_t   __MOLD_neg_int64 (int64_t x ) { return - x; }
int64_t   __MOLD_add_int64 (int64_t x, int64_t y) { return x + y; };
int64_t   __MOLD_sub_int64 (int64_t x, int64_t y) { return x - y; };
int64_t   __MOLD_mul_int64 (int64_t x, int64_t y) { return x * y; };
int64_t   __MOLD_imul_int64(int64_t x, int64_t y) { return x * y; };
float64_t __MOLD_div_int64 (int64_t x, int64_t y) { return (float64_t) x / y; };
int64_t   __MOLD_idiv_int64(int64_t x, int64_t y) { return x / y; };

// -----------------------------------------------------------------------------
//                     Arithmetic: float64 vs float64
// -----------------------------------------------------------------------------

float64_t __MOLD_neg_float64 (float64_t x )             { return - x; }
float64_t __MOLD_add_float64 (float64_t x, float64_t y) { return x + y; };
float64_t __MOLD_sub_float64 (float64_t x, float64_t y) { return x - y; };
float64_t __MOLD_mul_float64 (float64_t x, float64_t y) { return x * y; };
float64_t __MOLD_imul_float64(float64_t x, float64_t y) { return x * y; };
float64_t __MOLD_div_float64 (float64_t x, float64_t y) { return x / y; };
int64_t   __MOLD_idiv_float64(float64_t x, float64_t y) { return (int64_t) (x / y); };

// -----------------------------------------------------------------------------
//                    Arithmetic: variant vs variant
// -----------------------------------------------------------------------------

void __MOLD_negAndAssign_variant(Variant_t *rv, const Variant_t *x)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_ANY(x);

  __MOLD_VariantDestroy(rv);

  rv -> type  = x -> type;
  rv -> flags = 0;

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv -> valueAsInt64   = -x -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { rv -> valueAsFloat32 = -x -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { rv -> valueAsFloat64 = -x -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }
}

void __MOLD_addAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_ANY(x);
  ASSERT_VARIANT_PTR_ANY(y);

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_badType();
  }

  __MOLD_VariantDestroy(rv);

  rv -> type  = x -> type;
  rv -> flags = 0;

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv -> valueAsInt64   = x -> valueAsInt64   + y -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { rv -> valueAsFloat32 = x -> valueAsFloat32 + y -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { rv -> valueAsFloat64 = x -> valueAsFloat64 + y -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }
}

void __MOLD_subAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_ANY(x);
  ASSERT_VARIANT_PTR_ANY(y);

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_badType();
  }

  __MOLD_VariantDestroy(rv);

  rv -> type  = x -> type;
  rv -> flags = 0;

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv -> valueAsInt64   = x -> valueAsInt64   - y -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { rv -> valueAsFloat32 = x -> valueAsFloat32 - y -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { rv -> valueAsFloat64 = x -> valueAsFloat64 - y -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }
}

void __MOLD_mulAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_ANY(x);
  ASSERT_VARIANT_PTR_ANY(y);

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_badType();
  }

  __MOLD_VariantDestroy(rv);

  rv -> type  = x -> type;
  rv -> flags = 0;

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv -> valueAsInt64   = x -> valueAsInt64   * y -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { rv -> valueAsFloat32 = x -> valueAsFloat32 * y -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { rv -> valueAsFloat64 = x -> valueAsFloat64 * y -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }
}

void __MOLD_imulAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y)
{
  __MOLD_mulAndAssign_variant(rv, x, y);
}

void __MOLD_divAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_ANY(x);
  ASSERT_VARIANT_PTR_ANY(y);

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_badType();
  }

  __MOLD_VariantDestroy(rv);

  rv -> type  = VARIANT_DOUBLE;
  rv -> flags = 0;

  float64_t xValue = 0.0;
  float64_t yValue = 0.0;

  switch (x -> type)
  {
    case VARIANT_INTEGER: { xValue = (float64_t) x -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { xValue = (float64_t) x -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { xValue = x -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }

  switch (y -> type)
  {
    case VARIANT_INTEGER: { yValue = (float64_t) y -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { yValue = (float64_t) y -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { yValue = y -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }

  rv -> valueAsFloat64 = xValue / yValue;
}

void __MOLD_idivAndAssign_variant(Variant_t *rv, const Variant_t *x, const Variant_t *y)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_ANY(x);
  ASSERT_VARIANT_PTR_ANY(y);

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_badType();
  }

  __MOLD_VariantDestroy(rv);

  rv -> type  = VARIANT_INTEGER;
  rv -> flags = 0;

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv -> value = x -> valueAsInt64 / y -> valueAsInt64; break; }
    case VARIANT_FLOAT:   { rv -> value = (int64_t) (x -> valueAsFloat32 / y -> valueAsFloat32); break; }
    case VARIANT_DOUBLE:  { rv -> value = (int64_t) (x -> valueAsFloat64 / y -> valueAsFloat64); break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }
}

Variant_t __MOLD_neg_variant(const Variant_t *x) {
  Variant_t rv = { 0 };
  __MOLD_negAndAssign_variant(&rv, x);
  return rv;
}

Variant_t __MOLD_add_variant(const Variant_t *x, const Variant_t *y) {
  Variant_t rv = { 0 };
  __MOLD_addAndAssign_variant(&rv, x, y);
  return rv;
}

Variant_t __MOLD_sub_variant(const Variant_t *x, const Variant_t *y) {
  Variant_t rv = { 0 };
  __MOLD_subAndAssign_variant(&rv, x, y);
  return rv;
}

Variant_t __MOLD_mul_variant(const Variant_t *x, const Variant_t *y) {
  Variant_t rv = { 0 };
  __MOLD_mulAndAssign_variant(&rv, x, y);
  return rv;
}

Variant_t __MOLD_imul_variant(const Variant_t *x, const Variant_t *y) {
  Variant_t rv = { 0 };
  __MOLD_imulAndAssign_variant(&rv, x, y);
  return rv;
}

Variant_t __MOLD_div_variant (const Variant_t *x, const Variant_t *y) {
  Variant_t rv = { 0 };
  __MOLD_divAndAssign_variant(&rv, x, y);
  return rv;
}

Variant_t __MOLD_idiv_variant(const Variant_t *x, const Variant_t *y) {
  Variant_t rv = { 0 };
  __MOLD_idivAndAssign_variant(&rv, x, y);
  return rv;
}

// -----------------------------------------------------------------------------
//                         Compare: int32 vs int32
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_int32(int32_t x, int32_t y) { return x == y; }
bool32_t __MOLD_cmp_ne_int32(int32_t x, int32_t y) { return x != y; }
bool32_t __MOLD_cmp_lt_int32(int32_t x, int32_t y) { return x < y; }
bool32_t __MOLD_cmp_gt_int32(int32_t x, int32_t y) { return x > y; }
bool32_t __MOLD_cmp_le_int32(int32_t x, int32_t y) { return x <= y; }
bool32_t __MOLD_cmp_ge_int32(int32_t x, int32_t y) { return x >= y; }

// -----------------------------------------------------------------------------
//                         Compare: int64 vs int64
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_int64(int64_t x, int64_t y) { return x == y; }
bool32_t __MOLD_cmp_ne_int64(int64_t x, int64_t y) { return x != y; }
bool32_t __MOLD_cmp_lt_int64(int64_t x, int64_t y) { return x < y; }
bool32_t __MOLD_cmp_gt_int64(int64_t x, int64_t y) { return x > y; }
bool32_t __MOLD_cmp_le_int64(int64_t x, int64_t y) { return x <= y; }
bool32_t __MOLD_cmp_ge_int64(int64_t x, int64_t y) { return x >= y; }

// -----------------------------------------------------------------------------
//                       Compare: float64 vs float64
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_float64(float64_t x, float64_t y) { return x == y; }
bool32_t __MOLD_cmp_ne_float64(float64_t x, float64_t y) { return x != y; }
bool32_t __MOLD_cmp_lt_float64(float64_t x, float64_t y) { return x < y; }
bool32_t __MOLD_cmp_gt_float64(float64_t x, float64_t y) { return x > y; }
bool32_t __MOLD_cmp_le_float64(float64_t x, float64_t y) { return x <= y; }
bool32_t __MOLD_cmp_ge_float64(float64_t x, float64_t y) { return x >= y; }

// -----------------------------------------------------------------------------
//                        Compare: bool32 vs bool32
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_bool32(bool32_t x, bool32_t y) { return x == y; }
bool32_t __MOLD_cmp_ne_bool32(bool32_t x, bool32_t y) { return x != y; }

// -----------------------------------------------------------------------------
//                       Compare: variant vs variant
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_variant(const Variant_t *x, const Variant_t *y)
{
  bool32_t rv = 0;

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_notComparable();
  }

  if (x -> type == VARIANT_STRING)
  {
    rv = __MOLD_cmp_eq_string(x, y);
  }
  else
  {
    rv = (x -> value == y -> value);
  }

  return rv;
}

bool32_t __MOLD_cmp_ne_variant(const Variant_t *x, const Variant_t *y)
{
  return !__MOLD_cmp_eq_variant(x, y);
}

bool32_t __MOLD_cmp_lt_variant(const Variant_t *x, const Variant_t *y)
{
  bool32_t rv = 0;

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_implicitConversion();
  }

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv = x -> valueAsInt64   < y -> valueAsInt64;   break; }
    case VARIANT_FLOAT:   { rv = x -> valueAsFloat32 < y -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { rv = x -> valueAsFloat64 < y -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_notComparable();
    }
  }

  return rv;
}

bool32_t __MOLD_cmp_gt_variant(const Variant_t *x, const Variant_t *y)
{
  return !__MOLD_cmp_le_variant(x, y);
}

bool32_t __MOLD_cmp_le_variant(const Variant_t *x, const Variant_t *y)
{
  bool32_t rv = 0;

  if (x -> type != y -> type)
  {
    __MOLD_PrintErrorAndDie_implicitConversion();
  }

  switch (x -> type)
  {
    case VARIANT_INTEGER: { rv = x -> valueAsInt64   <= y -> valueAsInt64;   break; }
    case VARIANT_FLOAT:   { rv = x -> valueAsFloat32 <= y -> valueAsFloat32; break; }
    case VARIANT_DOUBLE:  { rv = x -> valueAsFloat64 <= y -> valueAsFloat64; break; }

    default:
    {
      __MOLD_PrintErrorAndDie_notComparable();
    }
  }

  return rv;
}

bool32_t __MOLD_cmp_ge_variant(const Variant_t *x, const Variant_t *y)
{
  return !__MOLD_cmp_lt_variant(x, y);
}

// -----------------------------------------------------------------------------
//                       Cast variant into primitives
// -----------------------------------------------------------------------------

int32_t __MOLD_VariantCastTo_int32(Variant_t *x)
{
  if (x -> type != VARIANT_INTEGER)
  {
    __MOLD_PrintErrorAndDie_integerExpected();
  }

  return x -> valueAsInt32;
}

int64_t __MOLD_VariantCastTo_int64(Variant_t *x)
{
  if (x -> type != VARIANT_INTEGER)
  {
    __MOLD_PrintErrorAndDie_integerExpected();
  }

  return x -> valueAsInt64;
}

float32_t __MOLD_VariantCastTo_float32(Variant_t *x)
{
  if (x -> type != VARIANT_FLOAT)
  {
    __MOLD_PrintErrorAndDie_floatExpected();
  }

  return x -> valueAsFloat32;
}

float64_t __MOLD_VariantCastTo_float64(Variant_t *x)
{
  if (x -> type != VARIANT_DOUBLE)
  {
    __MOLD_PrintErrorAndDie_floatExpected();
  }

  return x -> valueAsFloat64;
}

bool32_t __MOLD_VariantCastTo_bool32(Variant_t *x)
{
  if (x -> type != VARIANT_BOOLEAN)
  {
    __MOLD_PrintErrorAndDie_booleanExpected();
  }

  return x -> valueAsInt32;
}

// -----------------------------------------------------------------------------
//                       Bitwise: variant vs variant
// -----------------------------------------------------------------------------

Variant_t __MOLD_Bitand(const Variant_t *x, const Variant_t *y)
{
  Variant_t rv = { type: VARIANT_INTEGER, value: x -> value & y -> value, flags: 0 };
  return rv;
}

Variant_t __MOLD_Bitor(const Variant_t *x, const Variant_t *y)
{
  Variant_t rv = { type: VARIANT_INTEGER, value: x -> value | y -> value, flags: 0 };
  return rv;
}

Variant_t __MOLD_Bitxor(const Variant_t *x, const Variant_t *y)
{
  Variant_t rv = { type: VARIANT_INTEGER, value: x -> value ^ y -> value, flags: 0 };
  return rv;
}

Variant_t __MOLD_Bitnot(const Variant_t *x)
{
  Variant_t rv = { type: VARIANT_INTEGER, value: ~x -> value, flags: 0 };
  return rv;
}

void __MOLD_BitandAndAssign(Variant_t *rv, const Variant_t *x, const Variant_t *y) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Bitand(x, y);
}

void __MOLD_BitorAndAssign(Variant_t *rv, const Variant_t *x, const Variant_t *y) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Bitor(x, y);
}

void __MOLD_BitxorAndAssign(Variant_t *rv, const Variant_t *x, const Variant_t *y) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Bitxor(x, y);
}

void __MOLD_BitnotAndAssign(Variant_t *rv, const Variant_t *x) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Bitnot(x);
}

// -----------------------------------------------------------------------------
//                                    Utils
// -----------------------------------------------------------------------------

void __MOLD_Exit()
{
  exit(0);
}

uint64_t __MOLD_Len(const Variant_t *x)
{
  uint64_t len = 0;

  switch (x -> type)
  {
    case VARIANT_UNDEFINED:
    case VARIANT_NULL:
    {
      len = 0;
      break;
    }

    case VARIANT_INTEGER:
    case VARIANT_FLOAT:
    case VARIANT_DOUBLE:
    case VARIANT_BOOLEAN:
    {
      len = 1;
      break;
    }

    case VARIANT_STRING:
    {
      if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
      {
        len = 1;
      }
      else
      {
        Buffer_t *buf = (Buffer_t *) x -> value;
        String_t *str = (String_t *) buf -> bytesPtr;
        len = str -> length;
      }

      break;
    }

    case VARIANT_ARRAY:
    {
      Buffer_t *buf   = (Buffer_t *) x -> value;
      Array_t  *array = (Array_t *) buf -> bytesPtr;
      len = array -> itemsCnt;

      break;
    }

    case VARIANT_MAP:
    case VARIANT_OBJECT:
    {
      Buffer_t *buf = (Buffer_t *) x -> value;
      Map_t *map = (Map_t *) buf -> bytesPtr;
      len = map -> bucketsUsedCnt;

      break;
    }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }

  return len;
}

void __MOLD_SysCall(uint32_t id, Variant_t *rv, ...)
{
  // TODO: Clean up this mess.
  // TODO: Ugly work-around to implement VM syscall with id set at runtime.
  __MOLD_VariantDestroy(rv);
  memset(rv, 0, sizeof(Variant_t));

  va_list ptr;
  va_start(ptr, rv);

  Variant_t *x = va_arg(ptr, Variant_t *);
  Variant_t *y = va_arg(ptr, Variant_t *);
  Variant_t *z = va_arg(ptr, Variant_t *);

  switch (id)
  {
    case 29: *rv = __MOLD_FileLoad(x); break;

    case 31: *rv = __MOLD_VariantCreateFrom_int32(__MOLD_Ord(x)); break;
    case 32: *rv = __MOLD_Asc(x); break;
    case 33: *rv = __MOLD_ParseInteger(x); break;
    case 34: *rv = __MOLD_VariantCreateFrom_float64(__MOLD_ParseFloat(x)); break;
    case 35: *rv = __MOLD_Bitand(x, y); break;
    case 36: *rv = __MOLD_Bitor(x, y); break;
    case 37: *rv = __MOLD_Bitxor(x, y); break;
    case 38: *rv = __MOLD_Bitnot(x); break;

    case 40:       __MOLD_Exit(); break;
    case 41:       __MOLD_Die(x); break;
    case 42: *rv = __MOLD_Str(x); break;
    case 43: *rv = __MOLD_VariantCreateFrom_int64(__MOLD_Len(x)); break;
    case 44: *rv = __MOLD_Typeof(x); break;
    case 45:       __MOLD_VariantPrint(x); break;
    case 46:       __MOLD_PrintToFile_variant(stderr, x); break;

    case 50:       __MOLD_ArrayInsertAfterLast(x, y); break;

    case 55: *rv = __MOLD_SubStr(x,y,z); break;
    case 57: *rv = __MOLD_GetTypeId(x); break;

    default:
    {
      fprintf(stderr, "runtime error: unknown syscall id: %d\n", id);
      exit(-1);
    }
  }

  va_end(ptr);
}

Variant_t __MOLD_Typeof(const Variant_t *x)
{
  static uint8_t bufferBytes_undefined[] = { 9,0,0,0,0,0,0,0 , 'u', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', 0 };
  static uint8_t bufferBytes_null[]      = { 4,0,0,0,0,0,0,0 , 'n', 'u', 'l', 'l', 0 };
  static uint8_t bufferBytes_integer[]   = { 7,0,0,0,0,0,0,0 , 'i', 'n', 't', 'e', 'g', 'e', 'r', 0 };
  static uint8_t bufferBytes_float[]     = { 5,0,0,0,0,0,0,0 , 'f', 'l', 'o', 'a', 't', 0 };
  static uint8_t bufferBytes_string[]    = { 6,0,0,0,0,0,0,0 , 's', 't', 'r', 'i', 'n', 'g', 0 };
  static uint8_t bufferBytes_boolean[]   = { 7,0,0,0,0,0,0,0 , 'b', 'o', 'o', 'l', 'e', 'a', 'n', 0 };
  static uint8_t bufferBytes_array[]     = { 5,0,0,0,0,0,0,0 , 'a', 'r', 'r', 'a', 'y', 0 };
  static uint8_t bufferBytes_map[]       = { 3,0,0,0,0,0,0,0 , 'm', 'a', 'p', 0 };
  static uint8_t bufferBytes_object[]    = { 6,0,0,0,0,0,0,0 , 'o', 'b', 'j', 'e', 'c', 't', 0 };

  static Buffer_t buffer_undefined = { 10 , -1, 0, &bufferBytes_undefined };
  static Buffer_t buffer_null      = { 5  , -1, 0, &bufferBytes_null };
  static Buffer_t buffer_integer   = { 8  , -1, 0, &bufferBytes_integer };
  static Buffer_t buffer_float     = { 6  , -1, 0, &bufferBytes_float };
  static Buffer_t buffer_string    = { 7  , -1, 0, &bufferBytes_string };
  static Buffer_t buffer_boolean   = { 8  , -1, 0, &bufferBytes_boolean };
  static Buffer_t buffer_array     = { 6  , -1, 0, &bufferBytes_array };
  static Buffer_t buffer_map       = { 4  , -1, 0, &bufferBytes_map };
  static Buffer_t buffer_object    = { 7  , -1, 0, &bufferBytes_object };

  Buffer_t *buf = NULL;

  switch (x -> type)
  {
    case VARIANT_UNDEFINED: { buf = &buffer_undefined; break; }
    case VARIANT_NULL:      { buf = &buffer_null;      break; }

    case VARIANT_INTEGER:   { buf = &buffer_integer;   break; }
    case VARIANT_FLOAT:     { buf = &buffer_float;     break; }
    case VARIANT_DOUBLE:    { buf = &buffer_float;     break; }
    case VARIANT_STRING:    { buf = &buffer_string;    break; }
    case VARIANT_BOOLEAN:   { buf = &buffer_boolean;   break; }

    case VARIANT_ARRAY:     { buf = &buffer_array;     break; }
    case VARIANT_MAP:       { buf = &buffer_map;       break; }
    case VARIANT_OBJECT:    { buf = &buffer_object;    break; }

    default:
    {
      __MOLD_PrintErrorAndDie_badType();
    }
  }

  Variant_t rv =
  {
    type: VARIANT_STRING,
    valueAsBufferPtr: buf,
    flags: 0
  };

  return rv;
}

void __MOLD_TypeofAndAssign(Variant_t *rv, const Variant_t *x) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Typeof(x);
}

Variant_t __MOLD_ParseInteger(const Variant_t *x)
{
  Variant_t rv = {
    type: VARIANT_INTEGER,
    flags: 0
  };

  if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    rv.valueAsInt64 = strtol((const char *) &x -> value, NULL, 0);
  }
  else
  {
    String_t *str = (String_t *) x -> valueAsBufferPtr -> bytesPtr;
    rv.valueAsInt64 = strtoll(str -> text, NULL, 0);
  }

  return rv;
}

void __MOLD_ParseIntegerAndAssign(Variant_t *rv, const Variant_t *x) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_ParseInteger(x);
}

float64_t __MOLD_ParseFloat(const Variant_t *x)
{
  float64_t rv;

  if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    rv = atof((const char *) &x -> value);
  }
  else
  {
    String_t *str = (String_t *) x -> valueAsBufferPtr -> bytesPtr;
    rv = atof(str -> text);
  }

  return rv;
}

Variant_t __MOLD_FileLoad(const Variant_t *path)
{
  Variant_t rv = { VARIANT_STRING };

  const char *pathRaw = NULL;

  if (path -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    pathRaw = (const char *) path -> value;
  }
  else
  {
    pathRaw = ((String_t *) path -> valueAsBufferPtr -> bytesPtr) -> text;
  }

  FILE *f = fopen(pathRaw, "rb");

  if (f)
  {
    fseek(f, 0, SEEK_END );
    int fSize = ftell(f);
    fseek(f, 0, SEEK_SET);

    Buffer_t *newBuf = __MOLD_MemoryAlloc(sizeof(String_t) + fSize + 1);
    String_t *newStr = (String_t *) newBuf -> bytesPtr;

    newStr -> length = fSize;
    rv.valueAsBufferPtr = newBuf;

    fread(&newStr -> text, fSize, 1, f);
    fclose(f);
  }
  else
  {
    fprintf(stderr, "error: could not open file '%s'", pathRaw);
    exit(1);
  }

  return rv;
}

void __MOLD_FileLoadAndAssign(Variant_t *rv, const Variant_t *path) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_FileLoad(path);
}

void __MOLD_InitArgv(int _argc, char **_argv)
{
  // TEMP!!!
  // setvbuf(stdout, NULL, _IONBF, 0);
  // setvbuf(stderr, NULL, _IONBF, 0);

  // Init argc global.
  argc.type  = VARIANT_INTEGER;
  argc.value = _argc;

  // Init argv[] global.
  __MOLD_VariantArrayCreate(&argv);

  for (int i = 0; _argv[i]; i++)
  {
    Variant_t oneArg = __MOLD_VariantStringCreateFromCString(_argv[i]);
    __MOLD_VariantStoreAtIndex_variant(&argv, i, &oneArg);

    // TODO: Review it.
    __MOLD_VariantDestroy(&oneArg);
  }
}

Variant_t __MOLD_GetTypeId(const Variant_t *x)
{
  Variant_t rv = { type: VARIANT_INTEGER, value: x -> type, flags: 0 };
  return rv;
}

void __MOLD_GetTypeIdAndAssign(Variant_t *rv, const Variant_t *x) {
  ASSERT_VARIANT_PTR_ANY(x);

  __MOLD_VariantDestroy(rv);

  rv -> type  = VARIANT_INTEGER;
  rv -> flags = 0;
  rv -> value = x -> type;
}

// -----------------------------------------------------------------------------
// Free all resources alocated by variant variable if any ->
// Do nothing for primitives, but it's still correct.
// This call tells, that the variable is not needed anymore and may be freed.
//
// Pseudo code:
//   delete x
//
// Parameters:
//   x - variable to be destroyed (IN/OUT).
// -----------------------------------------------------------------------------

void __MOLD_VariantDestroy(Variant_t *x)
{
  ASSERT_VARIANT_PTR_ANY(x);

  switch (x -> type)
  {
    case VARIANT_UNDEFINED:
    case VARIANT_NULL:
    case VARIANT_INTEGER:
    case VARIANT_FLOAT:
    case VARIANT_DOUBLE:
    case VARIANT_BOOLEAN:
    {
      // Primitive.
      // Do nothing.
      break;
    }

    case VARIANT_STRING:
    {
      __MOLD_VariantStringRelease(x);
      break;
    }

    case VARIANT_ARRAY:
    {
      __MOLD_VariantArrayRelease(x);
      break;
    }

    case VARIANT_MAP:
    case VARIANT_OBJECT:
    {
      __MOLD_VariantMapRelease(x);
      break;
    }
  }

  x -> type         = VARIANT_UNDEFINED;
  x -> flags        = 0xdeadbeef;
  x -> valueAsInt64 = 0xdeadbeef;
}

// -----------------------------------------------------------------------------
// Helper function to free array of variants.
//
// Pseudo code:
//   for i in 0 to n
//     delete x[i]
//   endfor
//
// Parameters:
//   x - array of variables to be destroyed (IN/OUT).
//   n - number of items in x[] array (IN).
// -----------------------------------------------------------------------------

void __MOLD_VariantDestroyMany(Variant_t *x, uint32_t n) {
  for (uint32_t idx = 0; idx < n; idx++) {
    __MOLD_VariantDestroy(&x[idx]);
  }
}

// -----------------------------------------------------------------------------
// Increase reference counter for dynamically alocatted variables.
// Do nothing for primitives, but it still correct.
//
// Pseudo code:
//   x -> refCnt++
//
// Parameters:
//   x - variable to referenced (IN/OUT).
// -----------------------------------------------------------------------------

void __MOLD_VariantAddRef(const Variant_t *x)
{
  switch (x -> type)
  {
    case VARIANT_UNDEFINED:
    case VARIANT_NULL:
    case VARIANT_INTEGER:
    case VARIANT_FLOAT:
    case VARIANT_DOUBLE:
    case VARIANT_BOOLEAN:
    {
      // Primitive.
      // Do nothing.
      break;
    }

    case VARIANT_STRING:
    {
      if (!(x -> flags & VARIANT_FLAG_ONE_CHARACTER))
      {
        __MOLD_MemoryAddRef(x -> valueAsBufferPtr);
      }
      break;
    }

    case VARIANT_ARRAY:
    case VARIANT_MAP:
    case VARIANT_OBJECT:
    {
        __MOLD_MemoryAddRef(x -> valueAsBufferPtr);
      break;
    }
  }
}

// -----------------------------------------------------------------------------
// Move variant object from the source to the destination slots.
// Source variant is destroyed if was not undefined.
//
// Pseudo code:
//   x = y
//
// Parameters:
//   dst - pointer to the destination variant slot (IN/OUT)
//   src - pointer to the source variant slot (IN/OUT)
// -----------------------------------------------------------------------------

void __MOLD_VariantMove(Variant_t *dst, Variant_t *src)
{
  __MOLD_VariantAddRef(src);
  __MOLD_VariantDestroy(dst);
  memcpy(dst, src, sizeof(Variant_t));
}

// -----------------------------------------------------------------------------
// Allocate n x Variant_t items on internal MOLD stack available via
// global __MOLD_StackPtr pointer.
//
// Parameters:
//   n - number of Variant_t slots to allocate (IN).
// -----------------------------------------------------------------------------

void __MOLD_StackAlloc(uint32_t n) {
  __MOLD_StackPtr -= n;
  assert(__MOLD_StackPtr > __MOLD_Stack);
  assert(__MOLD_StackPtr < &__MOLD_Stack[MOLD_DEFAULT_STACK_SIZE]);
  memset(__MOLD_StackPtr, 0, n * sizeof(Variant_t));
};

// -----------------------------------------------------------------------------
// Release stack frame allocated by __MOLD_StackAllocate() before.
//
// Parameters:
//   n - frame size as number of Variant_t items (IN)
// -----------------------------------------------------------------------------

void __MOLD_StackFree(uint32_t n) {
  while (n > 0) {
    __MOLD_VariantDestroy(__MOLD_StackPtr);
    __MOLD_StackPtr ++;
    assert(__MOLD_StackPtr > __MOLD_Stack);
    assert(__MOLD_StackPtr < &__MOLD_Stack[MOLD_DEFAULT_STACK_SIZE]);
    n--;
  }
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldError.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <errhandlingapi.h>


#define MOLD_DEFINE_ERROR_FCT(id, msg) void __MOLD_PrintErrorAndDie_##id() { __MOLD_PrintErrorAndDie(msg); }

void __MOLD_Die(const Variant_t *msg)
{
  __MOLD_PrintToFile_variant(stderr, (Variant_t *) msg);
  fprintf(stderr, "\n");
  exit(-1);
}

void __MOLD_PrintErrorAndDie(const char *msg)
{
  fprintf(stderr, "runtime error: %s\n", msg);
  exit(-1);
}

MOLD_DEFINE_ERROR_FCT(generic                  , "generic")
MOLD_DEFINE_ERROR_FCT(integerExpected          , "integer expected")
MOLD_DEFINE_ERROR_FCT(integerIndexExpected     , "integer index expected")
MOLD_DEFINE_ERROR_FCT(booleanExpected          , "boolean expected")
MOLD_DEFINE_ERROR_FCT(floatExpected            , "float expected")
MOLD_DEFINE_ERROR_FCT(stringKeyExpected        , "string key expected")
MOLD_DEFINE_ERROR_FCT(stringExpected           , "string expected")
MOLD_DEFINE_ERROR_FCT(mapOrObjectExpected      , "map or object expected")
MOLD_DEFINE_ERROR_FCT(objectExpected           , "object expected")
MOLD_DEFINE_ERROR_FCT(arrayExpected            , "array expected")
MOLD_DEFINE_ERROR_FCT(arrayOrStringExpected    , "array or string expected")
MOLD_DEFINE_ERROR_FCT(arrayStringOrMapExpected , "array, string or map expected")
MOLD_DEFINE_ERROR_FCT(negativeIndex            , "negative array index")
MOLD_DEFINE_ERROR_FCT(indexOutOfRange          , "index out of range")
MOLD_DEFINE_ERROR_FCT(outOfMemory              , "out of memory")
MOLD_DEFINE_ERROR_FCT(badType                  , "bad type")
MOLD_DEFINE_ERROR_FCT(notImplemented           , "not implemented")
MOLD_DEFINE_ERROR_FCT(implicitConversion       , "implicit type conversion not supported anymore")
MOLD_DEFINE_ERROR_FCT(notComparable            , "not comparable")
MOLD_DEFINE_ERROR_FCT(divideByZero             , "divide by zero")
MOLD_DEFINE_ERROR_FCT(floatOverflow            , "floating point overflow")
MOLD_DEFINE_ERROR_FCT(floatUnderflow           , "floating point underflow")
MOLD_DEFINE_ERROR_FCT(notIterable              , "not iterable")
MOLD_DEFINE_ERROR_FCT(nullMethodCalled         , "null method called")
MOLD_DEFINE_ERROR_FCT(vcallOnNonObject         , "virtual call on non-object")

LONG WINAPI __MOLD_SystemExceptionHandler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  fflush(stdout);
  fflush(stderr);

  switch (ExceptionInfo -> ExceptionRecord -> ExceptionCode)
  {
    case 0xc00000be: __MOLD_PrintErrorAndDie_divideByZero();
    case 0xc0000091: __MOLD_PrintErrorAndDie_floatOverflow();
    case 0xc0000093: __MOLD_PrintErrorAndDie_floatUnderflow();
    case 0xc0000094: __MOLD_PrintErrorAndDie_divideByZero();

    default:
    {
      fprintf(stderr, "runtime error: generic %lx\n", ExceptionInfo -> ExceptionRecord -> ExceptionCode);
      abort();
    }
  }

  return EXCEPTION_CONTINUE_SEARCH;
}

void __MOLD_InitExceptions()
{
  AddVectoredExceptionHandler(1, __MOLD_SystemExceptionHandler);
  SetUnhandledExceptionFilter(__MOLD_SystemExceptionHandler);
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldForDriver.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <string.h>


void __MOLD_ForDriver_IndexesAndValuesInArray(Array_t *array,
                                              uint32_t *iteratorIndex,
                                              Variant_t *iteratorValue,
                                              LoopBodyCbProto cb)
{
  assert(array != NULL);
  assert(iteratorIndex != NULL);
  assert(iteratorValue != NULL);
  assert(cb != NULL);

  uint32_t itemsCnt = array -> itemsCnt;

  if (array -> innerType == 0)
  {
    // Array of variants.
    for (uint32_t idx = 0; idx < itemsCnt; idx++)
    {
      *iteratorIndex = idx;
      *iteratorValue = array -> items[idx];
      ASSERT_VARIANT_PTR_ANY(iteratorValue);
      cb();
    }
  }
  else
  {
    // Array of given type.
    // TODO: Simplify it.
    // TODO: Handle array of double.
    iteratorValue -> type  = array -> innerType;
    iteratorValue -> value = 0;
    iteratorValue -> flags = 0;

    switch (array -> itemSize)
    {
      case 0:
      {
        // Array of 8-bit values.
        int8_t *values = (int8_t *) array -> items;

        for (uint32_t idx = 0; idx < itemsCnt; idx++)
        {
           *iteratorIndex = idx;
           iteratorValue -> value = values[idx];
           ASSERT_VARIANT_PTR_INTEGER(iteratorValue);
           cb();
        }

        break;
      }

      case 1:
      {
        // Array of 16-bit values.
        int16_t *values = (int16_t *) array -> items;

        for (uint32_t idx = 0; idx < itemsCnt; idx++)
        {
           *iteratorIndex = idx;
           iteratorValue -> value = values[idx];
           ASSERT_VARIANT_PTR_INTEGER(iteratorValue);
           cb();
        }

        break;
      }

      case 2:
      {
        // Array of 32-bit values.
        int32_t *values = (int32_t *) array -> items;

        for (uint32_t idx = 0; idx < itemsCnt; idx++)
        {
           *iteratorIndex = idx;
           iteratorValue -> value = values[idx];
           ASSERT_VARIANT_PTR_INTEGER(iteratorValue);
           cb();
        }

        break;
      }

      case 3:
      {
        // Array of 64-bit values.
        int64_t *values = (int64_t *) array -> items;

        for (uint32_t idx = 0; idx < itemsCnt; idx++)
        {
           *iteratorIndex = idx;
           iteratorValue -> value = values[idx];
           ASSERT_VARIANT_PTR_INTEGER(iteratorValue);
           cb();
        }

        break;
      }
    }
  }

  memset(iteratorValue, 0, sizeof(Variant_t));
}

void __MOLD_ForDriver_IndexesAndValuesInString(Variant_t *box,
                                               uint32_t *iteratorIndex,
                                               Variant_t *iteratorValue,
                                               LoopBodyCbProto cb)
{
  assert(box != NULL);
  assert(iteratorIndex != NULL);
  assert(iteratorValue != NULL);
  assert(cb != NULL);

  iteratorValue -> type  = VARIANT_STRING;
  iteratorValue -> flags = VARIANT_FLAG_ONE_CHARACTER;

  if (box -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    // One character string.
    // Just pass it to caller.
    *iteratorIndex = 0;
    iteratorValue -> value = box -> valueAsInt8;
    ASSERT_VARIANT_PTR_STRING(iteratorValue);
    cb();
  }
  else
  {
    // Multichar string.
    // Iterate char-by-char.
    Buffer_t *buf = box -> valueAsBufferPtr;
    String_t *str = (String_t *) buf -> bytesPtr;

    uint32_t length = str -> length;

    for (uint32_t idx = 0; idx < length; idx++)
    {
      *iteratorIndex = idx;
      iteratorValue -> value = str -> text[idx];
      ASSERT_VARIANT_PTR_STRING(iteratorValue);
      cb();
    }
  }

  // Clear iterator variable after loop exit.
  memset(iteratorValue, 0, sizeof(Variant_t));
}

void __MOLD_ForDriver_KeysAndValuesInMap(Variant_t *box,
                                         Variant_t *iteratorKey,
                                         Variant_t *iteratorValue,
                                         LoopBodyCbProto cb)
{
  if ((box -> type != VARIANT_MAP) &&
      (box -> type != VARIANT_OBJECT))
  {
    __MOLD_PrintErrorAndDie_mapOrObjectExpected();
  }

  Buffer_t *buf = box -> valueAsBufferPtr;
  Map_t    *map = (Map_t *) buf -> bytesPtr;

  uint32_t bucketsUsedCnt = map -> bucketsUsedCnt;

  MapBucket_t *bucket = map -> firstBucket;

  for (uint32_t idx = 0; idx < bucketsUsedCnt; idx++)
  {
    memcpy(iteratorKey  , &bucket -> key  , sizeof(Variant_t));
    memcpy(iteratorValue, &bucket -> value, sizeof(Variant_t));

    ASSERT_VARIANT_PTR_STRING(iteratorKey);
    ASSERT_VARIANT_PTR_ANY(iteratorValue);
    cb();

    bucket = bucket -> nextBucket;
  }

  // Clear iterator variables after loop exit.
  memset(iteratorKey   , 0, sizeof(Variant_t));
  memset(iteratorValue , 0, sizeof(Variant_t));
}

// ----------------------------------------------------------------------------
//  Process each (key, value) pairs in generic box.
//
//  box                - array, map or string container (IN)
//  iteratorIndexOrKey - index or key iterator (OUT)
//  iteratorValue      - value iterator (OUT)
//  cb                 - body loop callback (IN)
// ----------------------------------------------------------------------------

void __MOLD_ForDriver_Generic(Variant_t *box, void *iteratorIndexOrKey,
                              Variant_t *iteratorValue, LoopBodyCbProto cb)
{
  ASSERT_VARIANT_PTR_ANY(box);

  // Redirect unused iterators to trash bin.
  if (iteratorIndexOrKey == NULL) iteratorIndexOrKey = &__TrashBin;
  if (iteratorValue      == NULL) iteratorValue      = &__TrashBin;

  // Dispatch variant type.
  switch (box -> type)
  {
    case VARIANT_ARRAY:
    {
      ASSERT_VARIANT_PTR_ARRAY(box);
      Buffer_t *buf  = box -> valueAsBufferPtr;
      Array_t *array = (Array_t *) buf -> bytesPtr;
      __MOLD_ForDriver_IndexesAndValuesInArray(array, iteratorIndexOrKey, iteratorValue, cb);
      break;
    }

    case VARIANT_STRING:
    {
      ASSERT_VARIANT_PTR_STRING(box);
      __MOLD_ForDriver_IndexesAndValuesInString(box, iteratorIndexOrKey, iteratorValue, cb);
      break;
    }

    case VARIANT_MAP:
    case VARIANT_OBJECT:
    {
      ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
      __MOLD_ForDriver_KeysAndValuesInMap(box, iteratorIndexOrKey, iteratorValue, cb);
      break;
    }

    default:
    {
      __MOLD_PrintErrorAndDie_notIterable();
    }
  }
}

void __MOLD_ForDriver_IndexesAndValuesInArrayOrString(Variant_t *box,
                                                      void *iteratorIndexOrKey,
                                                      Variant_t *iteratorValue,
                                                      LoopBodyCbProto cb)
{
  switch (box -> type)
  {
    case VARIANT_ARRAY:
    case VARIANT_STRING:
    {
      __MOLD_ForDriver_Generic(box, iteratorIndexOrKey, iteratorValue, cb);
      break;
    }

    default:
    {
      __MOLD_PrintErrorAndDie_arrayOrStringExpected();
    }
  }
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldMemory.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>


static int _cntAlloc = 0;
static int _cntFree  = 0;

// ----------------------------------------------------------------------------
// Allocate new memory buffer.
//
// sizeInBytes - size of new buffer in bytes (IN).
//
// RETURNS: Pointer to new allocated Buffer_t struct.
// ----------------------------------------------------------------------------

Buffer_t *__MOLD_MemoryAlloc(uint32_t sizeInBytes)
{
  Buffer_t *rv;
  uint32_t alignedCapacity;
  void *bytesPtr;

  // Align size to 64 bytes.
  alignedCapacity = (sizeInBytes + 64) & ~63;

  // Allocate Buffer_t holder.
  rv = malloc(sizeof(Buffer_t));

  if (rv == NULL)
  {
    __MOLD_PrintErrorAndDie_outOfMemory();
  }

  // Allocate new memory block.
  bytesPtr = calloc(1, alignedCapacity);

  // Set up Buffer_t struct.
  rv -> capacity = alignedCapacity;
  rv -> refCnt   = 1;
  rv -> flags    = 0;
  rv -> bytesPtr = bytesPtr;

  _cntAlloc++;

  // printf("[ MEMORY ] allocated buffer, capacity %d, ptr %p\n", alignedCapacity, rv);

  return rv;
}

// ----------------------------------------------------------------------------
// Increase buffer reference pointer.
//
// sizeInBytes - size of new buffer in bytes (IN).
//
// RETURNS: Pointer to new allocated Buffer_t struct.
// ----------------------------------------------------------------------------

void __MOLD_MemoryAddRef(Buffer_t *buf)
{
  if (buf -> refCnt != -1)
  {
    buf -> refCnt++;

    // printf("[ MEMORY ] increased refCnt to %"PRId64", ptr %p\n", buf -> refCnt, buf);
  }
}

// ----------------------------------------------------------------------------
// Decrease buffer reference counter and free it if reaches 0.
//
// buf - pointer to the Buffer_t struct allocated by __MOLD_MemoryAlloc()
//       before (IN/OUT).
// ----------------------------------------------------------------------------

void __MOLD_MemoryRelease(Buffer_t *buf)
{
  assert(buf -> refCnt != 0);

  if (buf -> refCnt != -1)
  {
    buf -> refCnt--;
    // printf("[ MEMORY ] decreased refCnt to %"PRId64", ptr %p\n", buf -> refCnt, buf);

    if (buf -> refCnt == 0)
    {
      free(buf -> bytesPtr);

      *((uint64_t *) (&buf -> bytesPtr)) = 0xdeadbeef;

      free(buf);
      _cntFree++;

      // printf("[ MEMORY ] freed buffer, ptr %p\n", buf);
    }
  };
}

// ----------------------------------------------------------------------------
// Change (increase or decrease) buffer size to the desired value.
//
// buf - pointer to Buffer_t struct allocated by __MOLD_MemoryAlloc
//       before (IN).
//
// newCapacity - desired size in bytes (IN).
// ----------------------------------------------------------------------------

void __MOLD_MemoryRealloc(Buffer_t *buf, uint64_t newCapacity)
{
  if (buf -> refCnt != -1)
  {
    // Align new capacity to 64-bytes.
    newCapacity = (newCapacity + 64) & ~63;

    // Allocate new bytes buffer.
    uint32_t oldCapacity = buf -> capacity;

    void *newBytesPtr = realloc(buf -> bytesPtr, newCapacity);

    if (newBytesPtr == NULL)
    {
      __MOLD_PrintErrorAndDie_outOfMemory();
    }

    // Zero fill new allocated content.
    memset(newBytesPtr + oldCapacity, 0, newCapacity - oldCapacity);

    // Set up buffer struct.
    buf -> bytesPtr = newBytesPtr;
    buf -> capacity = newCapacity;

    // printf("[ MEMORY ] realloc buffer, newCapacity %"PRId64", ptr %p\n", newCapacity, buf);
  }
}

// ----------------------------------------------------------------------------
// Increase buffer capacity twice.
//
// buf - pointer to Buffer_t struct allocated by __MOLD_MemoryAlloc before (IN).
//
// RETURNS: Pointer to new Buffer_t struct.
// ----------------------------------------------------------------------------

void __MOLD_MemoryIncreaseBufferTwice(Buffer_t *buf)
{
  __MOLD_MemoryRealloc(buf, buf -> capacity * 2);
}

// ----------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------

void __MOLD_MemoryDieIfMemoryLeak()
{
  if (_cntAlloc != _cntFree)
  {
    // fprintf(stderr, "error: memory leak detected (alloc=%d, free=%d)!\n", _cntAlloc, _cntFree);
  }
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldPrint.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <inttypes.h>
#include <stdarg.h>
#include <string.h>


#define __MOLD_DEFAULT_PRINT_BUFFER_SIZE 32

// Forward declaration.
struct __MOLD_PrintContext;

typedef void (*__MOLD_WriteRawCallback)(struct __MOLD_PrintContext *ctx,
                                        const char *data,
                                        uint64_t dataSize);

typedef struct __MOLD_PrintContext {
  // Callback functions called by generic print code.
  __MOLD_WriteRawCallback writeRawCb;

  // Used durint print to file mode.
  FILE *f;

  // Used during print to string mode.
  uint64_t bufCapacity;
  uint64_t bufSize;
  char *buf;
} __MOLD_PrintContext_t;

static void __MOLD_WriteRawToFileCallback(__MOLD_PrintContext_t *ctx,
                                          const char *data,
                                          uint64_t dataSize) {

  assert(ctx != NULL);
  assert(ctx -> f != NULL);
  fwrite(data, dataSize, 1, ctx -> f);
}

static void __MOLD_WriteRawToBufferCallback(__MOLD_PrintContext_t *ctx,
                                            const char *data,
                                            uint64_t dataSize) {

  assert(ctx != NULL);
  assert(ctx -> buf != NULL);

  if (dataSize > 0) {
    if (ctx -> bufSize + dataSize >= ctx -> bufCapacity) {
      ctx -> bufCapacity *= 2;
      ctx -> buf = realloc(ctx -> buf, ctx -> bufCapacity);
    }

    memcpy(ctx -> buf + ctx -> bufSize, data, dataSize);
    ctx -> bufSize += dataSize;
    ctx -> buf[ctx -> bufSize] = 0;
  }
}

// Remove visited flags recursively set during __MOLD_VariantPrint before.
// We set visited flag to catch circular references and avoid infinite
// loop.
// Because nodes may be connceted in any way, we walkthrough the tree
// twice during print:
// - first pass  - print nodes and mark visited node (to print once),
// - second pass - clean up visited flags.
static void __MOLD_ClenUpAfterPrint(Variant_t *x) {
  x -> flags &= ~VARIANT_FLAG_NODE_VISITED;

  switch (x -> type) {
    case VARIANT_ARRAY: {
      // Decode array from the variant box.
      Buffer_t *buf = x -> valueAsBufferPtr;
      Array_t *array = (Array_t *) buf -> bytesPtr;

      if (array -> innerType == 0) {
        if ((array -> itemsCnt > 0) &&
            (array -> items[0].flags & VARIANT_FLAG_NODE_VISITED)) {
          // Array was visited during print.
          // Switch back to non-visited before next print call.
          for (uint32_t idx = 0; idx < array -> itemsCnt; idx++) {
            __MOLD_ClenUpAfterPrint(&array -> items[idx]);
          }
        }
      }

      break;
    }

    case VARIANT_MAP: {
      // Decode map from the variant box.
      Buffer_t *buf = x -> valueAsBufferPtr;
      Map_t    *map = (Map_t *) buf -> bytesPtr;

      uint32_t bucketsUsedCnt = map -> bucketsUsedCnt;
      MapBucket_t *bucket     = map -> firstBucket;

      if (bucket && bucket -> key.flags & VARIANT_FLAG_NODE_VISITED) {
        // Map was visited during print.
        // Switch back to non-visited before next print call.
        for (uint32_t idx = 0; idx < bucketsUsedCnt; idx++) {
          __MOLD_ClenUpAfterPrint(&bucket -> key);
          __MOLD_ClenUpAfterPrint(&bucket -> value);
          bucket = bucket -> nextBucket;
        }
      }
    }

    break;
  }
}

// -----------------------------------------------------------------------------
// Print variant variable to the C stream.
//
// f - output C stream e.g. stdout (IN),
// x - variable to be printed (IN),
// -----------------------------------------------------------------------------

static void __MOLD_PrintVariantInernal(__MOLD_PrintContext_t *ctx, Variant_t *x) {
  assert(ctx != NULL);
  assert(x != NULL);

  #define EMIT_LITERAL(x) ctx -> writeRawCb(ctx, (x), sizeof(x) - 1);

  // Extra guard to avoid infinite loops on circular references.
  x -> flags |= VARIANT_FLAG_NODE_VISITED;

  // Temp buffer to render primitives before emit.
  char tmpBuf[31];
  uint64_t tmpBufSize;

  switch (x -> type) {
    // ------------------------------------------------------------------------
    //                         Print primitives
    // ------------------------------------------------------------------------

    case VARIANT_UNDEFINED: { EMIT_LITERAL("undefined"); break; }
    case VARIANT_NULL:      { EMIT_LITERAL("null");      break; }

    case VARIANT_INTEGER: {
      tmpBufSize = snprintf(tmpBuf, sizeof(tmpBuf) - 1, "%"PRId64, x -> valueAsInt64);
      ctx -> writeRawCb(ctx, tmpBuf, tmpBufSize);
      break;
    }

    case VARIANT_FLOAT: {
      tmpBufSize = snprintf(tmpBuf, sizeof(tmpBuf) - 1, "%f", x -> valueAsFloat32);
      ctx -> writeRawCb(ctx, tmpBuf, tmpBufSize);
      break;
    }

    case VARIANT_DOUBLE: {
      tmpBufSize = snprintf(tmpBuf, sizeof(tmpBuf) - 1, "%lf", x -> valueAsFloat64);
      ctx -> writeRawCb(ctx, tmpBuf, tmpBufSize);
      break;
    }

    case VARIANT_BOOLEAN:   {
      if (x -> valueAsInt32) {
        EMIT_LITERAL("true");
      } else {
        EMIT_LITERAL("false");
      }
      break;
    }

    // ------------------------------------------------------------------------
    //                           Print string
    // ------------------------------------------------------------------------

    case VARIANT_STRING: {
      if (x -> flags & VARIANT_FLAG_ONE_CHARACTER) {
        // One character string.
        // Just put single char directly.
        ctx -> writeRawCb(ctx, &x -> valueAsChar, 1);

      } else {
        // Multicharacter string.
        // Decode string buffer first.
        Buffer_t *buf = (Buffer_t *) x -> value;
        String_t *str = (String_t *) buf -> bytesPtr;
        ctx -> writeRawCb(ctx, str -> text, str -> length);
      }

      break;
    }

    // ------------------------------------------------------------------------
    //                          Print array[]
    // ------------------------------------------------------------------------

    case VARIANT_ARRAY: {
      // Decode array from the variant box.
      Buffer_t *buf = x -> valueAsBufferPtr;
      Array_t *array = (Array_t *) buf -> bytesPtr;

      if (array -> innerType == 0) {
        // Generic array of variants - potentially complex boxes inside.
        // Track visited nodes during printing.
        if ((array -> itemsCnt > 0) &&
            (array -> items[0].flags & VARIANT_FLAG_NODE_VISITED)) {
          // Circular reference - array already printed.
          EMIT_LITERAL("<circular>");

        } else {
          // Array was not visited yet - print it now.
          EMIT_LITERAL("[");

          for (uint32_t idx = 0; idx < array -> itemsCnt; idx++) {
            // Separate items by comma: x1, x2, x3, ...
            if (idx > 0) {
              EMIT_LITERAL(", ");
            }

            // Print next item value and wrap into 'value' if needed.
            if ((array -> items[idx].type) == VARIANT_STRING) EMIT_LITERAL("'");
            __MOLD_PrintVariantInernal(ctx, &array -> items[idx]);
            if ((array -> items[idx].type) == VARIANT_STRING) EMIT_LITERAL("'");
          }

          EMIT_LITERAL("]");
        }

      } else {
        // Typed array - use general for driver.
        // Possible improvement: Don't duplicate the code.
        Variant_t oneItem;
        uint32_t idx;

        EMIT_LITERAL("[");

        void _printOneItem() {
          // Separate items by comma: x1, x2, x3, ...
          if (idx > 0) {
            EMIT_LITERAL(", ");
          }

          // Print next item value and wrap into 'value' if needed.
          if (oneItem.type == VARIANT_STRING) EMIT_LITERAL("'");
          __MOLD_PrintVariantInernal(ctx, &oneItem);
          if (oneItem.type == VARIANT_STRING) EMIT_LITERAL("'");
        }

        // Print all items one-by-one.
        __MOLD_ForDriver_IndexesAndValuesInArray(array, &idx, &oneItem, _printOneItem);
        EMIT_LITERAL("]");
      }

      break;
    }

    // ------------------------------------------------------------------------
    //                        Print key, value map{}
    // ------------------------------------------------------------------------

    case VARIANT_MAP: {
      // Decode map from the variant box.
      Buffer_t *buf = x -> valueAsBufferPtr;
      Map_t    *map = (Map_t *) buf -> bytesPtr;

      uint32_t bucketsUsedCnt = map -> bucketsUsedCnt;
      MapBucket_t *bucket     = map -> firstBucket;

      if (bucket && bucket -> key.flags & VARIANT_FLAG_NODE_VISITED) {
        EMIT_LITERAL("<circular>");

      } else {
        // Map was not visited yet - print it now.
        EMIT_LITERAL("{");

        for (uint32_t idx = 0; idx < bucketsUsedCnt; idx++) {
          // Separate key:value pairs by commas:
          // { 'key1': val1, 'key2': val2, ... }
          if (idx > 0 ) {
            EMIT_LITERAL(", ");
          }

          // Print key.
          EMIT_LITERAL("'");
          __MOLD_PrintVariantInernal(ctx, &bucket -> key);
          EMIT_LITERAL("': ");

          // Print value.
          if (bucket -> value.type == VARIANT_STRING) EMIT_LITERAL("'");
          __MOLD_PrintVariantInernal(ctx, &bucket -> value);
          if (bucket -> value.type == VARIANT_STRING) EMIT_LITERAL("'");

          // Go to next bucket if any.
          bucket = bucket -> nextBucket;
        }

        EMIT_LITERAL("}");
      }

      break;
    }

    case VARIANT_OBJECT: {
      // TODO: Fix printing "classProto" under VM.
      // Possible improvement: Print methods/className for objects?
      EMIT_LITERAL("<object>");
      break;
    }

    default: {
      __MOLD_PrintErrorAndDie_badType();
    }
  }

  #undef EMIT_LITERAL
}

void __MOLD_PrintToFile_variant(FILE *f, Variant_t *x) {
  __MOLD_PrintContext_t ctx = { 0 };

  ctx.f = f;
  ctx.writeRawCb = __MOLD_WriteRawToFileCallback;

  __MOLD_PrintVariantInernal(&ctx, x);
  __MOLD_ClenUpAfterPrint(x);
}

Variant_t __MOLD_PrintToString_variant(Variant_t *x) {
  __MOLD_PrintContext_t ctx = { 0 };

  ctx.buf         = calloc(__MOLD_DEFAULT_PRINT_BUFFER_SIZE, 1);
  ctx.bufCapacity = __MOLD_DEFAULT_PRINT_BUFFER_SIZE;
  ctx.writeRawCb  = __MOLD_WriteRawToBufferCallback;

  __MOLD_PrintVariantInernal(&ctx, x);
  __MOLD_ClenUpAfterPrint(x);

  // Possible improvement: Avoid buffer copy?
  // Possible improvement: Pass result variant via pointer?
  Variant_t rv = __MOLD_VariantStringCreateFromCString(ctx.buf);

  free(ctx.buf);

  return rv;
}

void __MOLD_PrintFormat(const char *fmt, ...) {
  va_list ptr;
  va_start(ptr, fmt);

  while (*fmt) {
    switch (*fmt) {
      // Possible improvement: Better tokens set?
      case 's':
      case 'v': __MOLD_Print_variant(va_arg(ptr, Variant_t *)); break;
      case 'i': __MOLD_Print_int32  (va_arg(ptr, uint32_t));    break;
      case 'I': __MOLD_Print_int64  (va_arg(ptr, uint64_t));    break;
      case 'f': __MOLD_Print_float64(va_arg(ptr, float64_t));   break;
      case 'b': __MOLD_Print_bool32 (va_arg(ptr, bool32_t));    break;
      case '!': __MOLD_Print_EOL();                             break;
      case '~': break;

      default: {
        fprintf(stderr, "runtime error: unhandled print fmt token '%c'", *fmt);
        abort();
      }
    }

    // Possible improvement: Simplify it?
    if ((fmt[0] != '~') &&
        (fmt[0] != '!') &&
        (fmt[1] !=  0 ) &&
        (fmt[1] != '~') &&
        (fmt[1] != '!')) {
      __MOLD_Print_space();
    }

    fmt++;
  }
}

Variant_t __MOLD_BuildString(const char *fmt, ...) {
  va_list ptr;
  va_start(ptr, fmt);

  // TODO: Optimize it.
  // TODO: Reuse code from __MOLD_PrintFormat.
  Variant_t rv = __MOLD_VariantStringCreateFromCString("");

  while (*fmt) {
    Variant_t nextItem;

    switch (*fmt) {
      // Possible improvement: Better tokens set?
      case 's':
      case 'v': nextItem = __MOLD_Str(va_arg(ptr, Variant_t *)); break;
      case 'i': nextItem = __MOLD_VariantCreateFrom_int32(va_arg(ptr, uint32_t)); break;
      case 'I': nextItem = __MOLD_VariantCreateFrom_int64(va_arg(ptr, uint64_t)); break;
      case 'f': nextItem = __MOLD_VariantCreateFrom_float64(va_arg(ptr, float64_t)); break;
      case 'b': nextItem = __MOLD_VariantCreateFrom_bool32(va_arg(ptr, bool32_t)); break;

      default: {
        fprintf(stderr, "runtime error: unhandled print fmt token '%c' (string mode)", *fmt);
        abort();
      }
    }

    nextItem = __MOLD_Str(&nextItem);
    __MOLD_VariantStringJoin(&rv, &rv, &nextItem);

    fmt++;
  }

  return rv;
}

// -----------------------------------------------------------------------------
//         Helper wrappers to print single variable to the stdout
// -----------------------------------------------------------------------------

void __MOLD_Print_space() { printf(" "); }
void __MOLD_Print_EOL()   { printf("\n"); }

void __MOLD_Print_string(Variant_t *x) { __MOLD_Print_variant(x); }
void __MOLD_Print_int32(int32_t x)     { printf("%d", x); }
void __MOLD_Print_int64(int64_t x)     { printf("%"PRId64, x); }
void __MOLD_Print_float64(float64_t x) { printf("%lf", x); }
void __MOLD_Print_bool32(int32_t x)    { printf(x ? "true" : "false"); }

void __MOLD_Print_char(char x) {
  fputc(x, stdout);
}

void __MOLD_Print_raw(const char *buf, uint32_t bufSize) {
  fwrite(buf, bufSize, 1, stdout);
}

void __MOLD_Print_variant(Variant_t *x) {
  __MOLD_PrintToFile_variant(stdout, x);
}

void __MOLD_VariantPrint(Variant_t *x) { __MOLD_Print_variant(x); }

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantArray.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <string.h>


// #############################################################################
//                             Create functions
// #############################################################################

// -----------------------------------------------------------------------------
// Create new empty array.
//
// Pseudo code:
//   dst = []
//
// Parameters:
//   dst - pointer, where to store new array (OUT)
//
// -----------------------------------------------------------------------------

void __MOLD_VariantArrayCreate(Variant_t *dst)
{
  __MOLD_VariantDestroy(dst);

  // Possible improvment: Reuse existing buffer if possible?
  dst -> type  = VARIANT_ARRAY;
  dst -> flags = 0;
  dst -> valueAsBufferPtr = __MOLD_MemoryAlloc(64);
}

// -----------------------------------------------------------------------------
// Create array and init it with items from another one.
//
// WARNING: Only shallow copy is performed.
//
// Pseudo code:
//   dst    = []
//   dst[0] = initArray[0]
//   dst[1] = initArray[1]
//   ...
//   dst[n] = initArray[n]
//
// Parameters:
//   dst         - pointer, where to store new array (OUT),
//   initArray[] - array of items to be shallow copied into new array (IN).
// -----------------------------------------------------------------------------

void __MOLD_VariantArrayCreateFromInitList(Variant_t *dst, const Variant_t *initArray)
{
  ASSERT_VARIANT_PTR_ARRAY(initArray);

  __MOLD_VariantArrayCreate(dst);

  Variant_t oneItem;
  uint32_t idx;

  void _copyOneItem()
  {
    __MOLD_VariantStoreAtIndex_variant(dst, idx, &oneItem);
  }

  __MOLD_ForDriver_IndexesAndValuesInArray(
    (Array_t *) initArray -> valueAsBufferPtr -> bytesPtr,
    &idx,
    &oneItem,
    &_copyOneItem
  );

  ASSERT_VARIANT_PTR_ARRAY(dst);
}

// -----------------------------------------------------------------------------
// Release the array and it's item recursively.
// This call tells, that the array is not needed anymore and may be freed.
//
// Pseudo code:
//   delete x
//
// Parameters:
//   x[] - array to be freed (IN).
// -----------------------------------------------------------------------------

void __MOLD_VariantArrayRelease(Variant_t *x)
{
  ASSERT_VARIANT_PTR_ARRAY(x);

  if (x -> type != VARIANT_UNDEFINED)
  {
    // Release array items if needed.
    if (x -> valueAsBufferPtr -> refCnt == 1)
    {
      // We're going to free the whole array.
      // Release stored items first.
      Array_t *array = (Array_t *) (x -> valueAsBufferPtr -> bytesPtr);

      if (array -> innerType == 0)
      {
        // Array of variants.
        // Destroy stored items one-by-one.
        for (uint32_t idx = 0; idx < array -> itemsCnt; idx++)
        {
          __MOLD_VariantDestroy(array -> items + idx);
        }
      }
    }

    // Release the array buffer itself.
    __MOLD_MemoryRelease(x -> valueAsBufferPtr);

    x -> valueAsBufferPtr = NULL;
    x -> type             = VARIANT_UNDEFINED;
  }
}

// #############################################################################
//                               Load functions
// #############################################################################

// -----------------------------------------------------------------------------
// Load value stored at given index.
//
// Pseudo code:
//  rv = box[idx]
//
// Parameters:
//   rv  - buffer, where to store loaded item (OUT),
//   box - source array (IN),
//   idx - item array to be loaded (IN).
//
// Returns:
//   Value stored at given index.
// -----------------------------------------------------------------------------

void __MOLD_VariantLoadFromIndexAndAssign(Variant_t *rv,
                                          const Variant_t *box,
                                          int32_t idx)
{
  ASSERT_VARIANT_PTR_ANY(box);
  ASSERT_VARIANT_PTR_ANY(rv);

  __MOLD_VariantDestroy(rv);

  // TODO: Optimize it.
  // Set result to undefined before find.
  memset(rv, 0, sizeof(Variant_t));

  if (idx < 0)
  {
    __MOLD_PrintErrorAndDie_negativeIndex();
  }

  switch (box -> type)
  {
    case VARIANT_ARRAY:
    {
      ASSERT_VARIANT_PTR_ARRAY(box);

      Buffer_t *buf = box -> valueAsBufferPtr;
      Array_t  *array = (Array_t *) buf -> bytesPtr;

      if (idx < array -> itemsCnt)
      {
        if (array -> innerType == 0)
        {
          // Array of variants.
          memcpy(rv, array -> items + idx, sizeof(Variant_t));

          // Increse reference counter for the just loaded item.
          __MOLD_VariantAddRef(rv);
        }
        else
        {
          // Array of primitives.
          rv -> type = array -> innerType;

          switch (array -> itemSize)
          {
            // TODO: Get it work with non-integer too.
            case 0: rv -> valueAsInt64 = ((int8_t *)  array -> items)[idx]; break;
            case 1: rv -> valueAsInt64 = ((int16_t *) array -> items)[idx]; break;
            case 2: rv -> valueAsInt64 = ((int32_t *) array -> items)[idx]; break;
            case 3: rv -> valueAsInt64 = ((int64_t *) array -> items)[idx]; break;
          }
        }
      }

      break;
    }

    case VARIANT_STRING:
    {
      ASSERT_VARIANT_PTR_STRING(box);

      if (box -> flags & VARIANT_FLAG_ONE_CHARACTER)
      {
        // One character string - just return itself.
        memcpy(rv, box, sizeof(Variant_t));
      }
      else
      {
        // Multiple character string.
        Buffer_t *buf = box -> valueAsBufferPtr;
        String_t *str = (String_t *) buf -> bytesPtr;

        if (idx < str -> length)
        {
          rv -> type  = VARIANT_STRING;
          rv -> flags = VARIANT_FLAG_ONE_CHARACTER;
          rv -> value = str -> text[idx];
        }
      }

      break;
    }

    default:
    {
      __MOLD_PrintErrorAndDie_arrayOrStringExpected();
    }
  }

  ASSERT_VARIANT_PTR_ANY(rv);
}

void __MOLD_VariantLoadFromIndexAndAssign_variant(Variant_t *rv,
                                                  const Variant_t *box,
                                                  int32_t idx) {
  __MOLD_VariantLoadFromIndexAndAssign(rv, box, idx);
}

void __MOLD_VariantLoadFromIndexAndAssign_string(Variant_t *rv,
                                                 const Variant_t *box,
                                                 int32_t idx) {
  __MOLD_VariantLoadFromIndexAndAssign(rv, box, idx);
}

Variant_t __MOLD_VariantLoadFromIndex(const Variant_t *box,
                                              int32_t idx) {
  Variant_t rv = { 0 };
  __MOLD_VariantLoadFromIndexAndAssign(&rv, box, idx);
  return rv;
}

Variant_t __MOLD_VariantLoadFromIndex_variant(const Variant_t *box, int32_t idx) {
  return __MOLD_VariantLoadFromIndex(box, idx);
}

Variant_t __MOLD_VariantLoadFromIndex_string (const Variant_t *box, int32_t idx) {
  return __MOLD_VariantLoadFromIndex_variant(box, idx);
}

int32_t __MOLD_VariantLoadFromIndex_int32(const Variant_t *box, int32_t idx) {
  return __MOLD_VariantLoadFromIndex_variant(box, idx).valueAsInt32;
}

int64_t __MOLD_VariantLoadFromIndex_int64(const Variant_t *box, int32_t idx) {
  return __MOLD_VariantLoadFromIndex_variant(box, idx).valueAsInt64;
}

bool32_t __MOLD_VariantLoadFromIndex_bool32(const Variant_t *box, int32_t idx) {
  return __MOLD_VariantLoadFromIndex_variant(box, idx).valueAsInt32;
}

float64_t __MOLD_VariantLoadFromIndex_float64(const Variant_t *box, int32_t idx) {
  return __MOLD_VariantLoadFromIndex_variant(box, idx).valueAsFloat64;
}

// #############################################################################
//                             Store functions
// #############################################################################

// ----------------------------------------------------------------------------
// Store one variant item in the array.
//
// Pseudo code:
//   x[i] = value
//
// Parameters:
//   box   - array to modify (Variant_t) (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (Variant_t) (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtIndex_variant(Variant_t *box,
                                        int32_t idx,
                                        Variant_t *value)
{
  ASSERT_VARIANT_PTR_ARRAY(box);
  ASSERT_VARIANT_PTR_ANY(value);

  // TODO: Handle VARIANT_FLAG_DUPLICATE_ON_FIRST_WRITE?
  Buffer_t *buf   = box -> valueAsBufferPtr;
  Array_t  *array = (Array_t *) buf -> bytesPtr;

  if (idx < 0)
  {
    __MOLD_PrintErrorAndDie_negativeIndex();
  }

  if (idx >= array -> itemsCnt)
  {
    array -> itemsCnt = idx + 1;

    // Check is there space for new item
    int capacityNeeded = sizeof(Array_t) + array -> itemsCnt * sizeof(Variant_t);

    if (capacityNeeded > buf -> capacity)
    {
      // Array buffer is too small.
      // Increase buffer size.
      __MOLD_MemoryRealloc(buf, capacityNeeded);
      array = (Array_t *) buf -> bytesPtr;
    }
  }

  // Increase reference counter for the new stored item.
  __MOLD_VariantAddRef(value);

  // Destroy old value if any.
  __MOLD_VariantDestroy(&array -> items[idx]);

  // Put new item into array slot
  array -> items[idx] = *value;

  ASSERT_VARIANT_PTR_ARRAY(box);
  ASSERT_VARIANT_PTR_ANY(value);
}

// ----------------------------------------------------------------------------
// Store one string item in the array.
//
// Pseudo code:
//   x[i] = "text"
//
// Parameters:
//   box   - array to modify (Variant_t) (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (Variant_t) (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtIndex_string(Variant_t *box, int32_t idx, Variant_t *value)
{
  return __MOLD_VariantStoreAtIndex_variant(box, idx, value);
}

// ----------------------------------------------------------------------------
// Store one int32 value in the array.
//
// Pseudo code:
//   x[i] = <32-bit integer>
//
// Parameters:
//   box   - array to modify (Variant_t) (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (Variant_t) (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtIndex_int32(Variant_t *box, int32_t idx, int32_t value)
{
  Variant_t valueAsVariant =
  {
    type: VARIANT_INTEGER,
    valueAsInt64: value,
    flags: 0
  };

  __MOLD_VariantStoreAtIndex_variant(box, idx, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Store one int64 value in the array.
//
// Pseudo code:
//   x[i] = <64-bit integer>
//
// Parameters:
//   box   - array to modify (Variant_t) (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (Variant_t) (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtIndex_int64(Variant_t *box, int32_t idx, int64_t value)
{
  Variant_t valueAsVariant =
  {
    type: VARIANT_INTEGER,
    valueAsInt64: value,
    flags: 0
  };

  __MOLD_VariantStoreAtIndex_variant(box, idx, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Store one float64 (double precision) item in the array.
//
// Pseudo code:
//   x[i] = 3.14
//
// Parameters:
//   box   - array to modify (Variant_t) (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (Variant_t) (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtIndex_float64(Variant_t *box, int32_t idx, float64_t value)
{
  Variant_t valueAsVariant =
  {
    type: VARIANT_DOUBLE,
    valueAsFloat64: value,
    flags: 0
  };

  __MOLD_VariantStoreAtIndex_variant(box, idx, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Store one bool32 item in the array.
//
// Pseudo code:
//   x[i] = true
//
// Parameters:
//   box   - array to modify (Variant_t) (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (Variant_t) (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtIndex_bool32(Variant_t *box, int32_t idx, bool32_t value)
{
  Variant_t valueAsVariant =
  {
    type: VARIANT_BOOLEAN,
    valueAsInt64: value,
    flags: 0
  };

  __MOLD_VariantStoreAtIndex_variant(box, idx, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Append variant item to the end of the array.
// After that, array size is increased by one.
//
// 1, 2, 3, 4, 5, x
//                ^
//                New item goes here
//
// Pseudo code:
//   box[box.length - 1] = value
//
// Parameters:
//   box   - array to modify (IN),
//   idx   - index, where to store item (IN),
//   value - value to store (IN).
// ----------------------------------------------------------------------------

void __MOLD_ArrayInsertAfterLast(Variant_t *box, Variant_t *value)
{
  ASSERT_VARIANT_PTR_ARRAY(box);
  ASSERT_VARIANT_PTR_ANY(value);

  if (box -> type != VARIANT_ARRAY)
  {
    __MOLD_PrintErrorAndDie_arrayExpected();
  }

  Buffer_t *buf   = box -> valueAsBufferPtr;
  Array_t  *array = (Array_t *) buf -> bytesPtr;

  __MOLD_VariantStoreAtIndex_variant(box, array -> itemsCnt, value);
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantMap.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <string.h>


// #############################################################################
//                              Internal helpers
// #############################################################################

// ----------------------------------------------------------------------------
// Calculate string hash using DJB2 algorithm.
// http://www.cse.yorku.ca/~oz/hash.html
//
// Parameters:
//   x - string to hash (IN)
//
// RETURNS: hash value.
// ----------------------------------------------------------------------------

uint32_t __MOLD_hashDJB2(const Variant_t *x)
{
  ASSERT_VARIANT_PTR_STRING(x);

  uint32_t hash = 5381;
  uint32_t c;

  if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    // One character string.
    // One hard-coded cycle is needed.
    hash = ((hash << 5) + hash) + x -> valueAsUInt8;
  }
  else
  {
    // Multi character string.
    // Decode raw bytes buffer first.
    const char *str = ((String_t *) (x -> valueAsBufferPtr -> bytesPtr)) -> text;

    // Perform one cycle per each ascii character.
    while ((c = *str++))
    {
      // hash * 33 + c
      hash = ((hash << 5) + hash) + c;
    }
  }

  return hash;
}

// ----------------------------------------------------------------------------
// Internal helper to find bucket where given key should be stored.
// Used internally by load/store calls.
//
// If collision is detected function finds out the first available bucket
// using "open address" algorithm.
//
// Found bucket may be both occupied (set) or empty depending on map content.
//
// Parameters:
//   box{} - map to serach (IN)
//   key   - key string to find (IN)
//
// RETURNS: Pointer to bucket, where given key should be stored.
// ----------------------------------------------------------------------------

static MapBucket_t *__MOLD_FindMapBucketByKey(const Variant_t *box,
                                              const Variant_t *key)
{
  if ((box -> type != VARIANT_MAP) && (box -> type != VARIANT_OBJECT))
  {
    __MOLD_PrintErrorAndDie_mapOrObjectExpected();
  }

  if (key -> type != VARIANT_STRING)
  {
    __MOLD_PrintErrorAndDie_stringKeyExpected();
  }

  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
  ASSERT_VARIANT_PTR_STRING(key);

  // Decode map.
  Map_t *map = (Map_t *) box -> valueAsBufferPtr -> bytesPtr;

  assert(map != NULL);
  assert((uint64_t) map != 0xdeadbeef);

  // Calculate key hash.
  uint32_t keyHash = __MOLD_hashDJB2(key);

  // Find bucket.
  uint32_t bucketIdx = keyHash % map -> bucketsCnt;

  MapBucket_t *bucket = &(map -> buckets[bucketIdx]);

  // Skip current bucket as long as:
  // - bucket is occupied,
  // - and bucket has already different key as we're searching for.
  //
  // Stop condition for load:
  // - if bucket is free - we stop here, key not found,
  // - if bucket has the same key - matched, key is found.
  //
  // Stop condition for store:
  // - if bucket is free - we stop here, and put new key here from the scratch,
  // - if bucket has the same key - we had collision and go on to next one.
  //
  // Note: See hash key collision algorithm: "open address".

  while ((bucket -> key.type != VARIANT_UNDEFINED) &&
         (!__MOLD_cmp_eq_string(key, &bucket -> key)))
  {
    bucketIdx = (bucketIdx + 1) % map -> bucketsCnt;
    bucket    = &(map -> buckets[bucketIdx]);
  }

  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
  ASSERT_VARIANT_PTR_ANY(key);

  return bucket;
}

// ----------------------------------------------------------------------------
// Resize map twice if more than half of buckets are occupied.
// Do nothing otherwise.
//
// Parameters:
//   box{} - map resize (IN/OUT)
// ----------------------------------------------------------------------------

static void __MOLD_ResizeMapIfNeeded(Variant_t *box)
{
  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);

  // Decode map.
  Map_t *map = (Map_t *) box -> valueAsBufferPtr -> bytesPtr;

  // Resize map if needed.
  if (map -> bucketsUsedCnt > map -> bucketsCnt / 2)
  {
    Variant_t newMap = { 0 };

    __MOLD_VariantMapCreateWithCustomSize(&newMap, map -> bucketsCnt * 2);

    MapBucket_t *bucket = map -> firstBucket;

    while (bucket != NULL)
    {
      __MOLD_VariantStoreAtKey_variant(&newMap, &bucket -> key, &bucket -> value);
      // Key and values are already referenced after previous insert.
      // Avoid increasing referencing twice and then memory leak.
      __MOLD_VariantDestroy(&bucket -> key);
      __MOLD_VariantDestroy(&bucket -> value);

      // Go to next bucket.
      bucket = bucket -> nextBucket;
    }

    if (box -> type == VARIANT_OBJECT)
    {
      // TODO: Clean up this mess.
      // Clone vtable if object.
      ((Object_t *) (newMap.valueAsBufferPtr -> bytesPtr)) -> vtable =
      ((Object_t *) (map)) -> vtable;
    }

    // TODO: Simplify it.
    // TODO: Clean up this mess.
    // Swap buffer bytes.
    void *tmpBytesPtr = box -> valueAsBufferPtr -> bytesPtr;
    box -> valueAsBufferPtr -> bytesPtr = newMap.valueAsBufferPtr -> bytesPtr;
    newMap.valueAsBufferPtr -> bytesPtr = tmpBytesPtr;

    // Release old buffer.
    __MOLD_MemoryRelease(newMap.valueAsBufferPtr);
  }

  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
}

// #############################################################################
//                              Create functions
// #############################################################################

// ----------------------------------------------------------------------------
// Create new empty map with desired capacity.
//
// Pseudocode:
//   dst = new map(size)
//
// Parameters:
//   dst        - new allocated map wrapped into Variant container (OUT),
//   bucketsCnt - initial number of buckets (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantMapCreateWithCustomSize(Variant_t *dst, uint32_t bucketsCnt)
{
  ASSERT_VARIANT_PTR_ANY(dst);

  __MOLD_VariantDestroy(dst);

  Buffer_t *buf = __MOLD_MemoryAlloc(sizeof(Map_t) + bucketsCnt * sizeof(MapBucket_t));

  Map_t *map = (Map_t *) buf -> bytesPtr;

  map -> bucketsCnt = bucketsCnt;

  dst -> type             = VARIANT_MAP;
  dst -> flags            = 0;
  dst -> valueAsBufferPtr = buf;

  ASSERT_VARIANT_PTR_MAP(dst);
}

// ----------------------------------------------------------------------------
// Create new, empty map.
//
// Pseudo code:
//   dst = {}
//
// Parameters:
//   dst - new allocated map wrapped into Variant container (OUT).
// ----------------------------------------------------------------------------

void __MOLD_VariantMapCreate(Variant_t *dst)
{
  __MOLD_VariantMapCreateWithCustomSize(dst, VARIANT_MAP_DEFAULT_BUCKETS_CNT);
}

// ----------------------------------------------------------------------------
// Create new map and init it using keys[] and values[] arrays.
//
// Pseudo code:
//   dst = new map()
//   dst{key[0]} = value[0]
//   dst{key[1]} = value[1]
//   ...
//   dst{key[n]} = value[n]
//
// Parameters:
//   dst      - new allocated map wrapped into Variant container (OUT),
//   keys[]   - array of keys to insert (IN),
//   values[] - array of values to insert (IN).
// ----------------------------------------------------------------------------

void __MOLD_VariantMapCreateFromInitList(Variant_t *dst,
                                         const Variant_t *keys,
                                         const Variant_t *values)
{
  ASSERT_VARIANT_PTR_ANY(dst);
  ASSERT_VARIANT_PTR_ARRAY(keys);
  ASSERT_VARIANT_PTR_ARRAY(values);

  __MOLD_VariantMapCreate(dst);

  Variant_t oneKey;
  Variant_t oneValue;
  uint32_t  idx;

  void _copyOneKeyValuePair()
  {
    oneValue = __MOLD_VariantLoadFromIndex(values, idx);
    __MOLD_VariantStoreAtKey_variant(dst, &oneKey, &oneValue);
  }

  __MOLD_ForDriver_IndexesAndValuesInArray(
    (Array_t *) keys -> valueAsBufferPtr -> bytesPtr,
    &idx,
    &oneKey,
    &_copyOneKeyValuePair
  );

  ASSERT_VARIANT_PTR_ARRAY(keys);
  ASSERT_VARIANT_PTR_ARRAY(values);
  ASSERT_VARIANT_PTR_MAP(dst);
}

// -----------------------------------------------------------------------------
// Release the maps and it's item recursively.
// This call tells, that the map is not needed anymore and may be freed.
//
// Pseudo code:
//   delete x
//
// Parameters:
//   x{} - map to be freed (IN).
// -----------------------------------------------------------------------------

void __MOLD_VariantMapRelease(Variant_t *x)
{
  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(x);

  // Release array items if needed.
  if (x -> valueAsBufferPtr -> refCnt == 1)
  {
    // We're going to free the whole map.
    // Release stored keys and items first.
    Map_t *map = (Map_t *) (x -> valueAsBufferPtr -> bytesPtr);

    MapBucket_t *bucket = map -> firstBucket;

    while (bucket != NULL)
    {
      __MOLD_VariantDestroy(&bucket -> key);
      __MOLD_VariantDestroy(&bucket -> value);
      bucket = bucket -> nextBucket;
    }
  }

  // Release the map buffer itself.
  __MOLD_MemoryRelease(x -> valueAsBufferPtr);

  x -> type = VARIANT_UNDEFINED;
}

// #############################################################################
//                           Load from key functions
// #############################################################################

// ----------------------------------------------------------------------------
// Load value stored at given key.
//
// Pseudo code:
//   rv = box{key}
//
// Parameters:
//   rv    - pointer, where to store loaded value (OUT)
//   box{} - map where we searching for key (IN)
//   key   - key to find (IN)
//
// Returns:
//   Value stored at key.
// ----------------------------------------------------------------------------

void __MOLD_VariantLoadFromKeyAndAssign_variant(Variant_t *rv,
                                                Variant_t *box,
                                                Variant_t *key)
{
  ASSERT_VARIANT_PTR_ANY(rv);
  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
  ASSERT_VARIANT_PTR_STRING(key);

  __MOLD_VariantDestroy(rv);

  // Find bucket.
  MapBucket_t *bucket = __MOLD_FindMapBucketByKey(box, key);

  // Load bucket value if key is found.
  if (bucket -> key.type != VARIANT_UNDEFINED)
  {
    memcpy(rv, &bucket -> value, sizeof(Variant_t));

    // Increase reference counter for just loaded item.
    __MOLD_VariantAddRef(rv);

  }
  else
  {
    // Key not found - set result to undefined.
    memset(rv, 0, sizeof(Variant_t));
  }

  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
  ASSERT_VARIANT_PTR_STRING(key);
  ASSERT_VARIANT_PTR_ANY(rv);
}

Variant_t __MOLD_VariantLoadFromKey_variant(Variant_t *box,
                                            Variant_t *key) {
  Variant_t rv = { 0 };
  __MOLD_VariantLoadFromKeyAndAssign_variant(&rv, box, key);
  return rv;
}

// ----------------------------------------------------------------------------
// Load value stored at given key.
//
// Pseudo code:
//   ... = box{key}
//
// Parameters:
//   box{} - map where we searching for key (IN)
//   key   - key to find (IN)
//
// Returns:
//   - value stored at key if found,
//   - undefined variant otherwise.
// ----------------------------------------------------------------------------

Variant_t __MOLD_VariantLoadFromKey_string(Variant_t *box, Variant_t *key)
{
  return __MOLD_VariantLoadFromKey_variant(box, key);
}

void __MOLD_VariantLoadFromKeyAndAssign_string(Variant_t *rv,
                                               Variant_t *box,
                                               Variant_t *key) {
  __MOLD_VariantLoadFromKeyAndAssign_variant(rv, box, key);
}

// #############################################################################
//                           Store at key functions
// #############################################################################

// ----------------------------------------------------------------------------
// Store any value at given key.
//
// Pseudo code:
//   box{key} = value
//
// Parameters:
//   box{} - map, which we're going to modify (IN)
//   key   - string key, where we want to store value (IN)
//   value - value to store (IN)
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtKey_variant(Variant_t *box,
                                      const Variant_t *key,
                                      const Variant_t *value)
{
  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
  ASSERT_VARIANT_PTR_STRING(key);
  ASSERT_VARIANT_PTR_ANY(value);

  // Increase reference counter for the new stored value.
  __MOLD_VariantAddRef(value);

  // Find bucket.
  MapBucket_t *bucket = __MOLD_FindMapBucketByKey(box, key);

  // Conditional: Set new key if bucket is filled for the first time.
  if (bucket -> key.type == VARIANT_UNDEFINED)
  {
    // Set new key.
    bucket -> key = *key;

    // Increase reference counter for the key.
    __MOLD_VariantAddRef(key);

    // Decode map.
    Map_t *map = (Map_t *) box -> valueAsBufferPtr -> bytesPtr;

    // Count number of items stored in the map.
    map -> bucketsUsedCnt++;

    // Updated pointers to first/last buckets for forEach loops.
    if (map -> firstBucket == NULL)
    {
      map -> firstBucket = bucket;
    }

    if (map -> lastBucket != NULL)
    {
      map -> lastBucket -> nextBucket = bucket;
    }

    map -> lastBucket = bucket;
  }
  else
  {
    // Destroy previous value.
    __MOLD_VariantDestroy(&bucket -> value);
  }

  // Always: set new value at bucket.
  memcpy(&(bucket -> value), value, sizeof(Variant_t));

  // Resize map if needed.
  __MOLD_ResizeMapIfNeeded(box);

  ASSERT_VARIANT_PTR_MAP_OR_OBJECT(box);
  ASSERT_VARIANT_PTR_STRING(key);
  ASSERT_VARIANT_PTR_ANY(value);
}

// ----------------------------------------------------------------------------
// Store string value at given key.
//
// Pseudo code:
//   box{key} = 'text'
//
// Parameters:
//   box{} - map, which we're going to modify (IN)
//   key   - string key, where we want to store value (IN)
//   value - string value to store (IN)
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtKey_string(Variant_t *box,
                                     const Variant_t *key,
                                     const Variant_t *value)
{
  __MOLD_VariantStoreAtKey_variant(box, key, value);
}

// ----------------------------------------------------------------------------
// Store int32 value at given key.
//
// Pseudo code:
//   box{key} = <32-bit integer>
//
// Parameters:
//   box{} - map, which we're going to modify (IN)
//   key   - string key, where we want to store value (IN)
//   value - int32 value to store (IN)
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtKey_int32(Variant_t *box,
                                    const Variant_t *key,
                                    int32_t value)
{
  Variant_t valueAsVariant = { type: VARIANT_INTEGER, valueAsInt64: value, flags: 0 };
  __MOLD_VariantStoreAtKey_variant(box, key, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Store int64 value at given key.
//
// Pseudo code:
//   box{key} = <64-bit integer>
//
// Parameters:
//   box{} - map, which we're going to modify (IN)
//   key   - string key, where we want to store value (IN)
//   value - int64 value to store (IN)
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtKey_int64(Variant_t *box,
                                    const Variant_t *key,
                                    int64_t value)
{
  Variant_t valueAsVariant = { type: VARIANT_INTEGER, valueAsInt64: value, flags: 0 };
  __MOLD_VariantStoreAtKey_variant(box, key, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Store float64 value at given key.
//
// Pseudo code:
//   box{key} = 3.14
//
// Parameters:
//   box{} - map, which we're going to modify (IN)
//   key   - string key, where we want to store value (IN)
//   value - int64 value to store (IN)
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtKey_float64(Variant_t *box,
                                      const Variant_t *key,
                                      float64_t value)
{
  Variant_t valueAsVariant = { type: VARIANT_DOUBLE, valueAsFloat64: value, flags: 0 };
  __MOLD_VariantStoreAtKey_variant(box, key, &valueAsVariant);
}

// ----------------------------------------------------------------------------
// Store bool32 value at given key.
//
// Pseudo code:
//   box{key} = true
//
// Parameters:
//   box{} - map, which we're going to modify (IN)
//   key   - string key, where we want to store value (IN)
//   value - bool32 value to store (IN)
// ----------------------------------------------------------------------------

void __MOLD_VariantStoreAtKey_bool32(Variant_t *box,
                                     const Variant_t *key,
                                     bool32_t value)
{
  Variant_t valueAsVariant = { type: VARIANT_BOOLEAN, valueAsInt64: value, flags: 0 };
  __MOLD_VariantStoreAtKey_variant(box, key, &valueAsVariant);
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantObject.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <string.h>


void __MOLD_VariantObjectCreate(Variant_t *dst, void **vtable)
{
  __MOLD_VariantMapCreate(dst);

  dst -> type = VARIANT_OBJECT;

  Object_t *obj = (Object_t *) dst -> valueAsBufferPtr -> bytesPtr;
  obj -> vtable = vtable;
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Original file: >>> MoldVariantString.c <<<
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/**************************************************************************/
/* This file is part of Mold project.                                     */
/* Copyright (C) 2015, 2022 Sylwester Wysocki <sw143@wp.pl>               */
/*                                                                        */
/* This program is free software: you can redistribute it and/or modify   */
/* it under the terms of the GNU General Public License as published by   */
/* the Free Software Foundation, either version 3 of the License, or      */
/* (at your option) any later version.                                    */
/*                                                                        */
/* This program is distributed in the hope that it will be useful,        */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of         */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
/* GNU General Public License for more details.                           */
/*                                                                        */
/* You should have received a copy of the GNU General Public License      */
/* along with this program. If not, see <http://www.gnu.org/licenses/>    */
/*                                                                        */
/**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <inttypes.h>


// -----------------------------------------------------------------------------
// Create new string and init it from C string buffer.
//
// Pseudo code:
// ... = new string("text")
//
// Parameters:
//   text - pointer to the zero terminated C string (IN).
//
// Returns:
//   New allocated string set to given text wrapped into Variant container.
// -----------------------------------------------------------------------------

Variant_t __MOLD_VariantStringCreateFromCString(const char *text)
{
  Variant_t rv = { VARIANT_UNDEFINED };

  if (text)
  {
    uint32_t textLen = strlen(text);
    Buffer_t *buf    = __MOLD_MemoryAlloc(textLen + 1);
    String_t *str    = (String_t *) buf -> bytesPtr;

    memcpy(str -> text, text, textLen);

    str -> length = textLen;

    rv.type             = VARIANT_STRING;
    rv.valueAsBufferPtr = buf;
  }

  ASSERT_VARIANT_PTR_STRING(&rv);

  return rv;
}

// -----------------------------------------------------------------------------
// Release the string.
// This call tells, that the string is not needed anymore and may be freed.
//
// Pseudo code:
//   delete x
//
// Parameters:
//   x - string to be freed (IN).
// -----------------------------------------------------------------------------

void __MOLD_VariantStringRelease(Variant_t *x)
{
  ASSERT_VARIANT_PTR_STRING(x);

  // String - possible complex or primitive.
  if (!(x -> flags & VARIANT_FLAG_ONE_CHARACTER))
  {
    // Multi-character string.
    // Release the buffer.
    __MOLD_MemoryRelease(x -> valueAsBufferPtr);
  }
}

// -----------------------------------------------------------------------------
// Compare two strings (EQual).
//
// Pseudo code:
// ... = (x == y)
//
// Parameters:
//   x - the first string to compare (IN),
//   y - second string to compare (IN).
//
// Returns:
//   1 if string are equal,
//   0 otherwise.
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_eq_string(const Variant_t *x, const Variant_t *y)
{
  ASSERT_VARIANT_PTR_STRING(x);
  ASSERT_VARIANT_PTR_STRING(y);

  bool32_t rv = 0;

  if (x -> valueAsInt64 == y -> valueAsInt64) {
    // Both string uses the same buffer or stores the same
    // single character.
    // We still can't say anything if two strings use different
    // buffers. Two different buffers may store the same string created
    // at runtime.
    //
    rv = 1;
  }
  else if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    // CHAR eq ?
    if (y -> flags & VARIANT_FLAG_ONE_CHARACTER)
    {
      // CHAR eq CHAR
      rv = (x -> value == y -> value);
    }
    else
    {
      // CHAR eq STRING
      Buffer_t *yBuf = (Buffer_t *) y -> value;
      String_t *yStr = (String_t *) yBuf -> bytesPtr;
      rv = (yStr -> length == 1) && (yStr -> text[0] == x -> value);
    }
  }
  else
  {
    // STRING eq ?
    Buffer_t *xBuf = (Buffer_t *) x -> value;
    String_t *xStr = (String_t *) xBuf -> bytesPtr;

    if (y -> flags & VARIANT_FLAG_ONE_CHARACTER)
    {
      // STRING eq CHAR
      rv = (xStr -> length == 1) && (xStr -> text[0] == y -> value);
    }
    else
    {
      // STRING eq STRING
      Buffer_t *yBuf = (Buffer_t *) y -> value;
      String_t *yStr = (String_t *) yBuf -> bytesPtr;

      rv = (xStr -> length == yStr -> length) &&
           (memcmp(xStr -> text, yStr -> text, xStr -> length) == 0);
    }
  }

  return rv;
}

// -----------------------------------------------------------------------------
// Inverted compare two strings (Not-Equal).
//
// Pseudo code:
// ... = (x != y)
//
// Parameters:
//   x - the first string to compare (IN),
//   y - second string to compare (IN).
//
// Returns:
//   1 if string are different (not equal),
//   0 otherwise.
// -----------------------------------------------------------------------------

bool32_t __MOLD_cmp_ne_string(const Variant_t *x, const Variant_t *y)
{
  return !__MOLD_cmp_eq_string(x, y);
}

// -----------------------------------------------------------------------------
// Join (concatenate) two strings into another one.
//
// Pseudo code:
//   dst = x + y
//
// Parameters:
//   dst - existing variant, where to store joined strings (OUT),
//   x   - the first string to join (IN),
//   x   - second string to join (IN).
// -----------------------------------------------------------------------------

void __MOLD_VariantStringJoin(Variant_t *dst,
                              const Variant_t *x,
                              const Variant_t *y)
{
  ASSERT_VARIANT_PTR_STRING(x);
  ASSERT_VARIANT_PTR_STRING(y);

  uint64_t xLen = 0;
  uint64_t yLen = 0;

  char *xText = NULL;
  char *yText = NULL;

  // ------------------------------
  // Fetch the first source string.
  //

  if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    xLen  = 1;
    xText = (char *) &x -> value;
  }
  else
  {
    String_t *xStr = (String_t *) x -> valueAsBufferPtr -> bytesPtr;

    xLen  = xStr -> length;
    xText = (char *) xStr -> text;
  }

  // ---------------------------
  // Fetch second source string.
  //

  if (y -> flags & VARIANT_FLAG_ONE_CHARACTER)
  {
    yLen  = 1;
    yText = (char *) &y -> value;
  }
  else
  {
    String_t *yStr = (String_t *) y -> valueAsBufferPtr -> bytesPtr;

    yLen  = yStr -> length;
    yText = (char *) yStr -> text;
  }

  // -------------------------------------------------------
  // Calculate destination length (without zero terminator).
  //

  uint64_t newSize = xLen + yLen;

  // -------------------------------------------
  // Allocate new buffer for destination string.
  // TODO: Use existing buffer if possible.
  //

  Buffer_t *dstBuf = __MOLD_MemoryAlloc(sizeof(String_t) + newSize);
  String_t *dstStr = (String_t *) dstBuf -> bytesPtr;

  // ------------------------------------------------
  // Join two source strings into destination buffer.
  //

  memcpy(dstStr -> text        , xText, xLen);
  memcpy(dstStr -> text + xLen , yText, yLen);

  dstStr -> length = newSize;

  // Free existing dst if any.
  __MOLD_VariantDestroy(dst);

  // Assign new buffer to result.
  // --------------------------------------
  dst -> type             = VARIANT_STRING;
  dst -> valueAsBufferPtr = dstBuf;
  dst -> flags            = 0;

  ASSERT_VARIANT_PTR_STRING(dst);
  ASSERT_VARIANT_PTR_STRING(x);
  ASSERT_VARIANT_PTR_STRING(y);
}

// -----------------------------------------------------------------------------
// Pull out the piece from the string.
//
// Parameters:
//   str - source string with original full text (IN),
//   idx - index of the first character to be pulled (IN),
//   len - how many chars to be pulled or -1 for "up to end" beheavior (IN).
//
// Means:
// - Find character no. <idx>,
// - then copy <len> characters.
//
// Example:
//   substr("abcdefg", 2, 3) gives "cde".
//
// Returns:
//   New string contained substring from the source one.
//
// -----------------------------------------------------------------------------

Variant_t __MOLD_SubStr(const Variant_t *strVariant,
                        const Variant_t *idxVariant,
                        const Variant_t *lenVariant)
{
  ASSERT_VARIANT_PTR_STRING(strVariant);
  ASSERT_VARIANT_PTR_INTEGER(idxVariant);
  ASSERT_VARIANT_PTR_INTEGER(lenVariant);

  Variant_t rv = { VARIANT_STRING };

  String_t *str = (String_t *) strVariant -> valueAsBufferPtr -> bytesPtr;

  int32_t idx = idxVariant -> valueAsInt32;
  int32_t len = lenVariant -> valueAsInt32;

  if ((len < 0) || (idx + len >= str -> length))
  {
    len = str -> length - idx;
  }

  Buffer_t *newBuf = __MOLD_MemoryAlloc(sizeof(String_t) + len + 1);
  String_t *newStr = (String_t *) newBuf -> bytesPtr;

  newStr -> length = len;

  rv.valueAsBufferPtr = newBuf;

  memcpy(newStr -> text, str -> text + idx, len);

  ASSERT_VARIANT_PTR_STRING(&rv);

  return rv;
}

// -----------------------------------------------------------------------------
// Convert any variant to the string.
//
// Parameters:
//   x - any variant variable to be converted into text (IN).
//
// Returns:
//   Text representation of input variable.
// -----------------------------------------------------------------------------


Variant_t __MOLD_Str(Variant_t *x)
{
  ASSERT_VARIANT_PTR_ANY(x);

  Variant_t rv = { VARIANT_STRING };

  if (x -> type == VARIANT_STRING)
  {
    // Input is already a string - nothing to do.
    // TODO: Review it.
    __MOLD_VariantAddRef(x);
    rv = *x;
  }
  else
  {
    // Input is not a string.
    // We need to create new one.
    // Possible improvement: Optimize it.
    rv = __MOLD_PrintToString_variant(x);

    /*
    OLD IMPLEMENTATION
    const char *fmt = NULL;

    switch (x -> type)
    {
      case VARIANT_UNDEFINED: { fmt = "undefined"; break; }
      case VARIANT_NULL:      { fmt = "null"; break; }
      case VARIANT_INTEGER:   { fmt = "%"PRId64; break; }
      case VARIANT_FLOAT:     { fmt = "%f"; break; }
      case VARIANT_DOUBLE:    { fmt = "%lf"; break; }
      case VARIANT_BOOLEAN:   { fmt = x -> value ? "true" : "false"; break; }
      case VARIANT_ARRAY:     { fmt = "[array]"; break; }
      case VARIANT_MAP:       { fmt = "[map]"; break; }
      case VARIANT_OBJECT:    { fmt = "[object]"; break; }

      default:
      {
        __MOLD_PrintErrorAndDie_badType();
      }
    }

    Buffer_t *buf = __MOLD_MemoryAlloc(32 + sizeof(String_t));
    String_t *str = (String_t *) buf -> bytesPtr;
    str -> length = snprintf(str -> text, 31, fmt, x -> value);
    rv.valueAsBufferPtr = buf;
    */
  }

  ASSERT_VARIANT_PTR_ANY(x);
  ASSERT_VARIANT_PTR_STRING(&rv);

  return rv;
}

// -----------------------------------------------------------------------------
// Get ascii number of given character.
//
// Parameters:
//  x - one character string to be converted e.g. 'a' (IN)
//
// Returns:
//   Ascii value of given character.
// -----------------------------------------------------------------------------

uint32_t __MOLD_Ord(const Variant_t *x)
{
  ASSERT_VARIANT_PTR_ANY(x);

  uint32_t rv = 0;

  switch (x -> type)
  {
    case VARIANT_STRING:
    {
      if (x -> flags & VARIANT_FLAG_ONE_CHARACTER)
      {
        rv = x -> valueAsUInt8;
      }
      else
      {
        String_t *str = (String_t *) x -> valueAsBufferPtr -> bytesPtr;
        rv = str -> text[0];
      }

      break;
    }

    case VARIANT_UNDEFINED:
    {
      rv = 0;
      break;
    }

    case VARIANT_INTEGER:
    {
      rv = x -> valueAsUInt8;
      break;
    }

    default:
    {
      __MOLD_PrintErrorAndDie_stringExpected();
    }
  }

  return rv;
}

// -----------------------------------------------------------------------------
// Get character of given ascii number.
//
// Parameters:
//  x - ascii number e.g. 65 (IN)
//
// Returns:
//   Character with given ascii number.
// -----------------------------------------------------------------------------

Variant_t __MOLD_Asc(const Variant_t *x)
{
  ASSERT_VARIANT_PTR_INTEGER(x);

  Variant_t rv =
  {
    type: VARIANT_STRING,
    flags: VARIANT_FLAG_ONE_CHARACTER,
    value: x -> value
  };

  ASSERT_VARIANT_PTR_STRING(&rv);

  return rv;
}

void __MOLD_StrAndAssign(Variant_t *rv, Variant_t *x) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Str(x);
}

void __MOLD_SubStrAndAssign(Variant_t *rv,
                            const Variant_t *x,
                            const Variant_t *idx,
                            const Variant_t *len) {
  // TODO: Clean up this mess.
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_SubStr(x, idx, len);
}

void __MOLD_AscAndAssign(Variant_t *rv, const Variant_t *x) {
  // TODO: Clean up this mess.
  ASSERT_VARIANT_PTR_ANY(rv);
  __MOLD_VariantDestroy(rv);
  *rv = __MOLD_Asc(x);
}

