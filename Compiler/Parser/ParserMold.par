/******************************************************************************/
/*                                                                            */
/* This file is part of Mold project.                                         */
/* Copyright (C) 2015, 2019 Sylwester Wysocki (sw143@wp.pl)                   */
/*                                                                            */
/* This program is free software: you can redistribute it and/or modify       */
/* it under the terms of the GNU General Public License as published by       */
/* the Free Software Foundation, either version 3 of the License, or          */
/* (at your option) any later version.                                        */
/*                                                                            */
/* This program is distributed in the hope that it will be useful,            */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of             */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              */
/* GNU General Public License for more details.                               */
/*                                                                            */
/* You should have received a copy of the GNU General Public License          */
/* along with this program. If not, see <http://www.gnu.org/licenses/>        */
/*                                                                            */
/******************************************************************************/

#!language "mold";
#default action [* @@ = @1 *];
#whitespaces @WHITE;

@WHITE ' ' | "/*" .* "*/" | '#' .* '\r\n'+;
@EOL   '\r\n'+;
@IDENT 'A-Za-z_' 'A-Za-z0-9_'* ;

@STRING              '"' !'"\r\n'* '"'    | '\'' !'\'\r\n'* '\'' ;
@UNTERMINATED_STRING '"' !'"'*     '\r\n' | '\'' !'\''*     '\r\n' ;

@FLOAT   '0-9'+ '.' '0-9'+;
@INTEGER '0-9'+ | "0x" '0-9a-fA-F'+;

#left '=';
#left '+' '-';
#left '*' '/' "//";
#left "is" "isnt" '<' '>' "<=" ">=";
#left "and" "or";
#left "not";

// -----------------------------------------------------------------------------
//                       General source code sturucture
// -----------------------------------------------------------------------------

program$:
  stmt_list = AST_OPCODE_PROGRAM;

stmt_list:
  stmt_line* [* @@ = null *] =AST_OPCODE_BLOCK;

stmt_line
  : stmt @EOL
  | @EOL;

// -----------------------------------------------------------------------------
//                            Top level statements
//
// Below there are possible statements, that can be used in the global space.
// -----------------------------------------------------------------------------

stmt
  : stmt_declare_or_assign    =AST_OPCODE_DECLARE_OR_ASSIGN  // x = y
  | stmt_call                 =AST_OPCODE_CALL               // foo(x,y,z)
  | stmt_vcall                =AST_OPCODE_VCALL              // obj.foo(x,y,z)
  | stmt_function_declaration =AST_OPCODE_FUNCTION           // function foo()
  | stmt_class_declaration    =AST_OPCODE_CLASS              // class foo
  | stmt_if                   =AST_OPCODE_IF                 // if x is 1
  | stmt_for                  =AST_OPCODE_FOR_VALUES_RANGE   // for x in 0..10
  | stmt_while                =AST_OPCODE_WHILE              // while goOn is true
  | stmt_for_values           =AST_OPCODE_FOR_VALUES         // for values v in box
  | stmt_for_keys             =AST_OPCODE_FOR_KEYS           // for keys k in box
  | stmt_for_keys_values      =AST_OPCODE_FOR_KEYS_VALUES    // for keys k values v in box
  | stmt_for_indexes          =AST_OPCODE_FOR_INDEXES        // for indexes i in box
  | stmt_for_indexes_values   =AST_OPCODE_FOR_INDEXES_VALUES // for indexes i values v in box

// TODO
//  | stmt_switch
//  | stmt_read
//  | stmt_write
  ;

// -----------------------------------------------------------------------------
//                           Declare or assign: x = y
// -----------------------------------------------------------------------------

stmt_declare_or_assign
  : lval '=' rval

  | "const" var '=' rval_imm_array

  | "const" var '=' imm  [* if constantsMap{@2} is defined
                              this._handleError(line, column, "redeclaration of a constant '" + @4 + "'")
                            endif
                            constantsMap{@2} = @4
                            @@ = @2
                         *]
  ;

// -----------------------------------------------------------------------------
//                       Function declaration and call
// -----------------------------------------------------------------------------

function_proto
  : @IDENT '(' ')'                            [* @@ = {'name': @1, 'parameters': []} *]
  | @IDENT '(' ')' "->" @IDENT                [* @@ = {'name': @1, 'parameters': [], 'rv': @5} *]
  | @IDENT '(' parameter_list ')'             [* @@ = {'name': @1, 'parameters': @3} *]
  | @IDENT '(' parameter_list ')' "->" @IDENT [* @@ = {'name': @1, 'parameters': @3, 'rv': @6} *]
  ;

stmt_call
  : "print"  call_list_line [* @@ = 'print'  *]
  | "global" call_list_line [* @@ = 'global' *]
  | "import" call_list_line [* @@ = 'import' *]
  | function_call
  ;

function_call
  : @IDENT '(' value_list? ')'
  ;

stmt_function_declaration:
  "function" function_proto @EOL
  stmt_list
  "endfunction" [* @@ = @2 *];

//
// Comma separated lists.
//

parameter_list
  : parameter_list ',' @EOL? @IDENT [* @1[len(@1)] = @4
                                       @@ = @1
                                    *]

  | @EOL parameter_list            [* @@ = @2 *]
  | @IDENT                         [* @@ = [@1] *]
  | @EOL
  ;

call_list_line
  : call_list_line ',' rval
  | rval
  ;

//
// Key:value list.
//

key_value_list
  : key_value_list ',' map_key ':' map_val
  | key_value_list ',' @EOL map_key ':' map_val
  | key_value_list @EOL
  | @EOL key_value_list
  | map_key ':' map_val
  | @EOL
  ;

map_key : string =AST_DATA_STRING;
map_val : rval;

value_list
  : value_list ',' rval
  | value_list ',' @EOL rval
  | value_list @EOL
  | @EOL value_list
  | rval
  | @EOL
  ;

// TODO: Handle strings and bool too.
imm_list
  : imm_list ',' expr_imm    [* @1[len(@1)] = @3
                                @@ = @1 *]

  | imm_list ',' @EOL expr_imm [* @1[len(@1)] = @4
                                  @@ = @1 *]

  | imm_list @EOL [* @@ = @1 *]
  | @EOL imm_list [* @@ = @2 *]
  | expr_imm      [* @@ = [@1] *]
  | @EOL
  ;

// -----------------------------------------------------------------------------
//                          Built-in I/O statements
// -----------------------------------------------------------------------------

// write to stdout values x,y,z
stmt_read
  : "read" "from" rval "values" call_list_line [* @@ = 'read' *] =AST_OPCODE_CALL;

// read from stdin values x,y,z
stmt_write
  : "write" "to" rval "values" call_list_line  [* @@ = 'write' *] =AST_OPCODE_CALL;

// -----------------------------------------------------------------------------
//                          Object-oriented related (OOP)
// -----------------------------------------------------------------------------

class_begin
  : "class" @IDENT                  [* @@ = {'name': @2} *]
  | "class" @IDENT "extends" @IDENT [* @@ = {'name': @2, 'baseName': @4} *]
  ;

stmt_class_declaration:
  class_begin @EOL
  (method_declaration | @EOL)*
  "endclass";

stmt_vcall: method_call;

method_call
  : expr '.' @IDENT '(' value_list? ')' [* @@ = @3 *];

method_declaration:
  "method" function_proto @EOL
  stmt_list
  "endmethod" [* @@ = @2 *] =AST_OPCODE_CLASS_METHOD;

new_call
  : new_begin @IDENT '(' value_list? ')' [* @@ =  @2 *] =AST_OPCODE_CALL_NEW
  ;

new_begin
 : "new" [* @@ = '__this_placeholder__' *] =AST_OPCODE_VARIABLE;

// -----------------------------------------------------------------------------
//                              Expressions
// -----------------------------------------------------------------------------

expr
  : imm                             // 1, 3.14, 'text'
  | var                             // x
  | reference                       // x[y], x{y}, x.y
  | function_call =AST_OPCODE_CALL  // foo(x,y,z)
  | method_call   =AST_OPCODE_VCALL // obj.foo(x,y,z)
  | logic
  | expr_logic

  | expr '+' expr  =AST_OPCODE_ADD  // x + y
  | expr '-' expr  =AST_OPCODE_SUB  // x - y
  | expr '*' expr  =AST_OPCODE_MUL  // x * y
  | expr '/' expr  =AST_OPCODE_DIV  // x / y
  | expr "//" expr =AST_OPCODE_IDIV // x // y
  | '-' expr       =AST_OPCODE_NEG  // -x
  | '(' expr ')'                    // (x)
  ;

// -----------------------------------------------------------------------------
//                              Boolean logic
// -----------------------------------------------------------------------------

// Logical primitive: true, false, x o y
logic
  : bool                                       // true, false
  | "not" logic      =AST_OPCODE_BOOL_NOT      // not x
  | rval "is" rval   =AST_OPCODE_COMPARE_EQ    // x is y
  | rval "isnt" rval =AST_OPCODE_COMPARE_NEQ   // x isnt y
  | rval "<" rval    =AST_OPCODE_COMPARE_LT    // x < y
  | rval "<=" rval   =AST_OPCODE_COMPARE_LE    // x <= y
  | rval '>' rval    =AST_OPCODE_COMPARE_GT    // x > y
  | rval ">=" rval   =AST_OPCODE_COMPARE_GE    // x >= y
  ;

// Complex logical expression built from primitves.
expr_logic
  : bool
  | '(' logic ')'      [* @@ = @2 *]
  | '(' expr_logic ')' [* @@ = @2 *]
  | expr_logic "and" expr_logic =AST_OPCODE_BOOL_AND
  | expr_logic "or"  expr_logic =AST_OPCODE_BOOL_OR
  ;

expr_logic_multiline
  : expr_logic "and" @EOL (expr_logic | expr_logic_multiline) =AST_OPCODE_BOOL_AND
  | expr_logic "or"  @EOL (expr_logic | expr_logic_multiline) =AST_OPCODE_BOOL_OR
  ;

condition
  : logic
  | expr_logic
  | '(' expr_logic_multiline ')' [* @@ = @2 *]
  ;

// -----------------------------------------------------------------------------
//                                If-else-endif
// -----------------------------------------------------------------------------

stmt_if
  : "if" condition @EOL
      stmt_list
    "endif"

  | "if" condition @EOL
      stmt_list
    "else"
      stmt_list
    "endif"

  | "if" condition @EOL
      stmt_list
      stmt_elif
  ;

stmt_elif
  : "elif" condition @EOL
      stmt_list
    "endif"
    =AST_OPCODE_IF

  | "elif" condition @EOL
      stmt_list
    "else"
      stmt_list
    "endif"
    =AST_OPCODE_IF

  | "elif" condition @EOL
      stmt_list
      stmt_elif =AST_OPCODE_IF
  ;

// -----------------------------------------------------------------------------
//                                 Switch / case
// -----------------------------------------------------------------------------

/*
TODO
//
// switch x
//   case 1
//     ...
//   case 2, 3, 4
//     ...
//   othwerwise
//     ..
// endswitch
//

stmt_switch
  : "switch" rval @EOL stmt_switch_case+ stmt_switch_otherwise? "endswitch"
  ;

stmt_switch_case
  : "case" imm_list @EOL stmt_list
  ;

stmt_switch_otherwise
  : "otherwise" @EOL stmt_list
  ;
*/

// -----------------------------------------------------------------------------
//                               For range loop
// for i in 0..10 step n
//   ...
// endfor
// -----------------------------------------------------------------------------

stmt_for:
  "for" var "in" rval ".." rval step?
  stmt_list
  "endfor";

step
  : @EOL [* @@ = 1 *] =AST_DATA_INTEGER
  | "step" rval
  ;

// -----------------------------------------------------------------------------
//                            For-each like loops
//
// for values v in box              (generic iteration over values)
// for keys k in box                (map iteration over keys)
// for keys k values v in box       (map iteration over key:value pairs)
// for indexes idx in box           (array iteration over indexes)
// for indexes idx values v in box  (array iteration over index:value pairs)
// -----------------------------------------------------------------------------

stmt_for_values:
  "for" "values" var "in" rval
  stmt_list
  "endfor";

stmt_for_keys:
  "for" "keys" var "in" rval
  stmt_list
  "endfor";

stmt_for_indexes:
  "for" "indexes" var "in" rval
  stmt_list
  "endfor";

stmt_for_keys_values:
  "for" "keys" var "values" var "in" rval
  stmt_list
  "endfor";

stmt_for_indexes_values:
  "for" "indexes" var "values" var "in" rval
  stmt_list
  "endfor";

// -----------------------------------------------------------------------------
//                                 While loop
// -----------------------------------------------------------------------------

stmt_while:
  "while" condition @EOL
  stmt_list
  "endwhile";

// -----------------------------------------------------------------------------
//                Reference: Indirect acces by index or key
// -----------------------------------------------------------------------------

reference
  : expr '[' expr ']' =AST_OPCODE_REFERENCE_BY_INDEX // x[1234]
  | expr '{' expr '}' =AST_OPCODE_REFERENCE_BY_KEY   // x{'key'}
  | expr '.' member   =AST_OPCODE_REFERENCE_BY_KEY   // x.property
  ;

// -----------------------------------------------------------------------------
//                    L-values: Used on left side of x=y
// -----------------------------------------------------------------------------

lval
  : var       // x = ...
  | reference // x[i] = ...
  ;

// -----------------------------------------------------------------------------
//                   R-values: Used on right side of x=y
// -----------------------------------------------------------------------------

rval
  : var
  | expr
  | reference
  | new_call
  | imm
  | function_call =AST_OPCODE_CALL
  | method_call   =AST_OPCODE_VCALL
  | rval_array    =AST_DATA_ARRAY
  | rval_map      =AST_DATA_MAP
  | logic
  ;

rval_array
  : '[' ']'
  | '[' value_list ']'
  ;

rval_imm_array
  : imm_array =AST_DATA_ARRAY
  ;

rval_map
  : '{' '}'
  | '{' key_value_list '}'
  ;

imm_array
  : '[' imm_list ']' [* @@ = @2 *]
  ;

// -----------------------------------------------------------------------------
//                                Basic leafs
// -----------------------------------------------------------------------------

var    : @IDENT =AST_OPCODE_VARIABLE;
member : @IDENT =AST_DATA_STRING;

expr_imm
  : expr_imm '+'  expr_imm [* @@ = @1 + @3 *]
  | expr_imm '-'  expr_imm [* @@ = @1 - @3 *]
  | expr_imm '*'  expr_imm [* @@ = @1 * @3 *]
  | expr_imm '/'  expr_imm [* @@ = @1 / @3 *]
  | expr_imm "//" expr_imm [* @@ = @1 // @3 *]
  | '-' expr_imm           [* @@ = -@2 *]
  | '(' expr_imm ')'       [* @@ = @2 *]
  | integer
  | float
  | string
  | imm_array

  | @IDENT [* @@ = constantsMap{@1}
              if @@ is undefined
                this._handleError(line, column, 'only constant values can be inserted into constant array')
              endif
           *]
  ;

imm : integer =AST_DATA_INTEGER
    | float   =AST_DATA_DOUBLE
    | string  =AST_DATA_STRING
    ;

number
  : float
  | integer
  ;

integer
  : @INTEGER [* @@ = ParseInteger(@1) *]
  ;

float
  : @FLOAT [* @@ = ParseFloat(@1) *]
  ;

string
  : @STRING [* @@ = ''
               # Remove quotas.
               stringLen = len(@1)
               for idx in 1 .. stringLen - 1
                 @@ = @@ + @1[idx]
               endfor
            *]
  | error_unterminated_string
  ;

bool
  : "true"  [* @@ = true *]  =AST_DATA_BOOL
  | "false" [* @@ = false *] =AST_DATA_BOOL
  ;

// -----------------------------------------------------------------------------
//                            Common syntax errors
// -----------------------------------------------------------------------------

error_unterminated_string
  : @UNTERMINATED_STRING [* this._handleError(line, column, 'unterminated string') *]
  ;
