/******************************************************************************/
/*                                                                            */
/* This file is part of Mold project.                                         */
/* Copyright (C) 2015, 2019 Sylwester Wysocki (sw143@wp.pl)                   */
/*                                                                            */
/* This program is free software: you can redistribute it and/or modify       */
/* it under the terms of the GNU General Public License as published by       */
/* the Free Software Foundation, either version 3 of the License, or          */
/* (at your option) any later version.                                        */
/*                                                                            */
/* This program is distributed in the hope that it will be useful,            */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of             */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              */
/* GNU General Public License for more details.                               */
/*                                                                            */
/* You should have received a copy of the GNU General Public License          */
/* along with this program. If not, see <http://www.gnu.org/licenses/>        */
/*                                                                            */
/******************************************************************************/

#!language "mold";
#default action [* @@ = @1 *];
#whitespaces @WHITE;

@WHITE   ' ' | "/*" .* "*/" | '#' .* '\r\n'+;
@EOL     '\r\n'+;
@IDENT   'A-Za-z_' 'A-Za-z0-9_'* ;

@STRING              '"' !'"\r\n'* '"'    | '\'' !'\'\r\n'* '\'' ;
@UNTERMINATED_STRING '"' !'"'*     '\r\n' | '\'' !'\''*     '\r\n' ;

@FLOAT   '0-9'+ '.' '0-9'+;
@INTEGER '0-9'+ | "0x" '0-9a-fA-F'+;
@TRUE    "true";
@FALSE   "false";

#left '=';
#left '+' '-';
#left '*' '/' "//";
#left "is" "isnt" '<' '>' "<=" ">=";
#left "and" "or";
#left "not";

//
// Defining the grammar
//

program$ : stmt_list = AST_OPCODE_PROGRAM;

stmt_list : stmt* [* @@ = null *] =AST_OPCODE_BLOCK;

stmt
  : lval '=' rval @EOL                   =AST_OPCODE_DECLARE_OR_ASSIGN
  | "const" var '=' rval_imm_array @EOL  =AST_OPCODE_DECLARE_OR_ASSIGN

  | "const" var '=' imm @EOL  [* if constantsMap[@2] is defined
                                   this._handleError(line, column, "redeclaration of a constant '" + @4 + "'")
                                 endif
                                 constantsMap[@2] = @4
                                 @@ = @2
                              *] =AST_OPCODE_DECLARE_OR_ASSIGN

  | function_call @EOL
  | method_call @EOL
  | stmt_import @EOL
  | function_declaration @EOL     =AST_OPCODE_FUNCTION
  | class_declaration @EOL        =AST_OPCODE_CLASS
  | stmt_if @EOL                  =AST_OPCODE_IF
  | stmt_for @EOL                 =AST_OPCODE_FOR_VALUES_RANGE
  | stmt_while @EOL               =AST_OPCODE_WHILE
//TODO  | stmt_switch @EOL              =switch
  | stmt_for_values @EOL          =AST_OPCODE_FOR_VALUES
  | stmt_for_keys @EOL            =AST_OPCODE_FOR_KEYS
  | stmt_for_keys_values @EOL     =AST_OPCODE_FOR_KEYS_VALUES
  | stmt_for_indexes @EOL         =AST_OPCODE_FOR_INDEXES
  | stmt_for_indexes_values @EOL  =AST_OPCODE_FOR_INDEXES_VALUES
//  | stmt_read @EOL
//  | stmt_write @EOL
  | @EOL
  ;

//
// Import module.
//

stmt_import
  : "import" module_name [* @@ = 'import' *] =AST_OPCODE_CALL;

module_name
  : string =AST_DATA_STRING;

//
// Functions.
//

function_call
  : @IDENT '(' ')'           [* @@ = @1 *]       =AST_OPCODE_CALL //[* @@ = {'name': @1, 'parameters': []} *]
  | @IDENT '(' call_list ')' [* @@ = @1 *]       =AST_OPCODE_CALL //[* @@ = {'name': @1, 'parameters': @3} *]
  | "print" call_list_line   [* @@ = 'print' *]  =AST_OPCODE_CALL //[* @@ = {'name': 'print', 'parameters': @2} *]
  | "global" call_list_line  [* @@ = 'global' *] =AST_OPCODE_CALL //[* @@ = {'name': 'print', 'parameters': @2} *]
  ;

function_begin
  : "function" @IDENT '(' ')'                            [* @@ = {'name': @2, 'parameters': []} *]
  | "function" @IDENT '(' ')' "->" @IDENT                [* @@ = {'name': @2, 'parameters': [], 'rv': @6} *]
  | "function" @IDENT '(' parameter_list ')'             [* @@ = {'name': @2, 'parameters': @4} *]
  | "function" @IDENT '(' parameter_list ')' "->" @IDENT [* @@ = {'name': @2, 'parameters': @4, 'rv': @7} *]
  ;

function_end
  : "endfunction";

function_body
  : stmt_list
  ;

function_declaration
  : function_begin @EOL function_body function_end
  ;

//
// Comma separated lists.
//

parameter_list
  : parameter_list ',' @IDENT      [* @1[len(@1)] = @3
                                      @@ =@1 *]

  | parameter_list ',' @EOL @IDENT [* @1[len(@1)] = @4
                                      @@ = @1 *]

  | @EOL parameter_list            [* @@ = @2 *]
  | @IDENT                         [* @@ = [@1] *]
  | @EOL
  ;

call_list
  : call_list ',' rval        [* @1[len(@1)] = @3
                                 @@ =@1 *]

  | call_list ',' @EOL rval   [* @1[len(@1)] = @4
                                 @@ = @1 *]

  | @EOL call_list            [* @@ = @2 *]
  | call_list @EOL            [* @@ = @1 *]
  | rval                      [* @@ = [@1] *]
  | @EOL
  ;

call_list_line
  : call_list_line ',' rval [* @1[len(@1)] = @3
                               @@ =@1 *]

  | rval                    [* @@ = [@1] *]
  ;

//
// Key:value list.
//

key_value_list
  : key_value_list ',' map_key ':' map_val
  | key_value_list ',' @EOL map_key ':' map_val
  | key_value_list @EOL
  | @EOL key_value_list
  | map_key ':' map_val
  | @EOL
  ;

map_key : string =AST_DATA_STRING;
map_val : rval;

value_list
  : value_list ',' rval
  | value_list ',' @EOL rval
  | value_list @EOL
  | @EOL value_list
  | rval
  | @EOL
  ;

// TODO: Handle strings and bool too.
imm_list
  : imm_list ',' expr_imm    [* @1[len(@1)] = @3
                                @@ = @1 *]

  | imm_list ',' @EOL expr_imm [* @1[len(@1)] = @4
                                  @@ = @1 *]

  | imm_list @EOL [* @@ = @1 *]
  | @EOL imm_list [* @@ = @2 *]
  | expr_imm      [* @@ = [@1] *]
  | @EOL
  ;

//
// Comma separated identifiers list.
//

ident_list
  : ident_list ',' @IDENT
  | @IDENT
  ;


//
// I/O
// write to stdout values x,y,z
// read from stdin values x,y,z
//

stmt_read
  : "read" "from" rval "values" call_list_line [* @@ = 'read' *] =AST_OPCODE_CALL
  ;

stmt_write
  : "write" "to" rval "values" call_list_line  [* @@ = 'write' *] =AST_OPCODE_CALL
  ;

//
// Classes.
//

class_begin
  : "class" @IDENT                  [* @@ = {'name': @2} *]
  | "class" @IDENT "extends" @IDENT [* @@ = {'name': @2, 'baseName': @4} *]
  ;

class_end
  : "endclass";

class_body
  : class_body_item*;

class_body_item
  : method_declaration | @EOL;

class_declaration
  : class_begin @EOL class_body class_end;

method_call
  : expr '.' @IDENT '(' ')'           [* @@ = @3 *] =AST_OPCODE_INVOKE_METHOD
  | expr '.' @IDENT '(' call_list ')' [* @@ = @3 *] =AST_OPCODE_INVOKE_METHOD
  ;

method_begin
  : "method" @IDENT '(' ')'                            [* @@ = {'name': @2, 'parameters': []} *]
  | "method" @IDENT '(' ')' "->" @IDENT                [* @@ = {'name': @2, 'parameters': [], 'rv': @6} *]
  | "method" @IDENT '(' parameter_list ')'             [* @@ = {'name': @2, 'parameters': @4} *]
  | "method" @IDENT '(' parameter_list ')' "->" @IDENT [* @@ = {'name': @2, 'parameters': @4, 'rv': @7} *]
  ;

method_end
  : "endmethod";

method_body
  : stmt_list;

method_declaration
  : method_begin @EOL method_body method_end =AST_OPCODE_CLASS_METHOD;

//
// Constructor call.
//

new_call
  : new_begin @IDENT '(' ')'          [* @@ =  @2 *] =AST_OPCODE_CALL_NEW
  | new_begin @IDENT '('call_list ')' [* @@ =  @2 *] =AST_OPCODE_CALL_NEW
  ;

new_begin
 : "new" [* @@ = '__this_placeholder__' *] =AST_OPCODE_VARIABLE;

//
// Expressions.
//

expr
  : expr '+' expr     =AST_OPCODE_ADD
  | expr '-' expr     =AST_OPCODE_SUB
  | expr '*' expr     =AST_OPCODE_MUL
  | expr '/' expr     =AST_OPCODE_DIV
  | expr "//" expr    =AST_OPCODE_IDIV
  | '(' expr ')'
  | '-' expr          =AST_OPCODE_NEG
  | expr '[' expr ']' =AST_OPCODE_REFERENCE
  | expr '.' member   =AST_OPCODE_REFERENCE
  | imm
  | logic
  | expr_logic
  | var
  ;

//
// Logical.
//

// Logical primitive: true, false, x o y
logic
  : "not" logic       =AST_OPCODE_BOOL_NOT
  | rval "is" rval    =AST_OPCODE_COMPARE_EQ
  | rval "isnt" rval  =AST_OPCODE_COMPARE_NEQ
  | rval "<" rval     =AST_OPCODE_COMPARE_LT
  | rval "<=" rval    =AST_OPCODE_COMPARE_LE
  | rval '>' rval     =AST_OPCODE_COMPARE_GT
  | rval ">=" rval    =AST_OPCODE_COMPARE_GE
  | function_call
  | method_call
  | bool              =AST_DATA_BOOL
  ;

// Complex logical expression built from primitves.
expr_logic
  : bool =AST_DATA_BOOL
  | '(' logic ')'      [* @@ = @2 *]
  | '(' expr_logic ')' [* @@ = @2 *]
  | expr_logic "and" expr_logic =AST_OPCODE_BOOL_AND
  | expr_logic "or"  expr_logic =AST_OPCODE_BOOL_OR
  ;

expr_logic_multiline
  : expr_logic "and" @EOL (expr_logic | expr_logic_multiline) =AST_OPCODE_BOOL_AND
  | expr_logic "or"  @EOL (expr_logic | expr_logic_multiline) =AST_OPCODE_BOOL_OR
  ;

condition
  : logic
  | expr_logic
  | '(' expr_logic_multiline ')' [* @@ = @2 *]
  ;

//
// IF-ELSE-ENDIF
//

stmt_if
  : "if" condition @EOL stmt_list "endif"
  | "if" condition @EOL stmt_list "else" stmt_list "endif"
  | "if" condition @EOL stmt_list stmt_elif
  ;

stmt_elif
  : "elif" condition @EOL stmt_list "endif"                   =AST_OPCODE_IF
  | "elif" condition @EOL stmt_list "else" stmt_list "endif"  =AST_OPCODE_IF
  | "elif" condition @EOL stmt_list stmt_elif                 =AST_OPCODE_IF
  ;

/*
TODO
//
// switch x
//   case 1
//     ...
//   case 2, 3, 4
//     ...
//   othwerwise
//     ..
// endswitch
//

stmt_switch
  : "switch" rval @EOL stmt_switch_case+ stmt_switch_otherwise? "endswitch"
  ;

stmt_switch_case
  : "case" imm_list @EOL stmt_list
  ;

stmt_switch_otherwise
  : "otherwise" @EOL stmt_list
  ;
*/

//
// For loop.
//

stmt_for
  : "for" var "in" rval ".." rval step?  stmt_list "endfor";

step
  : @EOL [* @@ = 1 *] =AST_DATA_INTEGER
  | "step" rval
  ;

//
// for values v in box              (generic iteration over values)
// for keys k in box                (map iteration over keys)
// for keys k values v in box       (map iteration over key:value pairs)
// for indexes idx in box           (array iteration over indexes)
// for indexes idx values v in box  (array iteration over index:value pairs)
//

stmt_for_values
  : "for" "values" var "in" rval stmt_list "endfor";

stmt_for_keys
  : "for" "keys" var "in" rval stmt_list "endfor";

stmt_for_indexes
  : "for" "indexes" var "in" rval stmt_list "endfor";

stmt_for_keys_values
  : "for" "keys" var "values" var "in" rval stmt_list "endfor";

stmt_for_indexes_values
  : "for" "indexes" var "values" var "in" rval stmt_list "endfor";

//
// While loop.
//

stmt_while
  : "while" condition @EOL stmt_list "endwhile";

//
// Array initializers.
//

rval_array
  : '[' ']'
  | '[' value_list ']'
  ;

rval_imm_array
  : imm_array =AST_DATA_ARRAY
  ;

rval_map
  : '{' '}'
  | '{' key_value_list '}'
  ;

imm_array
  : '[' imm_list ']' [* @@ = @2 *]
  ;

//
// L-value and R-value.
//

lval
  : var               //=loadr
  | expr '[' expr ']' =AST_OPCODE_REFERENCE
  | expr '.' member   =AST_OPCODE_REFERENCE
  ;

rval
  : expr
  | expr '[' expr ']' =AST_OPCODE_REFERENCE
  | expr '.' member   =AST_OPCODE_REFERENCE
  | var               //=load
  | new_call
  | function_call
  | method_call
  | imm
  | rval_array        =AST_DATA_ARRAY
  | rval_map          =AST_DATA_MAP
  | logic
  ;

//
// Basic leafs.
//

var : @IDENT =AST_OPCODE_VARIABLE;

member : @IDENT =AST_DATA_STRING;

expr_imm
  : expr_imm '+'  expr_imm [* @@ = @1 + @3 *]
  | expr_imm '-'  expr_imm [* @@ = @1 - @3 *]
  | expr_imm '*'  expr_imm [* @@ = @1 * @3 *]
  | expr_imm '/'  expr_imm [* @@ = @1 / @3 *]
  | expr_imm "//" expr_imm [* @@ = @1 // @3 *]
  | '-' expr_imm           [* @@ = -@2 *]
  | '(' expr_imm ')'       [* @@ = @2 *]
  | integer
  | float
  | string
  | imm_array

  | @IDENT [* @@ = constantsMap[@1]
              if @@ is undefined
                this._handleError(line, column, 'only constant values can be inserted into constant array')
              endif *]
  ;

imm : integer   =AST_DATA_INTEGER
    | float     =AST_DATA_DOUBLE
    | string    =AST_DATA_STRING
    ;

number
  : float
  | integer
  ;

integer
  : @INTEGER [* @@ = ParseInteger(@1) *]
  ;

float
  : @FLOAT [* @@ = ParseFloat(@1) *]
  ;

string
  : @STRING [* @@ = ''
               # Remove quotas.
               stringLen = len(@1)
               for idx in 1 .. stringLen - 1
                 @@ = @@ + @1[idx]
               endfor
            *]
  | error_unterminated_string
  ;

bool
  : @TRUE   [* @@ = true *]
  | @FALSE  [* @@ = false *]
  ;

//
// Common syntax errors.
//

error_unterminated_string
  : @UNTERMINATED_STRING [* this._handleError(line, column, 'unterminated string') *]
  ;
