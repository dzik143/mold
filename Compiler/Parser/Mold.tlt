<?xml version="1.0" standalone="yes"?>
<generator name="Mold">
  <code_localization />

  <!--
################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2020 Sylwester Wysocki (sw143@wp.pl)                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################
  -->

  <!--
  ****************************************************************************
  Escape sequences
  ****************************************************************************
  -->

  <!-- FIXME -->
  <!-- Backslash must be double-quoted -->
  <escape-sequence for="\" do= />
  <!-- Escape double quotation marks -->
  <escape-sequence for="&#x22;" do= />
  <!-- END OF FIXME -->

  <!--
  ****************************************************************************
  Value-stack templates
  ****************************************************************************
  -->

  <vstack_def_type>any</vstack_def_type>
  <vstack_term_type>any</vstack_term_type>
  <vstack_union_att>@@value-type-id</vstack_union_att>
  <vstack_union_def>@@attribute: null, </vstack_union_def>
  <vstack_single>value: null</vstack_single>
  <vstack_union_start>value: {</vstack_union_start>
  <vstack_union_end>}</vstack_union_end>

  <!--
  ****************************************************************************
  Semantic action templates
  ****************************************************************************
  -->
  <action_start>        elif currentIdx is @@production-number
      </action_start>
  <action_end>

</action_end>

  <action_single>stackValues[stackIdx - @@offset]</action_single>

  <action_union>stackValues[stackIdx - @@offset].@@attribute</action_union>
  <action_lhs_single>     currentRet</action_lhs_single>
  <action_lhs_union>     currentRet.@@attribute</action_lhs_union>

  <action_set_lhs>     currentLhs = @@sym</action_set_lhs>

  <!--
  ****************************************************************************
  Semantic terminal action templates
  ****************************************************************************
  -->

  <scan_action_start>&#x09;&#x09;&#x09;&#x09;case @@symbol-number:&#x0A;&#x09;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;</scan_action_start>
  <scan_action_end>&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x09;&#x09;&#x09;&#x09;break;
  </scan_action_end>

  <scan_action_begin_offset>@@prefix_lexem( pcb )</scan_action_begin_offset>
  <scan_action_end_offset>currentLen</scan_action_end_offset>

  <scan_action_ret_single>stackValues[stackIdx]</scan_action_ret_single>

  <!-- TODO: Is it needed?
    <scan_action_ret_union>stack[stackIdx].@@attribute</scan_action_ret_union>
  -->

  <scan_action_set_symbol>currentSym = @@sym</scan_action_set_symbol>

  <!--
  ****************************************************************************
  Parse table templates
  ****************************************************************************
  -->

  <defprod>
    <col>@@production-number</col>
    <col_sep>, </col_sep>
  </defprod>

  <acttab>
    <row_start>  [ @@number-of-columns</row_start>
    <row_end> ]</row_end>
    <row_sep>,&#x0A;</row_sep>
    <col>, @@symbol,@@action,@@index </col>
    <col_sep></col_sep>
  </acttab>

  <gotab>
    <row_start>  [ @@number-of-columns</row_start>
    <row_end> ]</row_end>
    <row_sep>,&#x0A;</row_sep>
    <col>, @@symbol,@@action,@@index </col>
    <col_sep></col_sep>
  </gotab>

  <!--
  ****************************************************************************
  Lexer
  ****************************************************************************
  -->

  <dfa_select>
    <col>@@machine</col>
    <col_sep>, </col_sep>
  </dfa_select>

  <dfa_char>
    <col>@@from, @@to</col>
    <col_sep>, </col_sep>
  </dfa_char>

  <dfa_trans>
    <col>@@goto</col>
    <col_sep>, </col_sep>
  </dfa_trans>

  <dfa_idx>
    <row_start>  [ </row_start>
    <row_end> ]</row_end>
    <row_sep>,&#x0A;</row_sep>
    <col>@@index * 2</col>
    <col_sep>, </col_sep>
  </dfa_idx>

  <dfa_accept>
    <row_start>  [ </row_start>
    <row_end> ]</row_end>
    <row_sep>,&#x0A;</row_sep>
    <col>@@accept</col>
    <col_sep>, </col_sep>
  </dfa_accept>

  <!--
  ****************************************************************************
  Symbol and production information tables
  ****************************************************************************
  -->

  <symbols>
    <col>  @@greedy /* @@type | @@lexem | @@whitespace | @@symbol |' @@emit' | '@@symbol-name' */</col>
    <col_sep>,&#x0A;</col_sep>
  </symbols>

  <productions>
    <col>  @@emit-0, @@length, @@lhs /* @@production-number | '@@production' */</col>
    <col_sep>,&#x0A;</col_sep>
  </productions>

  <!--
  ****************************************************************************
  Parser program
  ****************************************************************************
  -->

<file filename="@@basename.mold"># Parser module generated by unicc from @@filename.
# DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
@@prologue

################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

# -----------------------------------------------------------------------------
#                                Constants
# -----------------------------------------------------------------------------

UNICC_ERROR  = 0
UNICC_REDUCE = 1
UNICC_SHIFT  = 2

UNICC_DEBUG = false

PRODUCTION_EMIT_IDX       = 0
PRODUCTION_LENGTH_IDX     = 1
PRODUCTION_LHS_IDX        = 2
PRODUCTION_DEFINITION_IDX = 3 # Unused, comment off when needed

# -----------------------------------------------------------------------------
#                              Helper functions
# -----------------------------------------------------------------------------

function debug(msg)
  global UNICC_DEBUG
  if UNICC_DEBUG is true
    print 'debug:', msg
  endif
endfunction

# -----------------------------------------------------------------------------
#                                Parse tables
# -----------------------------------------------------------------------------

# Action Table
const @@prefix_act = [
@@action-table
]

# GoTo Table
const @@prefix_go = [
@@goto-table
]

# Default productions per state
const @@prefix_def_prod = [
  @@default-productions
]

# DFA selection table
const @@prefix_dfa_select = [
  @@dfa-select - 0
]

# DFA index table
const @@prefix_dfa_idx = [
@@dfa-index
]

# DFA transition chars
const @@prefix_dfa_chars = [
  @@dfa-char
]

# DFA transitions
const @@prefix_dfa_trans = [
  @@dfa-trans
]

# DFA acception states
const @@prefix_dfa_accept = [
@@dfa-accept
]

# Symbol information table
const @@prefix_symbolsGreedy = [
@@symbols
]

# Production information table
const @@prefix_productions = [
@@productions
]

# -----------------------------------------------------------------------------
#                                Helper classes
# -----------------------------------------------------------------------------

#
# Abstract Syntax Tree
#

NodeId = 0

class AST
  method constructor(opcode, value, child)
    global NodeId

    this.opcode = opcode
    this.value  = value
    this.id     = NodeId

    this.children = []
    this.parent   = null
    this.child    = child
    this.prev     = null
    this.next     = null

    NodeId = NodeId + 1

    # TODO: Clean up this mess.
    # Collect children.
    node = child
    while node is defined
      node.parent               = this
      this.children[@afterlast] = node
      # Go to next child if any.
      node = node.next
    endwhile
  endmethod

  method _printInternal(node, deepIdx)
    prefix = ''
    for i in 0 .. deepIdx
      prefix = prefix ~ '..'
    endfor

    if node.value is defined
      print prefix ~ '#' ~ str(node.id), node.opcode, node.value
    else
      print prefix ~ '#' ~ str(node.id), node.opcode
    endif

    for values oneChild in node.children
      this._printInternal(oneChild, deepIdx + 1)
    endfor
  endmethod

  method print()
    print '----------------------------------'
    print ' Abstract Syntax Tree'
    print '----------------------------------'
    this._printInternal(this, 0)
  endmethod
endclass

# -----------------------------------------------------------------------------
#                                Parser class
# -----------------------------------------------------------------------------

class Parser
  method constructor()
    # Map of collected explicit constants.
    # TODO: Handle per module constants.
    this.constantsMap = {}
  endmethod

  method _handleError(line, column, msg)
    die(this.filePath ~ ':' ~ str(line) ~ ':' ~ str(column) ~ ': error: ' ~ msg)
  endmethod

  method _parseInternal(text) -> ast
    global UNICC_ERROR, UNICC_REDUCE, UNICC_SHIFT
    global PRODUCTION_LHS_IDX
    global PRODUCTION_LENGTH_IDX
    global PRODUCTION_EMIT_IDX

    global _symbolsGreedy, _productions, _act, _def_prod
    global _dfa_idx, _dfa_chars, _dfa_trans, _dfa_accept, _dfa_select, _go

    ast        = null
    goOn       = true
    innerGoOn  = true
    masterIter = 1

    #
    # Initialize Parser Control Block.
    #

    debug('going to parse [' ~ str(len(text)) ~ '] bytes')

    input    = text
    inputIdx = 0
    inputLen = len(text)
    line     = 1
    column   = 1

    # Buffer first lookup byte.
    # TODO: Clean up this mess.
    lookupByte = @@eof
    if inputLen > 0
      lookupByte = input[0]
    endif

    buf      = [lookupByte]
    bufSize  = 1
    inputIdx = 1

    # Map of collected explicit constants.
    constantsMap = this.constantsMap

    # Current parser state.
    currentAct = 0
    currentIdx = 0
    currentLhs = 0
    currentRet = null

    stackIdx     = 0
    stackValues  = [null]
    stackNodes   = [null]
    stackStates  = [0]
    stackLines   = [0]
    stackColumns = [0]

    # Begin of main parser loop
    debug('falling into main parser loop')

    while goOn is true
      debug('')
      debug('------------------------------')
      debug('MASTER ITER #' ~ str(masterIter))

      # Get symbol.
      currentSym = -1
      currentLen = 0

      if _dfa_select[stackStates[stackIdx]] > -1
        debug('starting lex...')

        dfa_st = 0
        length = 0
        chr    = 0
        mach   = _dfa_select[stackStates[stackIdx]]
        next   = ord(buf[0])

        if next is @@eof
          # End of file - no more data.
          currentSym = @@eof

        else
          # The are still some input data to read.
          # Read next token.
          while (dfa_st &gt;= 0) and (next isnt @@eof)
            lexInnerGoOn = true
            chr          = _dfa_idx[mach][dfa_st]
            dfa_st       = -1

            while (lexInnerGoOn is true) and (_dfa_chars[chr] &gt; -1)
              if (next &gt;= _dfa_chars[chr]) and (next &lt;= _dfa_chars[chr + 1])
                dfa_st =  _dfa_trans[chr // 2]

                if _dfa_accept[mach][dfa_st] &gt; 0
                  currentLen = length + 1
                  currentSym = _dfa_accept[mach][dfa_st] - 1

                  if (currentSym is @@eof) or (_symbolsGreedy[currentSym] is 0)
                    # End of file or non-greedy symbol.
                    dfa_st = -1
                  endif
                endif

                # Get next char from input.
                length              = length + 1
                numberOfBytesToRead = length - bufSize + 2

                for idx in 0 .. numberOfBytesToRead
                  # Get next character from input stream
                  if inputIdx &lt; inputLen
                    nextChar = input[inputIdx]
                    inputIdx = inputIdx + 1
                  else
                    nextChar = @@eof
                  endif

                  buf[bufSize] = nextChar
                  bufSize      = bufSize + 1
                endfor

                next         = ord(buf[length])
                lexInnerGoOn = false
              endif

              chr = chr + 2
            endwhile
          endwhile
        endif

        debug('lex done: sym=[' ~ str(currentSym) ~ ']')

      elif buf[0] is @@eof
        currentSym = @@eof
      endif

      debug('got symbol: sym=[' ~ str(currentSym) ~ ']' ~ ', len=[' ~ str(currentLen) ~ ']')

      # Get action.
      rv        = -1
      actionIdx = 1
      state     = stackStates[stackIdx]
      act       = _act[state]
      cnt       = act[0] * 3

      while (rv is -1) and (actionIdx &lt; cnt)
        if act[actionIdx] is currentSym
          currentAct = act[actionIdx + 1]

          if currentAct is UNICC_ERROR
            # Force parse error!
            rv = 0
          else
            currentIdx = act[actionIdx + 2]
            rv = 1
          endif
        endif

        actionIdx = actionIdx + 3
      endwhile

      if rv is -1
        # Default production.
        currentIdx = _def_prod[state]
        if currentIdx &gt; -1
          # Reduce.
          currentAct = 1
          rv = 1
        else
          rv = 0
        endif
      endif

      debug('got action: rv=[' ~ str(rv) ~ '], act=[' ~ str(currentAct) ~ '], idx=[' ~ str(currentIdx) ~ ']')

      if rv is 0
        this._handleError(line, column, 'syntax error')
      endif

      # Shift
      if bitand(currentAct, UNICC_SHIFT) isnt 0
        debug('going to shift...')
        nextChar = buf[currentLen]
        stackIdx = stackIdx + 1

        # Execute scanner actions, if existing.
        # Here, UNICC_ON_SHIFT is set to 1, so that shifting-
        # related operations will be performed.
        # Scan actions.
        if false
@@scan_actions
        else
          @@top-value = buf[0]
        endif

        if bitand(currentAct, UNICC_REDUCE) isnt 0
          stackStates[stackIdx] = -1
        else
          stackStates[stackIdx] = currentIdx
        endif

        stackLines[stackIdx]   = line
        stackColumns[stackIdx] = column

        # Pop value from buffer.
        # TODO: Optimize it.
        newValue = ''
        for idx in 0 .. currentLen
          newValue = newValue ~ buf[idx]
        endfor
        @@top-value = newValue

        stackNodes[stackIdx] = null
        buf[currentLen]      = nextChar

        # Perform the shift on input
        if (currentSym isnt @@eof) and (currentSym isnt @@goal-value)

          #
          # BEGIN OF CLEAR INPUT
          #

          if currentLen &gt; 0
            # Update counters for line and column
            for idx in 0 .. currentLen
              if ord(buf[idx]) is 10
                line   = line + 1
                column = 1
              else
                column = column + 1
              endif
            endfor

            # TODO: Optimize it,
            newBufCnt = bufSize - currentLen
            for idx in 0 .. newBufCnt
              buf[idx] = buf[idx + currentLen]
            endfor

            bufSize = newBufCnt
          else
            bufSize  = 0
          endif

          if bufSize is 0
            # Reload one lookup byte.
            buf[0]   = input[inputIdx]
            bufSize  = 1
            inputIdx = inputIdx + 1
          endif

          #
          # END OF CLEAR INPUT
          #

          currentSym = -1
          currentLen = 0
        endif

        debug('shifted')
      endif

      # Reduce
      innerGoOn  = true
      reduceIter = 1

      while (innerGoOn is true) and (bitand(currentAct, UNICC_REDUCE) isnt 0)
        debug('')
        debug('------------------------------')
        debug('REDUCE ITER #' ~ str(masterIter) ~ '.' ~ str(reduceIter))

        # Set default left-hand side
        # Run reduction code
        # TODO: Use switch
        if false
          @@actions
        endif

        currentLhs              = _productions[3 * currentIdx + PRODUCTION_LHS_IDX]
        currentProductionLength = _productions[3 * currentIdx + PRODUCTION_LENGTH_IDX]
        emit                    = _productions[3 * currentIdx + PRODUCTION_EMIT_IDX]

        #
        # Drop right-hand side
        #

        # Pop nodes from the stack.
        node = null
        for i in 0 .. currentProductionLength
          if stackNodes[stackIdx] is defined

            if node is defined
              # Go left to the first node on list.
              # [first] ... ... ... [node]
              while node.prev is defined
                node = node.prev
              endwhile

              node.prev = stackNodes[stackIdx]
              stackNodes[stackIdx].next = node
            endif

            node = stackNodes[stackIdx]
            stackNodes[stackIdx] = null
          endif

          stackIdx = stackIdx - 1
        endfor

        if node is defined
          lnode = stackNodes[stackIdx]

          if lnode is defined
            # Go right to the last node on list.
            # [lnode] ... ... ... [last]
            while lnode.next is defined
              lnode = lnode.next
            endwhile

            lnode.next = node
            node.prev  = lnode
          else
            stackNodes[stackIdx] = node
          endif
        endif

        if emit isnt 0
          # Emit new AST node.
          node                 = new AST(emit, currentRet, stackNodes[stackIdx])
          stackNodes[stackIdx] = node

          # TODO: Review it.
          node.line     = line
          node.column   = column
          node.filePath = this.filePath
        endif

        debug('goal symbol? (lhs=[' ~ str(currentLhs) ~ '], goal=[' ~ str(@@goal) ~ '], stackIdx=[' ~ str(stackIdx) ~ '])')

        # Goal symbol reduced, and stack is empty?
        if (currentLhs is @@goal) and (stackIdx is 0)
          #
          # BEGIN OF CLEAR INPUT
          #

          if currentLen &gt; 0
            # Update counters for line and column
            for idx in 0 .. currentLen
              if ord(buf[idx]) is 10
                line   = line + 1
                column = 1
              else
                column = column + 1
              endif
            endfor

            # TODO: Optimize it,
            newBufCnt = bufSize - currentLen
            for idx in 0 .. newBufCnt
              buf[idx] = buf[idx + currentLen]
            endfor

            bufSize = newBufCnt
          else
            bufSize  = 0
          endif

          if bufSize is 0
            # Reload one lookup byte.
            buf[0]   = input[inputIdx]
            bufSize  = 1
            inputIdx = inputIdx + 1
          endif

          #
          # END OF CLEAR INPUT
          #

          stackValues[stackIdx] = currentRet

          ast        = stackNodes[stackIdx]
          currentSym = -1
          currentLen = 0
          innerGoOn  = false

        else
          # Get goto.
          rv    = 0
          goIdx = 1
          state = stackStates[stackIdx]
          go    = _go[state]
          cnt   = go[0] * 3

          while (rv is 0) and (goIdx &lt; cnt)
            if go[goIdx] is currentLhs
              currentAct = go[goIdx + 1]
              currentIdx = go[goIdx + 2]
              rv         = 1
            endif

            goIdx = goIdx + 3
          endwhile

          # Push new item to state stack.
          stackIdx               = stackIdx + 1
          stackNodes[stackIdx]   = null
          stackValues[stackIdx]  = currentRet
          stackLines[stackIdx]   = line
          stackColumns[stackIdx] = column

          if bitand(currentAct, UNICC_REDUCE) isnt 0
            stackStates[stackIdx] = -1
          else
            stackStates[stackIdx] = currentIdx
          endif
        endif

        # Count reduce iters for debug purposes.
        reduceIter = reduceIter + 1

        debug('reduced')
      endwhile

      debug('END CONDITION: reduce=[' ~ str(bitand(currentAct, UNICC_REDUCE)) ~ '], idx=[' ~ str(currentIdx) ~ '], goalIdx=[' ~ str(@@goal-production) ~ ']')

      if (bitand(currentAct, UNICC_REDUCE) isnt 0) and (currentIdx is @@goal-production)
        goOn = false
      endif

      masterIter = masterIter + 1

      if masterIter > 1000000
        die('MAX ITERS reached!')
      endif
    endwhile
  endmethod

  method parseFile(path) -> ast
    # Load source code from file.
    source        = FileLoad(path)
    this.filePath = path

    # Parse source into AST tree.
    ast = this._parseInternal(source)
  endmethod

  method parseText(text) -> ast
    this.filePath = ''
    ast           = this._parseInternal(text)
  endmethod

endclass

</file>
</generator>
