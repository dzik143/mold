################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64Parser.mold'
import 'X64Translator.mold'
import 'X64Encoder.mold'
import 'PEWriter.mold'
import 'Buffer.mold'

class X64Compiler
  method constructor()
    this.parser     = new X64Parser()
    this.translator = new X64Translator()
    this.encoder    = new X64Encoder()
    this.tempBuffer = new Buffer()
    this.peWriter   = new PEWriter()

    # Set up toolchain.
    # We want to catch generated code to temporary buffer before
    # emit to caller.
    this.parser.connectTo(this.translator).connectTo(this.encoder).connectTo(this.tempBuffer)
  endmethod

  method compileToFile(targetBinPath, sourceAsmPath)
    this.peWriter.create(targetBinPath)
    this.compile(this.peWriter, sourceAsmPath)
    this.peWriter.close()
  endmethod

  method compile(outputObject, pathAsm)
    parser     = this.parser
    tempBuffer = this.tempBuffer
    translator = this.translator
    parser     = this.parser

    # Compile source into temporary buffer.
    tempBuffer.clear()
    parser.parseFile(pathAsm)

/*
    print ''
    print 'Buffer before patches:'
    for values v in buffer.data
      __mold_printToStdOutput(hex(v))
      __mold_printToStdOutput(' ')
      peWriter.emitByte(v)
    endfor
    print ''
*/

    # Patch generated code to handle unresolved references
    # and changed related to various jmp length (rel8 vs rel32).
    # Possible improvement: Avoid memory copy.
    codeSizeDiffTotal = 0
    readPos           = 0
    refs              = parser.getArrayOfRefs()

    # Check all instructions, which reference to another place.
    for values item in refs
      # Resolve label.
      oldCodeSize = item.codeSize
      labelOffset = parser.resolveLabel(item.label)
      posBefore   = item.offset
      item.imm    = labelOffset - posBefore - oldCodeSize

      print 'Patching... [', item.label, '] to [', item.imm, '] at [', item.offset, ']'

      # Go to next referencing instruction.
      tempBuffer.setCurrentPosition(posBefore, 0)

      # If there were any moved code before, we must apply this offset
      # to all following instructions.
      if labelOffset < posBefore
        item.imm = item.imm + codeSizeDiffTotal
      endif

      # Translate the same instruction once again, but using updated
      # label offset.
      translator.processOneItem(item)

      # Calculate new instruction size after patch.
      newCodeSize  = tempBuffer.getCurrentPosition() - posBefore
      codeSizeDiff = item.codeSize - newCodeSize

      # Pass all code from last patched code to current one.
      # We know there are no any references to patch in the middle.
      for pos in readPos .. item.offset + newCodeSize
        outputObject.emitByte(tempBuffer.data[pos])
      endfor

      # Skip current instruction in orginal read buffer i.e.
      # before patches.
      readPos = posBefore + oldCodeSize

      if codeSizeDiff < 0
        # Fatal - instruction is longer after patch.
        # Should never happen on production.
        die('error: code overwrite after patch')

      else
        # Track total code moves at current offset for further
        # instructions.
        codeSizeDiffTotal = codeSizeDiffTotal + codeSizeDiff
      endif
    endfor

    # Copy code to the final buffer taking into account new
    # instruction size after patch.
    # Before: cc cc cc xx xx xx ...
    # After:  cc cc cc ...
    # Where xx is bytes, which remain unused after code patch applied.
    for pos in readPos .. tempBuffer.getSize()
      outputObject.emitByte(tempBuffer.data[pos])
    endfor

    # Clean up temporary buffer.
    tempBuffer.clear()
  endmethod
endclass
