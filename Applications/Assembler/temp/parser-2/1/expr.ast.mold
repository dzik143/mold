# Parser module generated by unicc from expr.ast.par.
# DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!


################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (c) 2015, 2018 Sylwester Wysocki (sw143@wp.pl).                    #
#                                                                              #
# The Mold code and any derived work however based on this software are        #
# copyright of Sylwester Wysocki. Redistribution and use of the present        #
# software is allowed according to terms specified in the file LICENSE         #
# which comes in the source distribution.                                      #
#                                                                              #
# All rights reserved.                                                         #
#                                                                              #
################################################################################

# -----------------------------------------------------------------------------
#                                Constants
# -----------------------------------------------------------------------------

UNICC_ERROR  = 0
UNICC_REDUCE = 1
UNICC_SHIFT  = 2
UNICC_EOF    = 0

UNICC_DEBUG = false

PRODUCTION_EMIT_IDX       = 0
PRODUCTION_LENGTH_IDX     = 1
PRODUCTION_LHS_IDX        = 2
PRODUCTION_DEFINITION_IDX = 3 # Unused, comment off when needed

# -----------------------------------------------------------------------------
#                              Helper functions
# -----------------------------------------------------------------------------

null = 0

function debug(msg)
  global UNICC_DEBUG
  if UNICC_DEBUG is true
    print 'debug:', msg
  endif
endfunction

# -----------------------------------------------------------------------------
#                                Parse tables
# -----------------------------------------------------------------------------

# Action Table
const _act = [
  [ 1, 10,3,11  ],
  [ 1, 10,3,11  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 1, 10,3,11  ],
  [ 1, 10,3,11  ],
  [ 5, 9,2,7 , 8,2,8 , 7,2,9 , 6,2,10 , 0,3,0  ],
  [ 1, 5,2,15  ],
  [ 1, 10,3,11  ],
  [ 1, 10,3,11  ],
  [ 1, 10,3,11  ],
  [ 1, 10,3,11  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 1, 10,3,11  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 2, 7,2,9 , 6,2,10  ],
  [ 2, 7,2,9 , 6,2,10  ],
  [ 0 ],
  [ 0 ],
  [ 4, 9,2,7 , 8,2,8 , 7,2,9 , 6,2,10  ],
  [ 1, 3,2,24  ],
  [ 1, 4,2,26  ],
  [ 1, 10,3,11  ],
  [ 2, 2,2,3 , 1,2,4  ],
  [ 1, 10,3,11  ],
  [ 4, 9,2,7 , 8,2,8 , 7,2,9 , 6,2,10  ]
]

# GoTo Table
const _go = [
  [ 3, 23,3,13 , 22,2,1 , 21,2,2  ],
  [ 1, 23,3,12  ],
  [ 4, 27,3,25 , 26,2,5 , 16,2,6 , 13,3,8  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,23  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,20  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ],
  [ 1, 15,2,16  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,16  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,17  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,18  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,19  ],
  [ 3, 26,2,17 , 16,2,6 , 13,3,8  ],
  [ 3, 26,2,18 , 16,2,6 , 13,3,8  ],
  [ 3, 26,2,19 , 16,2,6 , 13,3,8  ],
  [ 3, 26,2,20 , 16,2,6 , 13,3,8  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,21  ],
  [ 5, 26,2,21 , 25,2,22 , 24,2,23 , 16,2,6 , 13,3,8  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ],
  [ 1, 12,2,25  ],
  [ 1, 14,3,5  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,24  ],
  [ 3, 26,2,27 , 16,2,6 , 13,3,8  ],
  [ 3, 23,3,13 , 22,2,1 , 21,3,22  ],
  [ 4, 20,2,11 , 19,2,12 , 18,2,13 , 17,2,14  ]
]

# Default productions per state
const _def_prod = [
  15, 14, -1, 15, 15, -1, -1, 15, 15, 15, 15, -1, -1, -1, -1, 15, 7, 1, 2, 3, 4, 10, 6, -1, 15, -1, 15, 9
]

# DFA selection table
const _dfa_select = [
  0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 2, 2, 2, 2, 7, 8, 9, 9, 9, 9, 9, 10, 11, 0, 2, 3, 9 - 0
]

# DFA index table
const _dfa_idx = [
  [ 0 * 2, 5 * 2, 7 * 2, 9 * 2 ],
  [ 10 * 2, 22 * 2, 23 * 2, 24 * 2, 25 * 2, 26 * 2, 27 * 2, 28 * 2, 29 * 2, 31 * 2, 33 * 2 ],
  [ 34 * 2, 37 * 2, 39 * 2 ],
  [ 41 * 2, 50 * 2, 51 * 2, 52 * 2, 53 * 2, 54 * 2, 55 * 2, 56 * 2 ],
  [ 57 * 2, 61 * 2, 62 * 2 ],
  [ 63 * 2, 68 * 2, 69 * 2, 70 * 2, 71 * 2 ],
  [ 72 * 2, 74 * 2 ],
  [ 75 * 2, 81 * 2, 82 * 2, 84 * 2, 86 * 2 ],
  [ 87 * 2, 91 * 2, 92 * 2, 94 * 2 ],
  [ 96 * 2, 103 * 2, 104 * 2, 105 * 2, 106 * 2, 107 * 2, 108 * 2 ],
  [ 109 * 2, 112 * 2, 113 * 2 ],
  [ 114 * 2, 116 * 2 ]
]

# DFA transition chars
const _dfa_chars = [
  48, 57, 97, 122, 9, 9, 32, 32, -1, -1, 48, 57, -1, -1, 97, 122, -1, -1, -1, -1, 40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 48, 57, 97, 122, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 57, -1, -1, 97, 122, -1, -1, -1, -1, 48, 57, 97, 122, -1, -1, 48, 57, -1, -1, 97, 122, -1, -1, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 40, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, 42, 42, 43, 43, 45, 45, 47, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 40, -1, -1, -1, -1, 41, 41, 48, 57, 97, 122, 9, 9, 32, 32, -1, -1, -1, -1, 48, 57, -1, -1, 97, 122, -1, -1, -1, -1, 41, 41, 48, 57, 97, 122, -1, -1, -1, -1, 48, 57, -1, -1, 97, 122, -1, -1, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 47, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 44, 44, -1, -1, -1, -1, -1, -1, 41, 41, -1, -1, -1, -1
]

# DFA transitions
const _dfa_trans = [
  1, 2, 3, 3, -1, 1, -1, 2, -1, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, 9, -1, -1, 1, 2, -1, 1, -1, 2, -1, 1, 2, 3, 4, 5, 6, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 2, -1, -1, -1, 1, 2, 3, 4, -1, -1, -1, -1, -1, 1, -1, -1, 1, 2, 3, 4, 4, -1, -1, 2, -1, 3, -1, -1, 1, 2, 3, -1, -1, 2, -1, 3, -1, 1, 2, 3, 4, 5, 6, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, 1, -1, -1
]

# DFA acception states
const _dfa_accept = [
  [ 0, 3, 2, 11 ],
  [ 0, 6, 5, 8, 10, 4, 9, 7, 3, 2, 11 ],
  [ 0, 3, 2 ],
  [ 0, 5, 8, 10, 4, 9, 7, 11 ],
  [ 0, 6, 11 ],
  [ 0, 8, 10, 9, 7 ],
  [ 0, 6 ],
  [ 0, 5, 3, 2, 11 ],
  [ 0, 5, 3, 2 ],
  [ 0, 5, 8, 10, 4, 9, 7 ],
  [ 0, 5, 4 ],
  [ 0, 5 ]
]

# Symbol information table
const _symbolsGreedy = [
  1 /* 3 | 0 | 0 | 0 |' ' | '&eof' */,
  1 /* 2 | 0 | 0 | 1 |' ' | 'ident' */,
  1 /* 2 | 0 | 0 | 2 |' ' | 'integer' */,
  1 /* 1 | 0 | 0 | 3 |' ' | ',' */,
  1 /* 1 | 0 | 0 | 4 |' ' | ')' */,
  1 /* 1 | 0 | 0 | 5 |' ' | '(' */,
  1 /* 1 | 0 | 0 | 6 |' ' | '/' */,
  1 /* 1 | 0 | 0 | 7 |' ' | '*' */,
  1 /* 1 | 0 | 0 | 8 |' ' | '-' */,
  1 /* 1 | 0 | 0 | 9 |' ' | '+' */,
  1 /* 1 | 0 | 1 | 10 |' ' | 't ' */,
  1 /* 0 | 0 | 0 | 11 |' ' | 'calculator'' */,
  1 /* 0 | 0 | 0 | 12 |' ' | ','' */,
  1 /* 0 | 0 | 0 | 13 |' ' | 'integer'' */,
  1 /* 0 | 0 | 0 | 14 |' ' | ')'' */,
  1 /* 0 | 0 | 0 | 15 |' ' | '('' */,
  1 /* 0 | 0 | 0 | 16 |' ' | 'ident'' */,
  1 /* 0 | 0 | 0 | 17 |' ' | '/'' */,
  1 /* 0 | 0 | 0 | 18 |' ' | '*'' */,
  1 /* 0 | 0 | 0 | 19 |' ' | '-'' */,
  1 /* 0 | 0 | 0 | 20 |' ' | '+'' */,
  1 /* 0 | 1 | 1 | 21 |' ' | '&whitespace*' */,
  1 /* 0 | 1 | 1 | 22 |' ' | '&whitespace+' */,
  1 /* 0 | 1 | 1 | 23 |' ' | '&whitespace' */,
  1 /* 0 | 0 | 0 | 24 |' ' | 'parameter_list?' */,
  1 /* 0 | 0 | 0 | 25 |' ' | 'parameter_list' */,
  1 /* 0 | 0 | 0 | 26 |' ' | 'expression' */,
  1 /* 0 | 0 | 0 | 27 |' ' | 'calculator' */
]

# Production information table
const _productions = [
  'expr', 2, 27 /* 0 | 'calculator : expression ~&eof' */,
  'add', 3, 26 /* 1 | 'expression : expression +' expression' */,
  'sub', 3, 26 /* 2 | 'expression : expression -' expression' */,
  'mul', 3, 26 /* 3 | 'expression : expression *' expression' */,
  'div', 3, 26 /* 4 | 'expression : expression /' expression' */,
  'call', 4, 26 /* 5 | 'expression : ident' (' parameter_list? )'' */,
  '', 1, 24 /* 6 | 'parameter_list? : parameter_list' */,
  '', 0, 24 /* 7 | 'parameter_list? : ' */,
  'int', 1, 26 /* 8 | 'expression : integer'' */,
  '', 3, 25 /* 9 | 'parameter_list : parameter_list ,' expression' */,
  '', 1, 25 /* 10 | 'parameter_list : expression' */,
  '', 1, 23 /* 11 | '&whitespace : 't '' */,
  '', 2, 22 /* 12 | '&whitespace+ : &whitespace+ &whitespace' */,
  '', 1, 22 /* 13 | '&whitespace+ : &whitespace' */,
  '', 1, 21 /* 14 | '&whitespace* : &whitespace+' */,
  '', 0, 21 /* 15 | '&whitespace* : ' */,
  '', 2, 20 /* 16 | '+' : '+' &whitespace*' */,
  '', 2, 19 /* 17 | '-' : '-' &whitespace*' */,
  '', 2, 18 /* 18 | '*' : '*' &whitespace*' */,
  '', 2, 17 /* 19 | '/' : '/' &whitespace*' */,
  '', 2, 16 /* 20 | 'ident' : @ident &whitespace*' */,
  '', 2, 15 /* 21 | '(' : '(' &whitespace*' */,
  '', 2, 14 /* 22 | ')' : ')' &whitespace*' */,
  '', 2, 13 /* 23 | 'integer' : @integer &whitespace*' */,
  '', 2, 12 /* 24 | ',' : ',' &whitespace*' */,
  '', 2, 11 /* 25 | 'calculator' : &whitespace* calculator' */
]

# -----------------------------------------------------------------------------
#                                Helper classes
# -----------------------------------------------------------------------------

#
# Abstract Syntax Tree
#

NodeId = 0

class AST
  method constructor(emit, token)
    global null
    global NodeId

    this.parent = null
    this.child  = null
    this.prev   = null
    this.next   = null

    this.emit  = emit
    this.token = token
    this.id    = NodeId

    NodeId = NodeId + 1
  endmethod

  method _printInternal(node, deepIdx)
    global null

    while node isnt null
      prefix = ''
      for i in 0 .. deepIdx
        prefix = prefix + '..'
      endfor

      if (node.token isnt null)
        print prefix + node.emit, node.token
      else
        print prefix + node.emit
      endif

      this._printInternal(node.child, deepIdx + 1)

      node = node.next
    endwhile
  endmethod

  method print()
    print '----------------------------------'
    print ' Abstract Syntax Tree'
    print '----------------------------------'
    this._printInternal(this, 0)
  endmethod

  method _convertInternal(node, deepIdx) -> rv
    global AST_DATA_INTEGER, AST_DATA_FLOAT, AST_DATA_DOUBLE, AST_DATA_STRING
    global AST_DATA_BOOL, AST_DATA_OBJECT, AST_DATA_NULL, AST_DATA_UNDEFINED
    global AST_DATA_ARRAY, AST_DATA_MAP, AST_OPCODE_VARIABLE
    global AST_OPCODE_PROGRAM, AST_OPCODE_NEG
    global AST_OPCODE_BOOL_AND, AST_OPCODE_BOOL_OR, AST_OPCODE_IDIV
    global AST_OPCODE_REFERENCE, AST_OPCODE_CALL, AST_OPCODE_BOOL_NOT
    global AST_OPCODE_ADD, AST_OPCODE_SUB, AST_OPCODE_MUL, AST_OPCODE_DIV
    global AST_OPCODE_IDIV, AST_OPCODE_INC, AST_OPCODE_DEC
    global AST_OPCODE_COMPARE_EQ, AST_OPCODE_COMPARE_NEQ, AST_OPCODE_COMPARE_GT
    global AST_OPCODE_COMPARE_GE, AST_OPCODE_COMPARE_LT, AST_OPCODE_COMPARE_LE
    global AST_OPCODE_CALL_NEW, AST_OPCODE_INVOKE_METHOD

    global AST_OPCODE_PROGRAM, AST_OPCODE_BLOCK, AST_OPCODE_DECLARE_OR_ASSIGN
    global AST_OPCODE_FOR_VALUES_RANGE, AST_OPCODE_WHILE
    global AST_OPCODE_CALL, AST_OPCODE_FUNCTION, AST_OPCODE_IF, AST_OPCODE_SWITCH
    global AST_OPCODE_VARIABLE, AST_OPCODE_REFERENCE
    global AST_OPCODE_CLASS, AST_OPCODE_CLASS_METHOD, AST_OPCODE_INVOKE_METHOD
    global AST_OPCODE_NOP, AST_DATA_STRING, AST_OPCODE_FOR_VALUES_RANGE
    global AST_OPCODE_CALL_DELETE

    global AST_OPCODE_FOR_VALUES
    global AST_OPCODE_FOR_INDEXES
    global AST_OPCODE_FOR_INDEXES_VALUES
    global AST_OPCODE_FOR_KEYS
    global AST_OPCODE_FOR_KEYS_VALUES

    global null

    rv          = {}
    children    = []
    childrenCnt = 0
    emit        = node.emit
    value       = node.token

    if emit is 'int'
      opcode = AST_DATA_INTEGER

    elif emit is 'float'
      opcode = AST_DATA_DOUBLE

    elif emit is 'string'
      opcode = AST_DATA_STRING

    elif emit is 'bool'
      opcode = AST_DATA_BOOL

    elif emit is 'unused'
      opcode = AST_DATA_OBJECT

    elif emit is 'null'
      opcode = AST_DATA_NULL

    elif emit is 'undefined'
      opcode = AST_DATA_UNDEFINED

    elif emit is 'array'
      opcode = AST_DATA_ARRAY

    elif emit is 'map'
      opcode = AST_DATA_MAP

    elif emit is 'program'
      opcode = AST_OPCODE_PROGRAM

    elif emit is 'block'
      opcode = AST_OPCODE_BLOCK

    elif emit is 'print'
      opcode = AST_OPCODE_CALL

    elif emit is 'call'
      opcode = AST_OPCODE_CALL

    elif emit is 'neg'
      opcode = AST_OPCODE_NEG

    elif emit is 'add'
      opcode = AST_OPCODE_ADD

    elif emit is 'sub'
      opcode = AST_OPCODE_SUB

    elif emit is 'mul'
      opcode = AST_OPCODE_MUL

    elif emit is 'div'
      opcode = AST_OPCODE_DIV

    elif emit is 'inc'
      opcode = AST_OPCODE_INC

    elif emit is 'dec'
      opcode = AST_OPCODE_DEC

    elif emit is 'idiv'
      opcode = AST_OPCODE_IDIV

    elif emit is 'store'
      opcode = AST_OPCODE_DECLARE_OR_ASSIGN

    elif emit is 'var'
      opcode = AST_OPCODE_VARIABLE

    elif emit is 'index'
      opcode = AST_OPCODE_REFERENCE

    elif emit is 'member'
      opcode = AST_DATA_STRING

    elif emit is 'for'
      opcode = AST_OPCODE_FOR_VALUES_RANGE

    elif emit is 'for_values'
      opcode = AST_OPCODE_FOR_VALUES

    elif emit is 'for_indexes'
      opcode = AST_OPCODE_FOR_INDEXES

    elif emit is 'for_keys'
      opcode = AST_OPCODE_FOR_KEYS

    elif emit is 'for_keys_values'
      opcode = AST_OPCODE_FOR_KEYS_VALUES

    elif emit is 'for_keys_indexes_values'
      opcode = AST_OPCODE_FOR_INDEXES_VALUES

    elif emit is 'while'
      opcode = AST_OPCODE_WHILE

    elif emit is 'cmpeq'
      opcode = AST_OPCODE_COMPARE_EQ

    elif emit is 'cmpne'
      opcode = AST_OPCODE_COMPARE_NEQ

    elif emit is 'cmpgt'
      opcode = AST_OPCODE_COMPARE_GT

    elif emit is 'cmpge'
      opcode = AST_OPCODE_COMPARE_GE

    elif emit is 'cmplt'
      opcode = AST_OPCODE_COMPARE_LT

    elif emit is 'cmple'
      opcode = AST_OPCODE_COMPARE_LE

    elif emit is 'bor'
      opcode = AST_OPCODE_BOOL_OR

    elif emit is 'band'
      opcode = AST_OPCODE_BOOL_AND

    elif emit is 'not'
      opcode = AST_OPCODE_BOOL_NOT

    elif emit is 'function'
      opcode = AST_OPCODE_FUNCTION
      rv['name']      = value['name']
      rv['params']    = value['parameters']
      rv['paramsCnt'] = len(value['parameters'])
      rv['rv']        = value['rv']

    elif emit is 'if'
      opcode = AST_OPCODE_IF

    elif emit is 'elif'
      opcode = AST_OPCODE_IF

    elif emit is 'class'
      opcode = AST_OPCODE_CLASS
      rv['name']     = value['name']
      rv['baseName'] = value['baseName']

    elif emit is 'method'
      opcode = AST_OPCODE_CLASS_METHOD

      newParams = ['this']
      params    = value['parameters']
      paramsCnt = len(params)

      for idx in 0 .. paramsCnt
        newParams[idx + 1] = params[idx]
      endfor

      rv['name']      = value['name']
      rv['params']    = newParams
      rv['paramsCnt'] = len(newParams)
      rv['rv']        = value['rv']

    elif emit is 'vcall'
      opcode = AST_OPCODE_INVOKE_METHOD

    elif emit is 'new'
      opcode = AST_OPCODE_CALL_NEW

    elif emit is 'delete'
      opcode = AST_OPCODE_CALL_DELETE

    else
      # TODO: Remove opcode assign.
      opcode = -1
      die('Unrecognized opcode ' + emit)
    endif

    rv['opcode'] = opcode
    rv['value']  = value
    rv['id']     = node.id

    node = node.child

    while node isnt null
      newChild              = this._convertInternal(node, deepIdx + 1)
      children[childrenCnt] = newChild
      childrenCnt           = childrenCnt + 1
      node                  = node.next

      newChild.parent = node
    endwhile

    rv['children']    = children
    rv['childrenCnt'] = childrenCnt
  endmethod

  method convert() -> rv
    #print '----------------------------------'
    #print ' Convert Abstract Syntax Tree'
    #print '----------------------------------'

    rv = this._convertInternal(this, 0)
  endmethod

endclass

# -----------------------------------------------------------------------------
#                                Parser class
# -----------------------------------------------------------------------------

class Parser
  method _handleError(line, column, msg)
    die(this.filePath + ':' + str(line) + ':' + str(column) + ': error: ' + msg)
  endmethod
  
  method _parseInternal(text) -> ast
    global null
    global UNICC_ERROR, UNICC_REDUCE, UNICC_SHIFT
    global PRODUCTION_LHS_IDX
    global PRODUCTION_LENGTH_IDX
    global PRODUCTION_EMIT_IDX
    global UNICC_EOF

    global _symbolsGreedy, _productions, _act, _def_prod
    global _dfa_idx, _dfa_chars, _dfa_trans, _dfa_accept, _dfa_select, _go

    ast        = null
    goOn       = true
    innerGoOn  = true
    masterIter = 1

    #
    # Initialize Parser Control Block.
    #

    debug('going to parse [' + str(len(text)) + '] bytes')

    input    = text
    inputIdx = 0
    inputLen = len(text)
    line     = 1
    column   = 1

    # Buffer first lookup byte.
    # TODO: Clean up this mess.
    lookupByte = UNICC_EOF
    if inputLen > 0
      lookupByte = input[0]
    endif

    buf      = [lookupByte]
    bufSize  = 1
    inputIdx = 1

    # Current parser state.
    currentAct = 0
    currentIdx = 0
    currentLhs = 0
    currentRet = null

    stackIdx     = 0
    stackValues  = [0]
    stackNodes   = [0]
    stackStates  = [0]
    stackLines   = [0]
    stackColumns = [0]

    # Begin of main parser loop
    debug('falling into main parser loop')

    while goOn is true
      debug('')
      debug('------------------------------')
      debug('MASTER ITER #' + str(masterIter))

      # Get symbol.
      currentSym = -1
      currentLen = 0

      if _dfa_select[stackStates[stackIdx]] > -1
        debug('starting lex...')

        dfa_st = 0
        length = 0
        chr    = 0
        mach   = _dfa_select[stackStates[stackIdx]]
        next   = ord(buf[0])

        if next is UNICC_EOF
          # End of file - no more data.
          currentSym = 0

        else
          # The are still some input data to read.
          # Read next token.
          while (dfa_st >= 0) and (next isnt UNICC_EOF)
            lexInnerGoOn = true
            chr          = _dfa_idx[mach][dfa_st]
            dfa_st       = -1

            while (lexInnerGoOn is true) and (_dfa_chars[chr] > -1)
              if (next >= _dfa_chars[chr]) and (next <= _dfa_chars[chr + 1])
                dfa_st =  _dfa_trans[chr // 2]

                if _dfa_accept[mach][dfa_st] > 0
                  currentLen = length + 1
                  currentSym = _dfa_accept[mach][dfa_st] - 1

                  if (currentSym is 0) or (_symbolsGreedy[currentSym] is 0)
                    # End of file or non-greedy symbol.
                    dfa_st = -1
                  endif
                endif

                # Get next char from input.
                length              = length + 1
                numberOfBytesToRead = length - bufSize + 2

                for idx in 0 .. numberOfBytesToRead
                  # Get next character from input stream
                  if inputIdx < inputLen
                    nextChar = input[inputIdx]
                    inputIdx = inputIdx + 1
                  else
                    nextChar = UNICC_EOF
                  endif

                  buf[bufSize] = nextChar
                  bufSize      = bufSize + 1
                endfor

                next         = ord(buf[length])
                lexInnerGoOn = false
              endif

              chr = chr + 2
            endwhile
          endwhile
        endif

        debug('lex done: sym=[' + str(currentSym) + ']')

      elif buf[0] is UNICC_EOF
        currentSym = 0
      endif

      debug('got symbol: sym=[' + str(currentSym) + ']' + ', len=[' + str(currentLen) + ']')

      # Get action.
      rv        = -1
      actionIdx = 1
      state     = stackStates[stackIdx]
      act       = _act[state]
      cnt       = act[0] * 3

      while (rv is -1) and (actionIdx < cnt)
        if act[actionIdx] is currentSym
          currentAct = act[actionIdx + 1]

          if currentAct is UNICC_ERROR
            # Force parse error!
            rv = 0
          else
            currentIdx = act[actionIdx + 2]
            rv = 1
          endif
        endif

        actionIdx = actionIdx + 3
      endwhile

      if rv is -1
        # Default production.
        currentIdx = _def_prod[state]
        if currentIdx > -1
          # Reduce.
          currentAct = 1
          rv = 1
        else
          rv = 0
        endif
      endif

      debug('got action: rv=[' + str(rv) + '], act=[' + str(currentAct) + '], idx=[' + str(currentIdx) + ']')

      if rv is 0
        this._handleError(line, column, 'syntax error')
      endif

      # Shift
      if bitand(currentAct, UNICC_SHIFT) isnt 0
        debug('going to shift...')
        nextChar = buf[currentLen]
        stackIdx = stackIdx + 1

        # Execute scanner actions, if existing.
        # Here, UNICC_ON_SHIFT is set to 1, so that shifting-
        # related operations will be performed.
        # Scan actions.
        if false

        else
          stackValues[stackIdx - 0] = buf[0]
        endif

        if bitand(currentAct, UNICC_REDUCE) isnt 0
          stackStates[stackIdx] = -1
        else
          stackStates[stackIdx] = currentIdx
        endif

        stackLines[stackIdx]   = line
        stackColumns[stackIdx] = column

        # Pop value from buffer.
        # TODO: Optimize it.
        newValue = ''
        for idx in 0 .. currentLen
          newValue = newValue + buf[idx]
        endfor
        stackValues[stackIdx - 0] = newValue

        stackNodes[stackIdx] = null
        buf[currentLen] = nextChar

        # Perform the shift on input
        if (currentSym isnt 0) and (currentSym isnt stackValues[stackIdx - 0])

          #
          # BEGIN OF CLEAR INPUT
          #

          if currentLen > 0
            # Update counters for line and column
            for idx in 0 .. currentLen
              if ord(buf[idx]) is 10
                line   = line + 1
                column = 1
              else
                column = column + 1
              endif
            endfor

            # TODO: Optimize it,
            newBufCnt = bufSize - currentLen
            for idx in 0 .. newBufCnt
              buf[idx] = buf[idx + currentLen]
            endfor

            bufSize = newBufCnt
          else
            bufSize  = 0
          endif

          if bufSize is 0
            # Reload one lookup byte.
            buf[0]   = input[inputIdx]
            bufSize  = 1
            inputIdx = inputIdx + 1
          endif

          #
          # END OF CLEAR INPUT
          #

          currentSym = -1
          currentLen = 0
        endif

        debug('shifted')
      endif

      # Reduce
      innerGoOn  = true
      reduceIter = 1

      while (innerGoOn is true) and (bitand(currentAct, UNICC_REDUCE) isnt 0)
        debug('')
        debug('------------------------------')
        debug('REDUCE ITER #' + str(masterIter) + '.' + str(reduceIter))

        # Set default left-hand side
        # Run reduction code
        # TODO: Use switch
        if false
                  elif currentIdx is 0
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 1
            currentRet = stackValues[stackIdx - 2] 

        elif currentIdx is 2
            currentRet = stackValues[stackIdx - 2] 

        elif currentIdx is 3
            currentRet = stackValues[stackIdx - 2] 

        elif currentIdx is 4
            currentRet = stackValues[stackIdx - 2] 

        elif currentIdx is 5
            currentRet = stackValues[stackIdx - 3] 

        elif currentIdx is 6
            currentRet = stackValues[stackIdx - 0] 

        elif currentIdx is 7
       

        elif currentIdx is 8
            currentRet = stackValues[stackIdx - 0] 

        elif currentIdx is 9
            currentRet = stackValues[stackIdx - 2] 

        elif currentIdx is 10
            currentRet = stackValues[stackIdx - 0] 

        elif currentIdx is 16
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 17
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 18
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 19
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 20
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 21
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 22
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 23
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 24
            currentRet = stackValues[stackIdx - 1] 

        elif currentIdx is 25
            currentRet = stackValues[stackIdx - 1] 


        endif

        currentLhs              = _productions[3 * currentIdx + PRODUCTION_LHS_IDX]
        currentProductionLength = _productions[3 * currentIdx + PRODUCTION_LENGTH_IDX]
        emit                    = _productions[3 * currentIdx + PRODUCTION_EMIT_IDX]

        # Drop right-hand side
        node = null

        for i in 0 .. currentProductionLength
          if stackNodes[stackIdx] isnt null
            if node isnt null
              while (node.prev isnt null)
                node = node.prev
              endwhile

              node.prev = stackNodes[stackIdx]
              stackNodes[stackIdx].next = node
            endif

            node = stackNodes[stackIdx]
            stackNodes[stackIdx] = null
          endif

          stackIdx = stackIdx - 1
        endfor

        if node isnt null
          lnode = stackNodes[stackIdx]

          if lnode isnt null
            while lnode.next isnt null
              lnode = lnode.next
            endwhile

            lnode.next = node
            node.prev  = lnode
          else
            stackNodes[stackIdx] = node
          endif
        endif

        if emit isnt ''
          node                 = new AST(emit, currentRet)
          node.child           = stackNodes[stackIdx]
          stackNodes[stackIdx] = node
        endif

        debug('goal symbol? (lhs=[' + str(currentLhs) + '], goal=[' + str(11) + '], stackIdx=[' + str(stackIdx) + '])')

        # Goal symbol reduced, and stack is empty?
        if (currentLhs is 11) and (stackIdx is 0)
          #
          # BEGIN OF CLEAR INPUT
          #

          if currentLen > 0
            # Update counters for line and column
            for idx in 0 .. currentLen
              if ord(buf[idx]) is 10
                line   = line + 1
                column = 1
              else
                column = column + 1
              endif
            endfor

            # TODO: Optimize it,
            newBufCnt = bufSize - currentLen
            for idx in 0 .. newBufCnt
              buf[idx] = buf[idx + currentLen]
            endfor

            bufSize = newBufCnt
          else
            bufSize  = 0
          endif

          if bufSize is 0
            # Reload one lookup byte.
            buf[0]   = input[inputIdx]
            bufSize  = 1
            inputIdx = inputIdx + 1
          endif

          #
          # END OF CLEAR INPUT
          #

          stackValues[stackIdx] = currentRet

          ast        = stackNodes[stackIdx]
          currentSym = -1
          currentLen = 0
          innerGoOn  = false

        else
          # Get goto.
          rv    = 0
          goIdx = 1
          state = stackStates[stackIdx]
          go    = _go[state]
          cnt   = go[0] * 3

          while (rv is 0) and (goIdx < cnt)
            if go[goIdx] is currentLhs
              currentAct = go[goIdx + 1]
              currentIdx = go[goIdx + 2]
              rv         = 1
            endif

            goIdx = goIdx + 3
          endwhile

          # Push new item to state stack.
          stackIdx               = stackIdx + 1
          stackNodes[stackIdx]   = null
          stackValues[stackIdx]  = currentRet
          stackLines[stackIdx]   = line
          stackColumns[stackIdx] = column

          if bitand(currentAct, UNICC_REDUCE) isnt 0
            stackStates[stackIdx] = -1
          else
            stackStates[stackIdx] = currentIdx
          endif
        endif

        # Count reduce iters for debug purposes.
        reduceIter = reduceIter + 1

        debug('reduced')
      endwhile

      debug('END CONDITION: reduce=[' + str(bitand(currentAct, UNICC_REDUCE)) + '], idx=[' + str(currentIdx) +'], goalIdx=[' + str(25) + ']')

      if (bitand(currentAct, UNICC_REDUCE) isnt 0) and (currentIdx is 25)
        goOn = false
      endif

      masterIter = masterIter + 1

      if masterIter > 1000000
        die('MAX ITERS reached!')
      endif
    endwhile
  endmethod

  method parseFile(path) -> ast
    # Load source code from file.
    source        = FileLoad(path)
    this.filePath = path

    # Parse source into AST tree.
    ast = this._parseInternal(source)
  endmethod

  method parseText(text) -> ast
    this.filePath = ''
    ast           = this._parseInternal(text)
  endmethod

endclass

