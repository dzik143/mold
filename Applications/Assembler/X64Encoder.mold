################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Libs/BitwiseHack.mold'

/*
TODO
marco DEFINE_OPCODE_CORE_R_R(mnemonic, opcode)
  method ${mnemonic}_r_r(regDst, regSrc)
    this.emitCore_r_r(opcode, regDst, regSrc)
  endmethod
endmacro

DEFINE_OPCODE_CORE_R_R(add, X64_ADD)
DEFINE_OPCODE_CORE_R_R(sub, X64_SUB)
DEFINE_OPCODE_CORE_R_R(xor, X64_XOR)
DEFINE_OPCODE_CORE_R_R(or,  X64_OR)
DEFINE_OPCODE_CORE_R_R(and, X64_AND)
...
*/

class X64Encoder
  method constructor()
    this.outputObject = false
  endmethod

  method emitByte(x)
    this.outputObject.emitByte(x)
  endmethod

  method emitWord(x)
    this.outputObject.emitWord(x)
  endmethod

  method emitDword(x)
    this.outputObject.emitDword(x)
  endmethod

  method emitQword(x)
    this.outputObject.emitQword(x)
  endmethod

  # ----------------------------------------------------------------------------
  #                             Common helpers
  # ----------------------------------------------------------------------------

  method emitModRegRM(addressMode, reg, rm)
    # 7 6 | 5 4 3 | 2 1 0
    # mod | reg   | r/m
    reg = bitand(reg, 0x7)
    rm  = bitand(rm,  0x7)
    this.emitByte(addressMode * 64 + reg * 8 + rm)
  endmethod

  method emitPrimaryOpcode(opcodeMask, direct, size)
    # 7 6 5 4 3 2 | 1 0
    # opcode      | d s
    this.emitByte(opcodeMask + direct * 2 + size)
  endmethod

  method emitPrefix16()
    this.emitByte(0x66)
  endmethod

  method emitPrefix64()
    this.emitByte(0x48)
  endmethod

  method emitSizePrefixIfNeeded(reg)
    if X64_IsReg16(reg) is true
      # 16-bit: Emit operand size prefix.
      this.emitPrefix16()

    elif X64_IsReg64(reg) is true
      # 64-bit: Emit REX.W prefix.
      this.emitPrefix64()
    endif
  endmethod

  # ----------------------------------------------------------------------------
  #                        Core encoding patterns
  # ----------------------------------------------------------------------------

  method emitCore(opcode, mode, reg, rm)
    # opcode | mod-reg-rm | SIB    | displacement | immediate
    # 1-2B   | 0 or 1     | 0 or 1 | 0, 1, 2 or 4 | 0, 1, 2 or 4
    # bytes  | byte       | byte   | bytes        | bytes

    global X64_SIZE16_32_64

    # Emit prefixes if needed.
    this.emitSizePrefixIfNeeded(reg)

    # Primary opcode.
    if opcode > 255
      # TODO: Clean up this mess.
      # We set extra mask in unused part to avoid treating 0xf
      # as one byte opcode.
      this.emitWord(bitand(opcode, 0xffff))
    else
      this.emitByte(opcode)
    endif

    # Mod-Reg-R/M byte.
    this.emitModRegRM(mode, reg, rm)
  endmethod

  method emitCore_r_r(opcode, regDst, regSrc)
    global X64_MOD_REGISTER
    this.emitCore(opcode, X64_MOD_REGISTER, regDst, regSrc)
  endmethod

  method emitCore_m_r(opcode, regBase, scale, regIndex, disp, regSrc)
    global X64_MOD_INDIRECT, X64_MOD_DISP8, X64_MOD_DISP32
    global X64_RM_SIB_MODE, X64_RM_RIP_DISP_MODE
    global X64_SIB_BASE_NONE
    global X64_RIP, X64_EBP, X64_RBP, X64_RSP

    if regIndex is X64_RSP
      die('error: rsp register cannot be used as index')
    endif

    if (scale is 2) and (regBase is -1)
      # Fasm like optimization.
      # [2*rsi] -> [rsi + 1*rsi]
      regBase = regIndex
      scale   = 1
    endif

    if (regBase is X64_RSP) and (scale is -1)
      # Special case: [ rsp ]
      regIndex = X64_RSP
      scale    = 1
    endif

    if regBase is X64_RIP
      # Code independent address: [rip + disp32]
      # In this mode displacement is always 32-bit.
      # MOD = 00  = INDIRECT,
      # R/M = RBP = displacement only.
      this.emitCore(opcode, X64_MOD_INDIRECT, regSrc, X64_RM_RIP_DISP_MODE)
      this.emitDword(disp)

    elif (regBase is -1) and (scale is -1) and (regIndex is -1)
      # Absolute ds:[disp32] address.
      # In this mode displacement is always 32-bit.
      #
      # https://wiki.osdev.org/X86-64_Instruction_Encoding#32.2F64-bit_addressing_2
      # http://www.c-jump.com/CIS77/CPU/x86/lecture.html#X77_0100_sib_byte_layout
      #
      # MOD       = INDIRECT
      # SIB.scale = 1
      # SIB.index = 100 = ILLEGAL
      # SIB.base  = 101 = displacement only.
      this.emitCore(opcode, X64_MOD_INDIRECT, regSrc, X64_RM_SIB_MODE)
      this.emitByte(0x25)
      this.emitDword(disp)

    else
      # General case.
      if (regBase isnt X64_RBP) and ((disp is 0) or (regBase is -1))
        # [r], r
        # [disp], r
        mode = X64_MOD_INDIRECT

      elif (disp >= -127) and (disp <= 128)
        # [disp8], r
        # [r + disp8], r
        mode = X64_MOD_DISP8

      else
        # [disp32], r
        # [r + disp32], r
        mode = X64_MOD_DISP32
      endif

      # Enable Scaled Index Base (SIB) mode.
      if scale > 0
        # Full SIB: [base + scale * index + disp]
        rm = X64_RM_SIB_MODE
      else
        # Base and displacement: [base + disp]
        rm = regBase
      endif

      # Primary opcode and Mod-Reg-R/M byte.
      this.emitCore(opcode, mode, regSrc, rm)

      # Emit SIB byte if needed.
      if scale > 0
        if scale is 1
          # [base + index + disp]
          scaleMask = 0x00

        elif scale is 2
          # [base + 2*index + disp]
          scaleMask = 0x40

        elif scale is 4
          # [base + 4*index + disp]
          scaleMask = 0x80

        elif scale is 8
          # [base + 8*index + disp]
          scaleMask = 0xc0

        else
          # Error - unexpected scale.
          scaleMask = -1
          die('error: only 1, 2, 4 or 8 scale is available')
        endif

        if regBase is -1
          # [scale * index + disp32]
          # Displacement is always 32-bit and is emited even if zero.
          regBaseMask = X64_SIB_BASE_NONE
          mode        = X64_MOD_DISP32
        else
          # [base + scale * index + disp8/32]
          regBaseMask = bitand(regBase, 0x7)
        endif

        regIndexMask = bitand(regIndex, 0x7) * 8

        this.emitByte(scaleMask + regIndexMask + regBaseMask)
      endif

      # Emit displacement if needed.
      if mode is X64_MOD_DISP8
        # 8-bit displacemnt.
        this.emitByte(disp)

      elif mode is X64_MOD_DISP32
        # 32-bit displacement
        this.emitDword(disp)
      endif
    endif
  endmethod

  method emitCore_r_m(opcode, regDst, regBase, scale, regIndex, disp)
    # Set direction flag in primary opcode byte to swap r<->m direction.
    opcode = bitor(opcode, 2)
    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, regDst)
  endmethod

  method emitCore_r(opcode, reg)
    this.emitCore_r_r(opcode, 0, reg)
  endmethod

  method emitCore_m(opcode, regBase, scale, regIndex, disp)
    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, 0)
  endmethod

  method emitCore_r_imm(opcode, regDst, imm)
    global X64_MOD_REGISTER
    global X64_ALU_RM8_IMM8_GROUP
    global X64_ALU_RM32_IMM32_GROUP
    global X64_ALU_RM32_IMM8_GROUP
    global X64_AL

    # Sub-opcode to encode inside Reg-Mod-RM byte.
    operationId = opcode // 8

    if regDst is X64_AL
      # Special case for AL register.
      this.emitByte(opcode + 4)
      this.emitByte(imm)

    elif X64_IsReg8(regDst) is true
      # General 8-bit destination.
      this.emitByte(X64_ALU_RM8_IMM8_GROUP)
      this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
      this.emitByte(imm)

    else
      # 16-bit, 32-bit or 64-bit destination.
      # 32-bit is default (no prefix needed).
      this.emitSizePrefixIfNeeded(regDst)

      if (imm >= -127) and (imm <= 128)
        # r16, imm8
        # r32, imm8
        # r64, imm8
        this.emitByte(X64_ALU_RM32_IMM8_GROUP)
        this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
        this.emitByte(imm)

      else
        # r16, imm32
        # r32, imm32
        # r64, imm32
        if bitand(regDst, 0x7) is X64_AL
          # Special case for ax, eax, rax.
          this.emitByte(opcode + 5)

        else
          this.emitByte(X64_ALU_RM32_IMM32_GROUP)
          this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
        endif

        # Emit immediate.
        if X64_IsReg16(regDst) is true
          this.emitWord(imm)
        else
          this.emitDword(imm)
        endif
      endif
    endif
  endmethod

  method emitCore_m_imm(opcode, regBase, scale, regIndex, disp, imm, dataSize)
    global X64_ALU_RM8_IMM8_GROUP
    global X64_ADC, X64_ADD, X64_AND, X64_CMP, X64_SBB, X64_SUB, X64_OR, X64_XOR

    # TODO: Clean up this mess.
    if dataSize is 2
      this.emitPrefix16()
    elif dataSize is 8
      this.emitPrefix64()
    endif

    if ((opcode is X64_ADC) or
        (opcode is X64_ADD) or
        (opcode is X64_AND) or
        (opcode is X64_CMP) or
        (opcode is X64_SBB) or
        (opcode is X64_SUB) or
        (opcode is X64_OR) or
        (opcode is X64_XOR))

      # Sub-opcode to encode inside Reg-Mod-RM byte.
      operationId = opcode // 8
      opcode      = X64_ALU_RM8_IMM8_GROUP
    else
      operationId = 0
    endif

    if dataSize > 1
      # Non 8-bit mode.
      opcode = opcode + 1
    endif

    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, operationId)

    if dataSize is 1
      # 8-bit immediate.
      this.emitByte(imm)
    elif dataSize is 2
      # 16-bit immediate.
      this.emitWord(imm)
    else
      # 32-bit immediate.
      # There is no 64-bit immediates even if qword
      # is accessed in memory.
      this.emitDword(imm)
    endif
  endmethod

  method emitCore_group_r(opcodeBase, operationId, reg)
    global X64_MOD_REGISTER
    if X64_IsReg8(reg) is true
      # neg r8 like.
      this.emitByte(opcodeBase)
    else
      # neg r16/32/64 like.
      # 32-bit is default.
      this.emitSizePrefixIfNeeded(reg)
      this.emitByte(opcodeBase + 1)
    endif

    # Emit Mod-Reg-R/M byte.
    # Reg field stores operation id (sub-opcode).
    this.emitModRegRM(X64_MOD_REGISTER, operationId, reg)
  endmethod

  method emitCore_group_m(opcodeBase, operationId, base, scale, index, disp)
    this.emitCore_m_r(opcodeBase, base, scale, index, disp, operationId)
  endmethod

  method emitCore_unaryGroup_r(operationId, reg)
    global X64_UNARY8_GROUP
    this.emitCore_group_r(X64_UNARY8_GROUP, operationId, reg)
  endmethod

  method emitCore_unaryGroup_m(operationId, base, scale, index, disp, dataSize)
    global X64_UNARY8_GROUP
    global X64_UNARY32_GROUP
    opcode = X64_UNARY32_GROUP

    if dataSize is 2
      # access word (2-bytes)
      operationId = operationId + 16

    elif dataSize is 4
      # access word (2-bytes)
      operationId = operationId + 32

    elif dataSize is 8
      # access qword (8-bytes)
      operationId = operationId + 48

    else
      # access single byte (8-bit)
      opcode = X64_UNARY8_GROUP
    endif

    this.emitCore_group_m(opcode, operationId, base, scale, index, disp)
  endmethod

  method emitCore_shiftGroup_r_imm8(operationId, regDst, imm8)
    global X64_SHIFT_RM8_IMM8_GROUP
    global X64_SHIFT_RM8_1_GROUP

    if imm8 is 1
      # Example: rol eax, 1
      this.emitCore_group_r(X64_SHIFT_RM8_1_GROUP, operationId, regDst)
    else
      # Example: shr eax, 14
      this.emitCore_group_r(X64_SHIFT_RM8_IMM8_GROUP, operationId, regDst)
      this.emitByte(imm8)
    endif
  endmethod

  method emitCore_shiftGroup_r_cl(operationId, regDst)
    global X64_SHIFT_RM8_CL_GROUP
    this.emitCore_group_r(X64_SHIFT_RM8_CL_GROUP, operationId, regDst)
  endmethod

  method emitCore_shiftGroup_m_imm8(operationId, regBase, scale, regIndex, disp, imm8, dataSize)
    global X64_SHIFT_RM8_IMM8_GROUP
    global X64_SHIFT_RM8_1_GROUP

    # TODO: Clean up this mess.
    if dataSize is 1
      opcodeShift = 0
    else
      opcodeShift = 1
      if dataSize is 2
        this.emitPrefix16()
      elif dataSize is 8
        this.emitPrefix64()
      endif
    endif

    if imm8 is 1
      # Example: rol dword [rdi], 1
      this.emitCore_group_m(
        X64_SHIFT_RM8_1_GROUP + opcodeShift,
        operationId, regBase, scale, regIndex, disp)
    else
      # Example: shr dword [rdi], 14
      this.emitCore_group_m(X64_SHIFT_RM8_IMM8_GROUP + opcodeShift,
        operationId, regBase, scale, regIndex, disp)

      this.emitByte(imm8)
    endif
  endmethod

  method emitCore_shiftGroup_m_cl(operationId, regBase, scale, regIndex, disp, dataSize)
    global X64_SHIFT_RM8_CL_GROUP
    global X64_SHIFT_RM32_CL_GROUP

    # TODO: Clean up this mess.
    if dataSize is 1
      opcode = X64_SHIFT_RM8_CL_GROUP
    else
      opcode = X64_SHIFT_RM32_CL_GROUP
      if dataSize is 2
        this.emitPrefix16()
      elif dataSize is 8
        this.emitPrefix64()
      endif
    endif

    this.emitCore_group_m(opcode, operationId, regBase, scale, regIndex, disp)
  endmethod

  # ----------------------------------------------------------------------------
  #                 Public API: Core x86-64 instruction set
  # ----------------------------------------------------------------------------

  #
  # Core ALU: add, or, adc, sbb, and, sub, xor, cmp, neg, not
  #

  # alu r, r
  method add_r_r(regDst, regSrc)
    global X64_ADD
    this.emitCore_r_r(X64_ADD, regDst, regSrc)
  endmethod

  method or_r_r(regDst, regSrc)
    global X64_OR
    this.emitCore_r_r(X64_OR, regDst, regSrc)
  endmethod

  method adc_r_r(regDst, regSrc)
    global X64_ADC
    this.emitCore_r_r(X64_ADC, regDst, regSrc)
  endmethod

  method sbb_r_r(regDst, regSrc)
    global X64_SBB
    this.emitCore_r_r(X64_SBB, regDst, regSrc)
  endmethod

  method and_r_r(regDst, regSrc)
    global X64_AND
    this.emitCore_r_r(X64_AND, regDst, regSrc)
  endmethod

  method sub_r_r(regDst, regSrc)
    global X64_SUB
    this.emitCore_r_r(X64_SUB, regDst, regSrc)
  endmethod

  method xor_r_r(regDst, regSrc)
    global X64_XOR
    this.emitCore_r_r(X64_XOR, regDst, regSrc)
  endmethod

  method cmp_r_r(regDst, regSrc)
    global X64_CMP
    this.emitCore_r_r(X64_CMP, regDst, regSrc)
  endmethod

  # alu r, imm
  method add_r_imm(regDst, imm)
    global X64_ADD
    this.emitCore_r_imm(X64_ADD, regDst, imm)
  endmethod

  method or_r_imm(regDst, imm)
    global X64_OR
    this.emitCore_r_imm(X64_OR, regDst, imm)
  endmethod

  method adc_r_imm(regDst, imm)
    global X64_ADC
    this.emitCore_r_imm(X64_ADC, regDst, imm)
  endmethod

  method sbb_r_imm(regDst, imm)
    global X64_SBB
    this.emitCore_r_imm(X64_SBB, regDst, imm)
  endmethod

  method and_r_imm(regDst, imm)
    global X64_AND
    this.emitCore_r_imm(X64_AND, regDst, imm)
  endmethod

  method sub_r_imm(regDst, imm)
    global X64_SUB
    this.emitCore_r_imm(X64_SUB, regDst, imm)
  endmethod

  method xor_r_imm(regDst, imm)
    global X64_XOR
    this.emitCore_r_imm(X64_XOR, regDst, imm)
  endmethod

  method cmp_r_imm(regDst, imm)
    global X64_CMP
    this.emitCore_r_imm(X64_CMP, regDst, imm)
  endmethod

  # alu r, m
  method add_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_ADD
    this.emitCore_r_m(X64_ADD, regDst, regBase, scale, regIndex, disp)
  endmethod

  method or_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_OR
    this.emitCore_r_m(X64_OR, regDst, regBase, scale, regIndex, disp)
  endmethod

  method adc_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_ADC
    this.emitCore_r_m(X64_ADC, regDst, regBase, scale, regIndex, disp)
  endmethod

  method sbb_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_SBB
    this.emitCore_r_m(X64_SBB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method and_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_AND
    this.emitCore_r_m(X64_AND, regDst, regBase, scale, regIndex, disp)
  endmethod

  method sub_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_SUB
    this.emitCore_r_m(X64_SUB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method xor_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_XOR
    this.emitCore_r_m(X64_XOR, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmp_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMP
    this.emitCore_r_m(X64_CMP, regDst, regBase, scale, regIndex, disp)
  endmethod

  # alu m, r
  method add_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_ADD
    this.emitCore_r_m(X64_ADD, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method or_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_OR
    this.emitCore_r_m(X64_OR, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method adc_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_ADC
    this.emitCore_r_m(X64_ADC, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method sbb_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_SBB
    this.emitCore_r_m(X64_SBB, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method and_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_AND
    this.emitCore_r_m(X64_AND, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method sub_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_SUB
    this.emitCore_r_m(X64_SUB, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method xor_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_XOR
    this.emitCore_r_m(X64_XOR, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method cmp_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_CMP
    this.emitCore_r_m(X64_CMP, regBase, scale, regIndex, disp, regSrc)
  endmethod

  #
  # Core ALU: inc, dec
  #

  method emitCore_incDec_m(operationId, regBase, scale, regIndex, disp, dataSize)
    global X64_INC_DEC_RM8_GROUP
    global X64_INC_DEC_RM32_GROUP

    # TODO: Clean up this mess.
    if dataSize is 1
      opcode = X64_INC_DEC_RM8_GROUP
    else
      opcode = X64_INC_DEC_RM32_GROUP

      if dataSize is 2
        this.emitPrefix16()
      elif dataSize is 8
        this.emitPrefix64()
      endif
    endif

    this.emitCore_group_m(opcode, operationId, regBase, scale, regIndex, disp)
  endmethod

  method inc_r(reg)
    global X64_INC_DEC_RM8_GROUP
    this.emitCore_group_r(X64_INC_DEC_RM8_GROUP, 0, reg)
  endmethod

  method inc_m(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_incDec_m(0, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method dec_r(reg)
    global X64_INC_DEC_RM8_GROUP
    this.emitCore_group_r(X64_INC_DEC_RM8_GROUP, 1, reg)
  endmethod

  method dec_m(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_incDec_m(1, regBase, scale, regIndex, disp, dataSize)
  endmethod

  #
  # Bit test: test
  #

  method test_r_r(reg1, reg2)
    global X64_TEST_RM8_R8
    this.emitCore_r_r(X64_TEST_RM8_R8, reg1, reg2)
  endmethod

  method test_m_r(regBase, scale, regIndex, disp, reg2)
    global X64_TEST_RM8_R8
    this.emitCore_m_r(X64_TEST_RM8_R8, regBase, scale, regIndex, disp, reg2)
  endmethod

  method test_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_unaryGroup_m(0, regBase, scale, regIndex, disp, dataSize)

    # TODO: Clean up this mess.
    if dataSize is 1
      # 8-bit immediate.
      this.emitByte(imm)
    elif dataSize is 2
      # 16-bit immediate.
      this.emitWord(imm)
    else
      # 32-bit immediate.
      # There is no 64-bit immediates even if qword
      # is accessed in memory.
      this.emitDword(imm)
    endif
  endmethod

  method test_r_imm(reg, imm)
    global X64_TEST_AL_IMM8
    global X64_TEST_EAX_IMM32
    global X64_AL, X64_AX
    global X64_MOD_REGISTER

    if bitand(reg, 0xf) is X64_AL
      # Special case:
      # - test al, imm8
      # - test ax, imm16  (16-bit prefix)
      # - test eax, imm32 (default)
      # - test rax, imm32 (REX.w prefix)
      if reg is X64_AL
        # test al, imm8
        this.emitByte(X64_TEST_AL_IMM8)

      else
        # Test ax, eax or rax register.
        this.emitSizePrefixIfNeeded(reg)
        this.emitByte(X64_TEST_EAX_IMM32)
      endif

    else
      # General case:
      # - test r8, imm8
      # - test r16, imm16 (16-bit prefix)
      # - test r32, imm32 (default)
      # - test r64, imm32 (REX.w prefix)
      this.emitCore_unaryGroup_r(0, reg)
    endif

    # Emit immediate.
    if X64_IsReg8(reg) is true
      # Test 8-bit register.
      this.emitByte(imm)

    elif X64_IsReg16(reg) is true
      # Test 16-bit register.
      this.emitWord(imm)

    else
      # Test 32 or 64-bit register.
      # Immediate is always 32-bit.
      this.emitDword(imm)
    endif
  endmethod

  #
  # Integer multiplication and division: mul, imul, div, idiv
  #

  # opcode r
  method not_r(reg)
    this.emitCore_unaryGroup_r(2, reg)
  endmethod

  method neg_r(reg)
    this.emitCore_unaryGroup_r(3, reg)
  endmethod

  method mul_r(reg)
    this.emitCore_unaryGroup_r(4, reg)
  endmethod

  method imul_r(reg)
    this.emitCore_unaryGroup_r(5, reg)
  endmethod

  method div_r(reg)
    this.emitCore_unaryGroup_r(6, reg)
  endmethod

  method idiv_r(reg)
    this.emitCore_unaryGroup_r(7, reg)
  endmethod

  # opcode m
  method not_m(base, scale, index, disp, dataSize)
    this.emitCore_unaryGroup_m(2, base, scale, index, disp, dataSize)
  endmethod

  method neg_m(base, scale, index, disp, dataSize)
    this.emitCore_unaryGroup_m(3, base, scale, index, disp, dataSize)
  endmethod

  method mul_m(base, scale, index, disp, dataSize)
    this.emitCore_unaryGroup_m(4, base, scale, index, disp, dataSize)
  endmethod

  method imul_m(base, scale, index, disp, dataSize)
    this.emitCore_unaryGroup_m(5, base, scale, index, disp, dataSize)
  endmethod

  method div_m(base, scale, index, disp, dataSize)
    this.emitCore_unaryGroup_m(6, base, scale, index, disp, dataSize)
  endmethod

  method idiv_m(base, scale, index, disp, dataSize)
    this.emitCore_unaryGroup_m(7, base, scale, index, disp, dataSize)
  endmethod

  #
  # Stack: push, pusha, pushad, pushf, pop, popa, popad, popf
  #

  method emitCore_pushPop_r(opcode, reg)
    if X64_IsReg16(reg) is true
      # push r16
      this.emitPrefix16()

    elif X64_IsReg64(reg) is true
      # push r64
      # Default scenario - nothing to do.
    else
      die('error: push/pop r8/32 are unavailable in 64-bit mode')
    endif

    this.emitByte(opcode + bitand(reg, 0x7))
  endmethod

  method push_r(reg)
    global X64_PUSH_R64
    this.emitCore_pushPop_r(X64_PUSH_R64, reg)
  endmethod

  method pop_r(reg)
    global X64_POP_R64
    this.emitCore_pushPop_r(X64_POP_R64, reg)
  endmethod

  method pop_m(regBase, scale, regIndex, disp, dataSize)
    global X64_POP_RM64
    if dataSize is 2
      this.emitPrefix16()
    elif dataSize is 8
      # push qword [...]
      # Default scenario - nothing to do.
    else
      die('error: push/pop m8/32 are unavailable in 64-bit mode')
    endif
    this.emitCore_group_m(X64_POP_RM64, 0, regBase, scale, regIndex, disp)
  endmethod

  method push_m(regBase, scale, regIndex, disp, dataSize)
    global X64_CALL_GROUP
    if dataSize is 2
      this.emitPrefix16()
    elif dataSize is 8
      # push qword [...]
      # Default scenario - nothing to do.
    else
      die('error: push/pop m8/32 are unavailable in 64-bit mode')
    endif
    this.emitCore_group_m(X64_CALL_GROUP, 6, regBase, scale, regIndex, disp)
  endmethod

  method pushf()
    global X64_PUSHF
    this.emitByte(X64_PUSHF)
  endmethod

  method popf()
    global X64_POPF
    this.emitByte(X64_POPF)
  endmethod

  #
  # Ports: in, out,
  #        insb, insw, insd, insq,
  #        outsb, outsw, outsd, outsq.
  #

  method emitCore_inOut(opcode, regData, portNumber)
    global X64_AL, X64_AX, X64_EAX
    global X64_DX

    if regData is X64_AL
      this.emitByte(opcode)

    elif regData is X64_AX
      this.emitPrefix16()
      this.emitByte(opcode + 1)

    elif regData is X64_EAX
      this.emitByte(opcode + 1)

    else
      die('error: only al/ax/eax registers can be data operand for in/out')
    endif

    if portNumber >= 0
      # Emit port number as 8-bit immediate.
      this.emitByte(portNumber)
    endif
  endmethod

  method in_r_imm(regDst, imm)
    global X64_IN_AL_IMM8
    this.emitCore_inOut(X64_IN_AL_IMM8, regDst, imm)
  endmethod

  method out_imm_r(imm, regSrc)
    global X64_OUT_IMM8_AL
    this.emitCore_inOut(X64_OUT_IMM8_AL, regSrc, imm)
  endmethod

  method in_r_dx(regDst)
    global X64_IN_AL_DX, X64_DX
    this.emitCore_inOut(X64_IN_AL_DX, regDst, -X64_DX)
  endmethod

  method out_dx_r(regSrc)
    global X64_OUT_DX_AL, X64_DX
    this.emitCore_inOut(X64_OUT_DX_AL, regSrc, -X64_DX)
  endmethod

  method insb()
    global X64_INSB
    this.emitByte(X64_INSB)
  endmethod

  method insw()
    global X64_INSW
    this.emitWord(X64_INSW)
  endmethod

  method outsb()
    global X64_OUTSB
    this.emitByte(X64_OUTSB)
  endmethod

  method outsw()
    global X64_OUTSW
    this.emitWord(X64_OUTSW)
  endmethod

  # Strings: movsb, movsw, movsd, movsq,
  #          cmpsb, cmpsw, cmpsd, cmpsq,
  #          stosb, stosw, stosd, stosq,
  #          lodsb, lodsw, lodsd, lodsq,
  #          scasb, scasw, scasd, scasq,
  #          repne, repe.

  method movsb()
    global X64_MOVSB
    this.emitByte(X64_MOVSB)
  endmethod

  method movsw()
    global X64_MOVSW
    this.emitWord(X64_MOVSW)
  endmethod

  method movsq()
    global X64_MOVSQ
    this.emitWord(X64_MOVSQ)
  endmethod

  method cmpsb()
    global X64_CMPSB
    this.emitByte(X64_CMPSB)
  endmethod

  method cmpsw()
    global X64_CMPSW
    this.emitWord(X64_CMPSW)
  endmethod

  method stosb()
    global X64_STOSB
    this.emitByte(X64_STOSB)
  endmethod

  method stosw()
    global X64_STOSW
    this.emitWord(X64_STOSW)
  endmethod

  method lodsb()
    global X64_LODSB
    this.emitByte(X64_LODSB)
  endmethod

  method lodsw()
    global X64_LODSW
    this.emitWord(X64_LODSW)
  endmethod

  method scasb()
    global X64_SCASB
    this.emitByte(X64_SCASB)
  endmethod

  method scasw()
    global X64_SCASW
    this.emitWord(X64_SCASW)
  endmethod

  method repne()
    global X64_PREFIX_REPNE
    this.emitByte(X64_PREFIX_REPNE)
  endmethod

  method repe()
    global X64_PREFIX_REPE
    this.emitByte(X64_PREFIX_REPE)
  endmethod

  #
  # Unconditional jumps.
  #

  method emitCore_jmp_rel8(opcode, rel)
    this.emitByte(opcode)
    this.emitByte(rel)
  endmethod

  method emitCore_jmp_rel32(opcode, rel)
    this.emitByte(opcode)
    this.emitDword(rel)
  endmethod

  method emitCore_jcc_rel(opcode, rel)
    # TODO: Review it.
    if (rel >= -126) and (rel <= 128 + 5)
      # jcc rel8
      this.emitByte(opcode)
      this.emitByte(rel - 2)

    else
      # jcc rel32
      # 0f 8x = two bytes jcc jump
      # TODO: Avoid hardcoded opcode.
      this.emitByte(0x0f)
      this.emitByte(opcode + 0x10)
      this.emitDword(rel - 6)
    endif
  endmethod

  method jmp_rel(rel)
    global X64_JMP_REL8
    global X64_JMP_REL32

    # TODO: Review it.
    if (rel >= -126) and (rel <= 128 + 5)
      # jmp rel8
      this.emitCore_jmp_rel8(X64_JMP_REL8, rel - 2)
    else
      # jmp rel32
      this.emitCore_jmp_rel32(X64_JMP_REL32, rel - 5)
    endif
  endmethod

  method jmp_r(reg)
    global X64_CALL_GROUP
    if X64_IsReg16(reg) is true
      this.emitPrefix16()
    endif
    this.emitCore_group_r(X64_CALL_GROUP, 4, bitand(reg, 0x7))
  endmethod

  method jmp_m(regBase, scale, regIndex, disp, dataSize)
    global X64_CALL_GROUP
    if dataSize is 2
      this.emitPrefix16()
    endif
    this.emitCore_group_m(X64_CALL_GROUP, 4, regBase, scale, regIndex, disp)
  endmethod

  #
  # Conditional jumps: jcc, loopnz, loopz, loop, jrcxz, jecxz
  #

  method jo_rel(rel)
    global X64_JO
    this.emitCore_jcc_rel(X64_JO, rel)
  endmethod

  method jno_rel(rel)
    global X64_JNO
    this.emitCore_jcc_rel(X64_JNO, rel)
  endmethod

  method jb_rel(rel)
    global X64_JB
    this.emitCore_jcc_rel(X64_JB, rel)
  endmethod

  method jae_rel(rel)
    global X64_JAE
    this.emitCore_jcc_rel(X64_JAE, rel)
  endmethod

  method jz_rel(rel)
    global X64_JZ
    this.emitCore_jcc_rel(X64_JZ, rel)
  endmethod

  method jnz_rel(rel)
    global X64_JNZ
    this.emitCore_jcc_rel(X64_JNZ, rel)
  endmethod

  method jbe_rel(rel)
    global X64_JBE
    this.emitCore_jcc_rel(X64_JBE, rel)
  endmethod

  method ja_rel(rel)
    global X64_JA
    this.emitCore_jcc_rel(X64_JA, rel)
  endmethod

  method js_rel(rel)
    global X64_JS
    this.emitCore_jcc_rel(X64_JS, rel)
  endmethod

  method jns_rel(rel)
    global X64_JNS
    this.emitCore_jcc_rel(X64_JNS, rel)
  endmethod

  method jp_rel(rel)
    global X64_JP
    this.emitCore_jcc_rel(X64_JP, rel)
  endmethod

  method jnp_rel(rel)
    global X64_JNP
    this.emitCore_jcc_rel(X64_JNP, rel)
  endmethod

  method jl_rel(rel)
    global X64_JL
    this.emitCore_jcc_rel(X64_JL, rel)
  endmethod

  method jge_rel(rel)
    global X64_JGE
    this.emitCore_jcc_rel(X64_JGE, rel)
  endmethod

  method jle_rel(rel)
    global X64_JLE
    this.emitCore_jcc_rel(X64_JLE, rel)
  endmethod

  method jg_rel(rel)
    global X64_JG
    this.emitCore_jcc_rel(X64_JG, rel)
  endmethod

  method loopz_rel(rel)
    global X64_LOOPZ_REL8
    this.emitCore_jmp_rel8(X64_LOOPZ_REL8, rel - 2)
  endmethod

  method loopnz_rel(rel)
    global X64_LOOPNZ_REL8
    this.emitCore_jmp_rel8(X64_LOOPNZ_REL8, rel - 2)
  endmethod

  method loop_rel(rel)
    global X64_LOOP_REL8
    this.emitCore_jmp_rel8(X64_LOOP_REL8, rel - 2)
  endmethod

  method loopzd_rel(rel)
    global X64_LOOPZ_REL8
    this.emitByte(0x67)
    this.emitCore_jmp_rel8(X64_LOOPZ_REL8, rel - 3)
  endmethod

  method loopnzd_rel(rel)
    global X64_LOOPNZ_REL8
    this.emitByte(0x67)
    this.emitCore_jmp_rel8(X64_LOOPNZ_REL8, rel - 3)
  endmethod

  method loopd_rel(rel)
    global X64_LOOP_REL8
    this.emitByte(0x67)
    this.emitCore_jmp_rel8(X64_LOOP_REL8, rel - 3)
  endmethod

  method jecxz_rel(rel)
    global X64_JRCXZ_REL8
    this.emitByte(0x67)
    this.emitCore_jmp_rel8(X64_JRCXZ_REL8, rel - 3)
  endmethod

  method jrcxz_rel(rel)
    global X64_JRCXZ_REL8
    this.emitCore_jmp_rel8(X64_JRCXZ_REL8, rel - 2)
  endmethod

  #
  # Procedures: call, ret
  #

  method call_rel(rel)
    global X64_CALL_REL32
    this.emitCore_jmp_rel32(X64_CALL_REL32, rel - 5)
  endmethod

  method call_r(reg)
    global X64_CALL_GROUP
    if X64_IsReg16(reg) is true
      this.emitPrefix16()
    endif
    this.emitCore_group_r(X64_CALL_GROUP, 2, bitand(reg, 0x7))
  endmethod

  method call_m(regBase, scale, regIndex, disp, dataSize)
    global X64_CALL_GROUP
    if dataSize is 2
      this.emitPrefix16()
    endif
    this.emitCore_group_m(X64_CALL_GROUP, 2, regBase, scale, regIndex, disp)
  endmethod

  method ret()
    global X64_RET
    this.emitByte(X64_RET)
  endmethod

  method ret_imm(imm)
    global X64_RET_IMM16
    this.emitByte(X64_RET_IMM16)
    this.emitWord(imm)
  endmethod

  method retf()
    global X64_RETFQ
    this.emitWord(X64_RETFQ)
  endmethod

  method retf_imm(imm)
    global X64_RETF_IMM16
    this.emitPrefix64()
    this.emitByte(X64_RETF_IMM16)
    this.emitWord(imm)
  endmethod

  #
  # Data move: mov, xchg
  #

  method mov_r_r(regDst, regSrc)
    global X64_MOV_RM8_R8
    this.emitCore_r_r(X64_MOV_RM8_R8, regSrc, regDst)
  endmethod

  method mov_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_MOV_RM8_R8
    this.emitCore_r_m(X64_MOV_RM8_R8, regDst, regBase, scale, regIndex, disp)
  endmethod

  method mov_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_MOV_RM8_R8
    this.emitCore_m_r(X64_MOV_RM8_R8, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method mov_r_imm(regDst, imm)
    global X64_MOV_R8_IMM8
    global X64_MOV_R32_IMM32
    global X64_MOV_RM32_IMM32
    global X64_MOD_REGISTER

    regDstId = bitand(regDst, 0x7)

    if X64_IsReg8(regDst) is true
      # mov r8, imm8
      this.emitByte(X64_MOV_R8_IMM8 + regDstId)
      this.emitByte(imm)

    else
      # Move 16, 32 or 64 bits.
      # 32-bit is default (no prefix needed).
      if X64_IsReg16(regDst) is true
        # mov r16, imm16
        this.emitPrefix16()
        this.emitByte(X64_MOV_R32_IMM32 + regDstId)
        this.emitWord(imm)

      elif X64_IsReg32(regDst) is true
        # mov r32, imm32
        this.emitByte(X64_MOV_R32_IMM32 + regDstId)
        this.emitDword(imm)

      else
        # mov r64, imm32/64
        this.emitPrefix64()

        if (imm >= -2147483649) and (imm <= 2147483648)
          # mov r64, imm32
          this.emitCore(X64_MOV_RM32_IMM32, X64_MOD_REGISTER, 0, regDst)
          this.emitDword(imm)
        else
          # mov r64, imm64
          this.emitByte(X64_MOV_R32_IMM32 + regDstId)
          this.emitQword(imm)
        endif
      endif
    endif
  endmethod

  method mov_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    global X64_MOV_RM8_IMM8
    this.emitCore_m_imm(X64_MOV_RM8_IMM8, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method xchg_r_r(reg1, reg2)
    global X64_XCHG_RM8_R8, X64_XCHG_EAX_R32, X64_XCHG_RM32_R32, X64_NOP
    global X64_AL, X64_EAX, X64_RAX

    if X64_IsReg8(reg1) is true
      # xchg r8, r8
      this.emitCore_r_r(X64_XCHG_RM8_R8, reg1, reg2)

    elif (reg1 is X64_EAX) and (reg2 is X64_EAX)
      # Avoid emitting optimized one byte version for
      # xchg eax, eax
      # to distinguish from explicit nop opcode.
      this.emitWord(0xc087)

    else
      regMask1 = bitand(reg1, 0x7)
      regMask2 = bitand(reg2, 0x7)

      if regMask1 is X64_AL
        # Use optimized one-byte version if first operand is rax.
        # xchg ax/eax/rax, r
        this.emitSizePrefixIfNeeded(reg1)
        this.emitByte(X64_XCHG_EAX_R32 + regMask2)

      elif regMask2 is X64_AL
        # xchg r, ax/eax/rax
        # Swap arguments and use optimized rax version.
        this.emitSizePrefixIfNeeded(reg1)
        this.emitByte(X64_XCHG_EAX_R32 + regMask1)

      else
        # General case: xchg r, r
        this.emitCore_r_r(X64_XCHG_RM32_R32, reg1, reg2)
      endif
    endif
  endmethod

  # Conversion: cbw, cwd
  method cbw()
    global X64_CBW
    this.emitWord(X64_CBW)
  endmethod

  method cwd()
    global X64_CWD
    this.emitWord(X64_CWD)
  endmethod

  #
  # Interrupts: int, int1, int3, iret
  #

  method int_imm(imm8)
    global X64_INT
    global X64_INT3

    if imm8 is 3
      this.emitByte(X64_INT3)

    else
      this.emitByte(X64_INT)
      this.emitByte(imm8)
    endif
  endmethod

  method iret()
    global X64_IRETQ
    this.emitWord(X64_IRETQ)
  endmethod

  #
  # Flags: clc, stc, cli, sti, cld, std
  #

  method clc()
    global X64_CLC
    this.emitByte(X64_CLC)
  endmethod

  method stc()
    global X64_STC
    this.emitByte(X64_STC)
  endmethod

  method cli()
    global X64_CLI
    this.emitByte(X64_CLI)
  endmethod

  method sti()
    global X64_STI
    this.emitByte(X64_STI)
  endmethod

  method cld()
    global X64_CLD
    this.emitByte(X64_CLD)
  endmethod

  method std()
    global X64_STD
    this.emitByte(X64_STD)
  endmethod

  #
  # Core other: lea, nop, xlatb, hlt, cmc
  #

  method lea_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LEA
    this.emitCore_m_r(X64_LEA, regBase, scale, regIndex, disp, regDst)
  endmethod

  #
  #  lock
  #

  method lock()
    global X64_PREFIX_LOCK
    this.emitByte(X64_PREFIX_LOCK)
  endmethod

  method connectTo(outputObject) -> rv
    this.outputObject = outputObject
    rv = outputObject
  endmethod

  # aaa     invalid in 64-bit mode
  # aad     invalid in 64-bit mode
  # aam     invalid in 64-bit mode
  # lahf    invalid in 64-bit mode
  # aas     invalid in 64-bit mode
  # das     invalid in 64-bit mode
  # sahf    invalid in 64-bit mode
  # lds     invalid in 64-bit mode
  # les     invalid in 64-bit mode
  # daa     invalid in 64-bit mode
  # into    invalid in 64-bit mode

  #
  # Bit shifts and rotations: rol, ror, rcl, rcr, shl, rhr, sar
  #

  # r, cl
  method rol_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(0, regDst)
  endmethod

  method ror_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(1, regDst)
  endmethod

  method rcl_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(2, regDst)
  endmethod

  method rcr_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(3, regDst)
  endmethod

  method shl_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(4, regDst)
  endmethod

  method sal_r_cl(regDst)
    this.shl_r_cl(regDst)
  endmethod

  method shr_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(5, regDst)
  endmethod

  method sar_r_cl(regDst)
    this.emitCore_shiftGroup_r_cl(7, regDst)
  endmethod

  # m, imm8
  method rol_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(0, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method ror_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(1, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method rcl_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(2, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method rcr_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(3, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method shl_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(4, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method sal_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.shl_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method shr_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(5, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method sar_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_shiftGroup_m_imm8(7, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  # m, cl
  method rol_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(0, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method ror_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(1, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method rcl_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(2, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method rcr_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(3, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method shl_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(4, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method sal_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.shl_m_cl(regBase, scale, regIndex, disp, dataSize)
  endmethod

  method shr_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(5, regBase, scale, regIndex, disp, dataSize)
  endmethod

  method sar_m_cl(regBase, scale, regIndex, disp, dataSize)
    this.emitCore_shiftGroup_m_cl(7, regBase, scale, regIndex, disp, dataSize)
  endmethod

  #
  # No operation (nop).
  #

  method nop()
    global X64_NOP
    this.emitByte(X64_NOP)
  endmethod

  method nop_r(regDst)
    global X64_NOP_RM
    global X64_MOD_REGISTER
    this.emitSizePrefixIfNeeded(regDst)
    this.emitWord(X64_NOP_RM)
    this.emitModRegRM(X64_MOD_REGISTER, 0, regDst)
  endmethod

  method nop_m(regBase, scale, regIndex, disp, dataSize)
    global X64_NOP_RM

    # TODO: Clean up this mess.
    if dataSize is 2
      this.emitPrefix16()
    elif dataSize is 8
      this.emitPrefix64()
    endif

    this.emitCore_group_m(X64_NOP_RM, 0, regBase, scale, regIndex, disp)
  endmethod

  method cmc()
    global X64_CMC
    this.emitByte(X64_CMC)
  endmethod

  method hlt()
    global X64_HLT
    this.emitByte(X64_HLT)
  endmethod

  method wait()
    global X64_WAIT
    this.emitByte(X64_WAIT)
  endmethod

  method xlatb()
    global X64_XLATB
    this.emitByte(X64_XLATB)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80186 processor.
  #
  # Skipped mnemonics:
  #   bound    - invalid in 64-bit mode
  #   popa     - invalid in 64-bit mode
  #   pusha    - invalid in 64-bit mode
  #-----------------------------------------------------------------------------

  method enter_imm16_imm8(disp, level)
    global X64_ENTER
    this.emitByte(X64_ENTER)
    this.emitWord(disp)
    this.emitByte(level)
  endmethod

  method leave()
    global X64_LEAVE
    this.emitByte(X64_LEAVE)
  endmethod

  method push_imm8(imm)
    global X64_PUSH_IMM8
    this.emitByte(X64_PUSH_IMM8)
    this.emitByte(imm)
  endmethod

  method push_imm32(imm)
    global X64_PUSH_IMM32
    this.emitByte(X64_PUSH_IMM32)
    this.emitDword(imm)
  endmethod

  # r, imm8
  method rol_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(0, regDst, imm)
  endmethod

  method ror_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(1, regDst, imm)
  endmethod

  method rcl_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(2, regDst, imm)
  endmethod

  method rcr_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(3, regDst, imm)
  endmethod

  method shl_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(4, regDst, imm)
  endmethod

  method sal_r_imm(regDst, imm)
    this.shl_r_imm(regDst, imm)
  endmethod

  method shr_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(5, regDst, imm)
  endmethod

  method sar_r_imm(regDst, imm)
    this.emitCore_shiftGroup_r_imm8(7, regDst, imm)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80286 processor.
  #
  # Skipped mnemonics:
  #   arpl    - invalid in 64-bit mode
  #   loadall - 80286 only
  #-----------------------------------------------------------------------------

  method emitCore286_r_r(opcode, regDst, regSrc)
    # TODO: Clean up this mess.
    # We avoid setting up size bit in primary opcode.
    # TODO: Why we need to swap operands?
    this.emitSizePrefixIfNeeded(regDst)
    regDst = bitand(regDst, 0x7)
    this.emitCore_r_r(opcode, regDst, regSrc)
  endmethod

  method emitCore286_r_m(opcode, regDst, regBase, scale, regIndex, disp)
    # TODO: Clean up this mess.
    # We avoid setting up size bit in primary opcode.
    this.emitSizePrefixIfNeeded(regDst)
    regDst = bitand(regDst, 0x7)
    this.emitCore_r_m(opcode, regDst, regBase, scale, regIndex, disp)
  endmethod

  method emitCore_group0f_00_m(operationId, regBase, scale, regIndex, disp)
    # TODO: Clean up this mess.
    # We set extra mask in unused part to avoid treating 0xf
    # as one byte opcode.
    this.emitCore_group_m(0x1000000f, operationId, regBase, scale, regIndex, disp)
  endmethod

  method emitCore_group0f_00_r(operationId, reg)
    global X64_GROUP_0F_00
    global X64_MOD_REGISTER

    # TODO: Clean up this mess.
    if operationId <= 1
      this.emitSizePrefixIfNeeded(reg)
    endif

    this.emitWord(X64_GROUP_0F_00)
    this.emitModRegRM(X64_MOD_REGISTER, operationId, reg)
  endmethod

  method emitCore_group0f_01_m(operationId, regBase, scale, regIndex, disp)
    this.emitCore_group_m(0x010f, operationId, regBase, scale, regIndex, disp)
  endmethod

  method emitCore_group0f_01_r(operationId, reg)
    global X64_GROUP_0F_01
    global X64_MOD_REGISTER

    # TODO: Clean up this mess.
    if operationId is 4
      this.emitSizePrefixIfNeeded(reg)
    endif

    this.emitWord(X64_GROUP_0F_01)
    this.emitModRegRM(X64_MOD_REGISTER, operationId, reg)
  endmethod

  # Group 0f 00 /x: memory operand
  method sldt_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_00_m(0, regBase, scale, regIndex, disp)
  endmethod

  method str_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_00_m(1, regBase, scale, regIndex, disp)
  endmethod

  method lldt_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_00_m(2, regBase, scale, regIndex, disp)
  endmethod

  method ltr_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_00_m(3, regBase, scale, regIndex, disp)
  endmethod

  method verr_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_00_m(4, regBase, scale, regIndex, disp)
  endmethod

  method verw_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_00_m(5, regBase, scale, regIndex, disp)
  endmethod

  # Group 0f 00 /x: register operand
  method sldt_r(regSrc)
    this.emitCore_group0f_00_r(0, regSrc)
  endmethod

  method str_r(regSrc)
    this.emitCore_group0f_00_r(1, regSrc)
  endmethod

  method lldt_r(regDst)
    this.emitCore_group0f_00_r(2, regDst)
  endmethod

  method ltr_r(regDst)
    this.emitCore_group0f_00_r(3, regDst)
  endmethod

  method verr_r(regDst)
    this.emitCore_group0f_00_r(4, regDst)
  endmethod

  method verw_r(regSrc)
    this.emitCore_group0f_00_r(5, regSrc)
  endmethod

  # Group 0f 01 /x: memory operand
  method sgdt_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(0, regBase, scale, regIndex, disp)
  endmethod

  method sidt_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(1, regBase, scale, regIndex, disp)
  endmethod

  method lgdt_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(2, regBase, scale, regIndex, disp)
  endmethod

  method lidt_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(3, regBase, scale, regIndex, disp)
  endmethod

  method smsw_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(4, regBase, scale, regIndex, disp)
  endmethod

  method lmsw_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(6, regBase, scale, regIndex, disp)
  endmethod

  # Group 0f 01 /x: register operand
  method smsw_r(regSrc)
    this.emitCore_group0f_01_r(4, regSrc)
  endmethod

  method lmsw_r(regDst)
    this.emitCore_group0f_01_r(6, regDst)
  endmethod

  # 286: Other
  method lar_r_r(regDst, regSrc)
    global X64_LAR
    this.emitCore286_r_r(X64_LAR, regDst, regSrc)
  endmethod

  method lar_r_m16(regDst, regBase, scale, regIndex, disp)
    global X64_LAR
    this.emitCore286_r_m(X64_LAR, regDst, regBase, scale, regIndex, disp)
  endmethod

  method lsl_r_r(regDst, regSrc)
    global X64_LSL
    this.emitCore_r_r(X64_LSL, regSrc, regDst)
  endmethod

  method lsl_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LSL
    this.emitCore_m_r(X64_LSL, regBase, scale, regIndex, disp, regDst)
  endmethod

  method clts()
    global X64_CLTS
    this.emitWord(X64_CLTS)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80386 processor.
  #
  # Skipped mnemonics:
  #   pushad   - invalid in 64-bit mode
  #   popad    - invalid in 64-bit mode
  #   pushfd   - invalid in 64-bit mode
  #   popfd    - invalid in 64-bit mode
  #   loadalld - 80386 only
  #   ibts     - 80386 before B1 step only
  #   xbts     - 80386 before B1 step only
  #-----------------------------------------------------------------------------

  # TODO: mov to/from CR/DR/TR (already handled)
  # TODO: btx r,i8
  # TODO: btx m,i8

  method emitCore_bitTest_r_imm8(opcode, reg1, reg2)
    die('error: not implemented: btx r,imm8')
  endmethod

  method emitCore_bitTest_m_imm8(opcode, regBase, scale, regIndex, disp, reg, dataSize)
    die('error: not implemented: btx m,imm8')
  endmethod

  # Bit scan forward/reverse
  method bsf_r_r(regDst, regSrc)
    global X64_BSF
    this.emitCore_r_r(X64_BSF, regDst, regSrc)
  endmethod

  method bsf_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_BSF
    this.emitCore_r_m(X64_BSF, regDst, regBase, scale, regIndex, disp)
  endmethod

  method bsr_r_r(regDst, regSrc)
    global X64_BSR
    this.emitCore_r_r(X64_BSR, regDst, regSrc)
  endmethod

  method bsr_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_BSR
    this.emitCore_r_m(X64_BSR, regDst, regBase, scale, regIndex, disp)
  endmethod

  # btx r,r
  method bt_r_r(regDst, regSrc)
    global X64_BT_RM_R
    this.emitCore_r_r(X64_BT_RM_R, regDst, regSrc)
  endmethod

  method btc_r_r(regDst, regSrc)
    global X64_BTC_RM_R
    this.emitCore_r_r(X64_BTC_RM_R, regDst, regSrc)
  endmethod

  method btr_r_r(regDst, regSrc)
    global X64_BTR_RM_R
    this.emitCore_r_r(X64_BTR_RM_R, regDst, regSrc)
  endmethod

  method bts_r_r(regDst, regSrc)
    global X64_BTS_RM_R
    this.emitCore_r_r(X64_BTS_RM_R, regDst, regSrc)
  endmethod

  # btx r,m
  method bt_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_BT_RM_R
    this.emitCore_m_r(X64_BT_RM_R, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method btc_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_BTC_RM_R
    this.emitCore_m_r(X64_BTC_RM_R, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method btr_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_BTR_RM_R
    this.emitCore_m_r(X64_BTR_RM_R, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method bts_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_BTS_RM_R
    this.emitCore_m_r(X64_BTS_RM_R, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method lfs_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LFS
    this.emitCore286_r_m(X64_LFS, regDst, regBase,scale, regIndex, disp)
  endmethod

  method lgs_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LGS
    this.emitCore286_r_m(X64_LGS, regDst, regBase,scale, regIndex, disp)
  endmethod

  method lss_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LSS
    this.emitCore286_r_m(X64_LSS, regDst, regBase,scale, regIndex, disp)
  endmethod

  method shld_r_r_cl(regDst, regSrc)
    die('not implemented: shld r,r,cl')
  endmethod

  method shld_r_r_imm(regDst, regSrc, imm)
    die('not implemented: shld r,r,imm')
  endmethod

  method shld_r_r_cl(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: shld m,r,cl')
  endmethod

  method shld_m_r_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: shld m,r,imm')
  endmethod

  method shrd_r_r_cl(regDst, regSrc)
    die('not implemented: shrd r,r,cl')
  endmethod

  method shrd_r_r_imm(regDst, regSrc, imm)
    die('not implemented: shrd r,r,imm')
  endmethod

  method shrd_r_r_cl(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: shrd m,r,cl')
  endmethod

  method shrd_m_r_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: shrd m,r,imm')
  endmethod

  # setcc r8
  method seto_r8(regDst)
    global X64_SETO
    this.emitCore_r(X64_SETO, regDst)
  endmethod

  method setno_r8(regDst)
    global X64_SETNO
    this.emitCore_r(X64_SETNO, regDst)
  endmethod

  method setb_r8(regDst)
    global X64_SETB
    this.emitCore_r(X64_SETB, regDst)
  endmethod

  method setae_r8(regDst)
    global X64_SETAE
    this.emitCore_r(X64_SETAE, regDst)
  endmethod

  method sete_r8(regDst)
    global X64_SETE
    this.emitCore_r(X64_SETE, regDst)
  endmethod

  method setne_r8(regDst)
    global X64_SETNE
    this.emitCore_r(X64_SETNE, regDst)
  endmethod

  method setbe_r8(regDst)
    global X64_SETBE
    this.emitCore_r(X64_SETBE, regDst)
  endmethod

  method seta_r8(regDst)
    global X64_SETA
    this.emitCore_r(X64_SETA, regDst)
  endmethod

  method sets_r8(regDst)
    global X64_SETS
    this.emitCore_r(X64_SETS, regDst)
  endmethod

  method setns_r8(regDst)
    global X64_SETNS
    this.emitCore_r(X64_SETNS, regDst)
  endmethod

  method setp_r8(regDst)
    global X64_SETP
    this.emitCore_r(X64_SETP, regDst)
  endmethod

  method setnp_r8(regDst)
    global X64_SETNP
    this.emitCore_r(X64_SETNP, regDst)
  endmethod

  method setl_r8(regDst)
    global X64_SETL
    this.emitCore_r(X64_SETL, regDst)
  endmethod

  method setge_r8(regDst)
    global X64_SETGE
    this.emitCore_r(X64_SETGE, regDst)
  endmethod

  method setle_r8(regDst)
    global X64_SETLE
    this.emitCore_r(X64_SETLE, regDst)
  endmethod

  method setg_r8(regDst)
    global X64_SETG
    this.emitCore_r(X64_SETG, regDst)
  endmethod

  # setcc m8
  method seto_m8(regBase, scale, regIndex, disp)
    global X64_SETO
    this.emitCore_m(X64_SETO, regBase, scale, regIndex, disp)
  endmethod

  method setno_m8(regBase, scale, regIndex, disp)
    global X64_SETNO
    this.emitCore_m(X64_SETNO, regBase, scale, regIndex, disp)
  endmethod

  method setb_m8(regBase, scale, regIndex, disp)
    global X64_SETB
    this.emitCore_m(X64_SETB, regBase, scale, regIndex, disp)
  endmethod

  method setae_m8(regBase, scale, regIndex, disp)
    global X64_SETAE
    this.emitCore_m(X64_SETAE, regBase, scale, regIndex, disp)
  endmethod

  method sete_rm(regBase, scale, regIndex, disp)
    global X64_SETE
    this.emitCore_m(X64_SETE, regBase, scale, regIndex, disp)
  endmethod

  method setne_m8(regBase, scale, regIndex, disp)
    global X64_SETNE
    this.emitCore_m(X64_SETNE, regBase, scale, regIndex, disp)
  endmethod

  method setbe_m8(regBase, scale, regIndex, disp)
    global X64_SETBE
    this.emitCore_m(X64_SETBE, regBase, scale, regIndex, disp)
  endmethod

  method seta_m8(regBase, scale, regIndex, disp)
    global X64_SETA
    this.emitCore_m(X64_SETA, regBase, scale, regIndex, disp)
  endmethod

  method sets_m8(regBase, scale, regIndex, disp)
    global X64_SETS
    this.emitCore_m(X64_SETS, regBase, scale, regIndex, disp)
  endmethod

  method setns_m8(regBase, scale, regIndex, disp)
    global X64_SETNS
    this.emitCore_m(X64_SETNS, regBase, scale, regIndex, disp)
  endmethod

  method setp_m8(regBase, scale, regIndex, disp)
    global X64_SETP
    this.emitCore_m(X64_SETP, regBase, scale, regIndex, disp)
  endmethod

  method setnp_m8(regBase, scale, regIndex, disp)
    global X64_SETNP
    this.emitCore_m(X64_SETNP, regBase, scale, regIndex, disp)
  endmethod

  method setl_m8(regBase, scale, regIndex, disp)
    global X64_SETL
    this.emitCore_m(X64_SETL, regBase, scale, regIndex, disp)
  endmethod

  method setge_m8(regBase, scale, regIndex, disp)
    global X64_SETGE
    this.emitCore_m(X64_SETGE, regBase, scale, regIndex, disp)
  endmethod

  method setle_m8(regBase, scale, regIndex, disp)
    global X64_SETLE
    this.emitCore_m(X64_SETLE, regBase, scale, regIndex, disp)
  endmethod

  method setg_m8(regBase, scale, regIndex, disp)
    global X64_SETG
    this.emitCore_m(X64_SETG, regBase, scale, regIndex, disp)
  endmethod

  method cwde()
    global X64_CWDE
    this.emitByte(X64_CWDE)
  endmethod

  method cdq()
    global X64_CDQ
    this.emitWord(X64_CDQ)
  endmethod

  method iretd()
    this.iret()
  endmethod

  method movsd()
    global X64_MOVSD
    this.emitByte(X64_MOVSD)
  endmethod

  method cmpsd()
    global X64_CMPSD
    this.emitByte(X64_CMPSD)
  endmethod

  method lodsd()
    global X64_LODSD
    this.emitByte(X64_LODSD)
  endmethod

  method stosd()
    global X64_STOSD
    this.emitByte(X64_STOSD)
  endmethod

  method scasd()
    global X64_SCASD
    this.emitByte(X64_SCASD)
  endmethod

  method insd()
    global X64_INSD
    this.emitByte(X64_INSD)
  endmethod

  method outsd()
    global X64_OUTSD
    this.emitByte(X64_OUTSD)
  endmethod

  method emitCore_movExtend_r_r(opcode, regDst, regSrc)
    global X64_MOD_REGISTER
    # TODO: Clean up this mess.
    this.emitSizePrefixIfNeeded(regDst)
    if X64_IsReg8(regSrc) is false
      opcode = bitor(opcode, 256)
    endif

    this.emitWord(opcode)
    this.emitModRegRM(X64_MOD_REGISTER, regDst, regSrc)
  endmethod

  method emitCore_movExtend_r_m(opcode, regDst, regBase, scale, regIndex, disp)
    # TODO: Clean up this mess.
    # We Avoid to set up size bit in primary opcode.
    this.emitSizePrefixIfNeeded(regDst)
    regDstId = bitand(regDst, 0x7)
    this.emitCore_r_m(opcode, regDstId, regBase, scale, regIndex, disp)
  endmethod

  # movsx r,r/m
  method movsx_r_r(regDst, regSrc)
    global X64_MOVSX_R_RM8
    this.emitCore_movExtend_r_r(X64_MOVSX_R_RM8, regDst, regSrc)
  endmethod

  method movsx_r_m8(regDst, regBase, scale, regIndex, disp)
    global X64_MOVSX_R_RM8
    this.emitCore_movExtend_r_m(X64_MOVSX_R_RM8, regDst, regBase, scale, regIndex, disp)
  endmethod

  method movsx_r_m16(regDst, regBase, scale, regIndex, disp)
    global X64_MOVSX_R_RM16
    this.emitCore_movExtend_r_m(X64_MOVSX_R_RM16, regDst, regBase, scale, regIndex, disp)
  endmethod

  # movzx r,r/m
  method movzx_r_r(regDst, regSrc)
    global X64_MOVZX_R_RM8
    this.emitCore_movExtend_r_r(X64_MOVZX_R_RM8, regDst, regSrc)
  endmethod

  method movzx_r_m8(regDst, regBase, scale, regIndex, disp)
    global X64_MOVZX_R_RM8
    this.emitCore_movExtend_r_m(X64_MOVZX_R_RM8, regDst, regBase, scale, regIndex, disp)
  endmethod

  method movzx_r_m16(regDst, regBase, scale, regIndex, disp)
    global X64_MOVZX_R_RM16
    this.emitCore_movExtend_r_m(X64_MOVZX_R_RM16, regDst, regBase, scale, regIndex, disp)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80486 processor:
  #-----------------------------------------------------------------------------

  method bswap_r(reg)
    global X64_BSWAP
    this.emitSizePrefixIfNeeded(reg)
    this.emitWord(X64_BSWAP + 256 * bitand(reg, 0x7))
  endmethod

  method cmpxchg_r_r(regDst, regSrc)
    global X64_CMPXCHG_RM8_R8
    this.emitCore_r_r(X64_CMPXCHG_RM8_R8, regDst, regSrc)
  endmethod

  method cmpxchg_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_CMPXCHG_RM8_R8
    this.emitCore_m_r(X64_CMPXCHG_RM8_R8, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method xadd_r_r(regDst, regSrc)
    global X64_XADD_RM8_R8
    this.emitCore_r_r(X64_XADD_RM8_R8, regDst, regSrc)
  endmethod

  method xadd_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_XADD_RM8_R8
    this.emitCore_m_r(X64_XADD_RM8_R8, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method invlpg_m(regBase, scale, regIndex, disp)
    this.emitCore_group0f_01_m(6, regBase, scale, regIndex, disp)
  endmethod

  method invd()
    global X64_INVD
    this.emitWord(X64_INVD)
  endmethod

  method wbinvd()
    global X64_WBINVD
    this.emitWord(X64_WBINVD)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Pentium processor:
  #-----------------------------------------------------------------------------

  method cmpxchg8b_m(regBase, scale, regIndex, disp)
    global X64_CMPXCHG8B
    this.emitCore_group_m(X64_CMPXCHG8B, 1, regBase, scale, regIndex, disp)
  endmethod

  method cpuid()
    global X64_CPUID
    this.emitWord(X64_CPUID)
  endmethod

  method rdmsr()
    global X64_RDMSR
    this.emitWord(X64_RDMSR)
  endmethod

  method rdtsc()
    global X64_RDTSC
    this.emitWord(X64_RDTSC)
  endmethod

  method wrmsr()
    global X64_WRMSR
    this.emitWord(X64_WRMSR)
  endmethod

  method rsm()
    global X64_RSM
    this.emitWord(X64_RSM)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Penitum Pro processor:
  #-----------------------------------------------------------------------------

  # r,r
  method cmovo_r_r(regDst, regSrc)
    global X64_CMOVO
    this.emitCore_r_r(X64_CMOVO, regDst, regSrc)
  endmethod

  method cmovno_r_r(regDst, regSrc)
    global X64_CMOVNO
    this.emitCore_r_r(X64_CMOVNO, regDst, regSrc)
  endmethod

  method cmovb_r_r(regDst, regSrc)
    global X64_CMOVB
    this.emitCore_r_r(X64_CMOVB, regDst, regSrc)
  endmethod

  method cmove_r_r(regDst, regSrc)
    global X64_CMOVE
    this.emitCore_r_r(X64_CMOVE, regDst, regSrc)
  endmethod

  method cmovne_r_r(regDst, regSrc)
    global X64_CMOVNE
    this.emitCore_r_r(X64_CMOVNE, regDst, regSrc)
  endmethod

  method cmovbe_r_r(regDst, regSrc)
    global X64_CMOVBE
    this.emitCore_r_r(X64_CMOVBE, regDst, regSrc)
  endmethod

  method cmova_r_r(regDst, regSrc)
    global X64_CMOVA
    this.emitCore_r_r(X64_CMOVA, regDst, regSrc)
  endmethod

  method cmovs_r_r(regDst, regSrc)
    global X64_CMOVS
    this.emitCore_r_r(X64_CMOVS, regDst, regSrc)
  endmethod

  method cmovns_r_r(regDst, regSrc)
    global X64_CMOVNS
    this.emitCore_r_r(X64_CMOVNS, regDst, regSrc)
  endmethod

  method cmovp_r_r(regDst, regSrc)
    global X64_CMOVP
    this.emitCore_r_r(X64_CMOVP, regDst, regSrc)
  endmethod

  method cmovnp_r_r(regDst, regSrc)
    global X64_CMOVNP
    this.emitCore_r_r(X64_CMOVNP, regDst, regSrc)
  endmethod

  method cmovl_r_r(regDst, regSrc)
    global X64_CMOVL
    this.emitCore_r_r(X64_CMOVL, regDst, regSrc)
  endmethod

  method cmovge_r_r(regDst, regSrc)
    global X64_CMOVGE
    this.emitCore_r_r(X64_CMOVGE, regDst, regSrc)
  endmethod

  method cmovg_r_r(regDst, regSrc)
    global X64_CMOVG
    this.emitCore_r_r(X64_CMOVG, regDst, regSrc)
  endmethod

  # r,m
  method cmovo_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVO
    this.emitCore_r_m(X64_CMOVO, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovno_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVNO
    this.emitCore_r_m(X64_CMOVNO, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovb_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVB
    this.emitCore_r_m(X64_CMOVB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmove_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVE
    this.emitCore_r_m(X64_CMOVE, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovne_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVNE
    this.emitCore_r_m(X64_CMOVNE, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovbe_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVBE
    this.emitCore_r_m(X64_CMOVBE, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmova_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVA
    this.emitCore_r_m(X64_CMOVA, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovs_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVS
    this.emitCore_r_m(X64_CMOVS, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovns_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVNS
    this.emitCore_r_m(X64_CMOVNS, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovp_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVP
    this.emitCore_r_m(X64_CMOVP, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovnp_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVNP
    this.emitCore_r_m(X64_CMOVNP, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovl_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVL
    this.emitCore_r_m(X64_CMOVL, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovge_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVGE
    this.emitCore_r_m(X64_CMOVGE, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmovg_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMOVG
    this.emitCore_r_m(X64_CMOVG, regDst, regBase, scale, regIndex, disp)
  endmethod

  method ud2()
    global X64_UD2
    this.emitWord(X64_UD2)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Penium MMX processor:
  #-----------------------------------------------------------------------------

  method rdpmc()
    global X64_RDPMC
    this.emitWord(X64_RDPMC)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with AMD K6 processor:
  #-----------------------------------------------------------------------------

  method syscall()
    global X64_SYSCALL
    this.emitWord(X64_SYSCALL)
  endmethod

  method sysret()
    global X64_SYSRET
    this.emitWord(X64_SYSRET)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Penitum II:
  #-----------------------------------------------------------------------------

  method sysenter()
    global X64_SYSENTER
    this.emitWord(X64_SYSENTER)
  endmethod

  method sysexit()
    global X64_SYSEXIT
    this.emitWord(X64_SYSEXIT)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Amd64:
  #-----------------------------------------------------------------------------

  method movsxd_r64_r32(regDst, regSrc)
    global X64_MOVSXD
    this.emitCore_r_r(X64_MOVSXD, regDst, regSrc)
  endmethod

  method movsxd_r64_m32(regDst, regBase, scale, regIndex, disp)
    global X64_MOVSXD
    this.emitCore_r_m(X64_MOVSXD, regDst, regBase, scale, regIndex, disp)
  endmethod

  method cmpxchg16b_m(regBase, scale, regIndex, disp)
    this.emitPrefix64()
    this.cmpxchg8b_m(regBase, scale, regIndex, disp)
  endmethod

  method cdqe()
    global X64_CDQE
    this.emitWord(X64_CDQE)
  endmethod

  method cqo()
    global X64_CQO
    this.emitWord(X64_CQO)
  endmethod

  method cmpsq()
    global X64_CMPSQ
    this.emitWord(X64_CMPSQ)
  endmethod

  method stosq()
    global X64_STOSQ
    this.emitWord(X64_STOSQ)
  endmethod

  method lodsq()
    global X64_LODSQ
    this.emitWord(X64_LODSQ)
  endmethod

  method scasq()
    global X64_SCASQ
    this.emitWord(X64_SCASQ)
  endmethod

  method iretq()
    global X64_IRETQ
    this.emitWord(X64_IRETQ)
  endmethod

  method popfq()
    global X64_POPFQ
    this.emitWord(X64_POPFQ)
  endmethod

  method pushfq()
    global X64_PUSHFQ
    this.emitWord(X64_PUSHFQ)
  endmethod

  method rdtscp()
    global X64_RDTSCP
    this.emitByte(0xf)
    this.emitWord(X64_RDTSCP)
  endmethod

  method swapgs()
    global X64_SWAPGS
    this.emitByte(0xf)
    this.emitWord(X64_SWAPGS)
  endmethod

  # ----------------------------------------------------------------------------
  #                 Public API: FPU instruction set (x87)
  # ----------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # Original mnemonics from 8087 coprocessor (FPU).
  #
  # fdisi  - 8087 only
  # feni   - 8087 only
  # fndisi - 8087 only
  # fneni  - 8087 only
  # ------------------------------------------------------------------------------

  method emitFPU_sti(opcode, sti)
    # TODO: Optimize it.
    # xx yy+i
    stiId  = bitand(sti, 0x7)
    opcode = bitor(opcode, 256 * stiId)
    this.emitWord(opcode)
  endmethod

  method emitFPU_m(mixedOpcode, regBase, scale, regIndex, disp)
    baseOpcode  = bitand(mixedOpcode, 0xff)
    operationId = bitand(mixedOpcode // 256, 0x07)
    this.emitCore_group_m(baseOpcode, operationId, regBase, scale, regIndex, disp)
  endmethod

  method emitFPU_st0_sti(operationId, stSrc)
    global X64_GROUP_ST0_STI
    this.emitCore_group_r(X64_GROUP_ST0_STI, operationId, bitand(stSrc, 0x7))
  endmethod

  method emitFPU_sti_st0(operationId, stDst)
    global X64_GROUP_STI_ST0
    this.emitCore_group_r(X64_GROUP_STI_ST0, operationId, bitand(stDst, 0x7))
  endmethod

  method emitFPU_m32real(operationId, regBase, scale, regIndex, disp)
    global X64_GROUP_M32REAL
    this.emitCore_group_m(X64_GROUP_M32REAL, operationId, regBase, scale, regIndex, disp)
  endmethod

  method emitFPU_m64real(operationId, regBase, scale, regIndex, disp)
    global X64_GROUP_M64REAL
    this.emitCore_group_m(X64_GROUP_M64REAL, operationId, regBase, scale, regIndex, disp)
  endmethod

  # st0,sti
  method fadd_st0_sti(stSrc)
    this.emitFPU_st0_sti(0, stSrc)
  endmethod

  method fmul_st0_sti(stSrc)
    this.emitFPU_st0_sti(1, stSrc)
  endmethod

  method fcom_st0_sti(stSrc)
    this.emitFPU_st0_sti(2, stSrc)
  endmethod

  method fcomp_st0_sti(stSrc)
    this.emitFPU_st0_sti(3, stSrc)
  endmethod

  method fsub_st0_sti(stSrc)
    this.emitFPU_st0_sti(4, stSrc)
  endmethod

  method fsubr_st0_sti(stSrc)
    this.emitFPU_st0_sti(5, stSrc)
  endmethod

  method fdiv_st0_sti(stSrc)
    this.emitFPU_st0_sti(6, stSrc)
  endmethod

  method fdivr_st0_sti(stSrc)
    this.emitFPU_st0_sti(7, stSrc)
  endmethod

  # sti,st0
  method fadd_sti_st0(stDst)
    this.emitFPU_sti_st0(0, stDst)
  endmethod

  method fmul_sti_st0(stDst)
    this.emitFPU_sti_st0(1, stDst)
  endmethod

  method fsub_sti_st0(stDst)
    this.emitFPU_sti_st0(4, stDst)
  endmethod

  method fsubr_sti_st0(stDst)
    this.emitFPU_sti_st0(5, stDst)
  endmethod

  method fdiv_sti_st0(stDst)
    this.emitFPU_sti_st0(6, stDst)
  endmethod

  method fdivr_sti_st0(stDst)
    this.emitFPU_sti_st0(7, stDst)
  endmethod

  # m32real
  method fadd_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(0, regBase, scale, regIndex, disp)
  endmethod

  method fmul_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(1, regBase, scale, regIndex, disp)
  endmethod

  method fcom_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(2, regBase, scale, regIndex, disp)
  endmethod

  method fcomp_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(3, regBase, scale, regIndex, disp)
  endmethod

  method fsub_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(4, regBase, scale, regIndex, disp)
  endmethod

  method fsubr_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(5, regBase, scale, regIndex, disp)
  endmethod

  method fdiv_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(6, regBase, scale, regIndex, disp)
  endmethod

  method fdivr_m32(regBase, scale, regIndex, disp)
    this.emitFPU_m32real(7, regBase, scale, regIndex, disp)
  endmethod

  # m64real
  method fadd_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(0, regBase, scale, regIndex, disp)
  endmethod

  method fmul_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(1, regBase, scale, regIndex, disp)
  endmethod

  method fcom_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(2, regBase, scale, regIndex, disp)
  endmethod

  method fcomp_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(3, regBase, scale, regIndex, disp)
  endmethod

  method fsub_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(4, regBase, scale, regIndex, disp)
  endmethod

  method fsubr_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(5, regBase, scale, regIndex, disp)
  endmethod

  method fdiv_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(6, regBase, scale, regIndex, disp)
  endmethod

  method fdivr_m64(regBase, scale, regIndex, disp)
    this.emitFPU_m64real(7, regBase, scale, regIndex, disp)
  endmethod


  method faddp_sti_st0(stDst)
    global X64_FADDP_STI_ST0
    this.emitFPU_sti(X64_FADDP_STI_ST0, stDst)
  endmethod

  method fdivp_sti_st0(stDst)
    global X64_FDIVP_STI_ST0
    this.emitFPU_sti(X64_FDIVP_STI_ST0, stDst)
  endmethod

  method fdivrp_sti_st0(stDst)
    global X64_FDIVRP_STI_ST0
    this.emitFPU_sti(X64_FDIVRP_STI_ST0, stDst)
  endmethod

  method fmulp_sti_st0(stDst)
    global X64_FMULP_STI_ST0
    this.emitFPU_sti(X64_FMULP_STI_ST0, stDst)
  endmethod

  method fsubp_sti_st0(stDst)
    global X64_FSUBP_STI_ST0
    this.emitFPU_sti(X64_FSUBP_STI_ST0, stDst)
  endmethod

  method fsubrp_sti_st0(stDst)
    global X64_FSUBRP_STI_ST0
    this.emitFPU_sti(X64_FSUBRP_STI_ST0, stDst)
  endmethod

  method fxch_sti(stSrc)
    global X64_FXCH_STI
    this.emitFPU_sti(X64_FXCH_STI, stSrc)
  endmethod

  method fcom()
    this.fcom_st0_sti(1)
  endmethod

  method fxch()
    this.fxch_sti(1)
  endmethod

  method fild_m16(regBase, scale, regIndex, disp)
    global X64_FILD_M16
    this.emitFPU_m(X64_FILD_M16, regBase, scale, regIndex, disp)
  endmethod

  method fild_m32(regBase, scale, regIndex, disp)
    global X64_FILD_M32
    this.emitFPU_m(X64_FILD_M32, regBase, scale, regIndex, disp)
  endmethod

  method fild_m64(regBase, scale, regIndex, disp)
    global X64_FILD_M64
    this.emitFPU_m(X64_FILD_M64, regBase, scale, regIndex, disp)
  endmethod

  method fistp_m16(regBase, scale, regIndex, disp)
    global X64_FISTP_M16
    this.emitFPU_m(X64_FISTP_M16, regBase, scale, regIndex, disp)
  endmethod

  method fistp_m32(regBase, scale, regIndex, disp)
    global X64_FISTP_M32
    this.emitFPU_m(X64_FISTP_M32, regBase, scale, regIndex, disp)
  endmethod

  method fistp_m64(regBase, scale, regIndex, disp)
    global X64_FISTP_M64
    this.emitFPU_m(X64_FISTP_M64, regBase, scale, regIndex, disp)
  endmethod

  method fiadd_m16(regBase, scale, regIndex, disp)
    global X64_FIADD_M16
    this.emitFPU_m(X64_FIADD_M16, regBase, scale, regIndex, disp)
  endmethod

  method fiadd_m32(regBase, scale, regIndex, disp)
    global X64_FIADD_M32
    this.emitFPU_m(X64_FIADD_M32, regBase, scale, regIndex, disp)
  endmethod

  method fimul_m16(regBase, scale, regIndex, disp)
    global X64_FIMUL_M16
    this.emitFPU_m(X64_FIMUL_M16, regBase, scale, regIndex, disp)
  endmethod

  method fimul_m32(regBase, scale, regIndex, disp)
    global X64_FIMUL_M32
    this.emitFPU_m(X64_FIMUL_M32, regBase, scale, regIndex, disp)
  endmethod

  method fidiv_m16(regBase, scale, regIndex, disp)
    global X64_FIDIV_M16
    this.emitFPU_m(X64_FIDIV_M16, regBase, scale, regIndex, disp)
  endmethod

  method fidiv_m32(regBase, scale, regIndex, disp)
    global X64_FIDIV_M32
    this.emitFPU_m(X64_FIDIV_M32, regBase, scale, regIndex, disp)
  endmethod

  method fidivr_m16(regBase, scale, regIndex, disp)
    global X64_FIDIVR_M16
    this.emitFPU_m(X64_FIDIVR_M16, regBase, scale, regIndex, disp)
  endmethod

  method fidivr_m32(regBase, scale, regIndex, disp)
    global X64_FIDIVR_M32
    this.emitFPU_m(X64_FIDIVR_M32, regBase, scale, regIndex, disp)
  endmethod

  method fisub_m16(regBase, scale, regIndex, disp)
    global X64_FISUB_M16
    this.emitFPU_m(X64_FISUB_M16, regBase, scale, regIndex, disp)
  endmethod

  method fisub_m32(regBase, scale, regIndex, disp)
    global X64_FISUB_M32
    this.emitFPU_m(X64_FISUB_M32, regBase, scale, regIndex, disp)
  endmethod

  method fisubr_m16(regBase, scale, regIndex, disp)
    global X64_FISUBR_M16
    this.emitFPU_m(X64_FISUBR_M16, regBase, scale, regIndex, disp)
  endmethod

  method fisubr_m32(regBase, scale, regIndex, disp)
    global X64_FISUBR_M32
    this.emitFPU_m(X64_FISUBR_M32, regBase, scale, regIndex, disp)
  endmethod

  method fist_m16(regBase, scale, regIndex, disp)
    global X64_FIST_M16
    this.emitFPU_m(X64_FIST_M16, regBase, scale, regIndex, disp)
  endmethod

  method fist_m32(regBase, scale, regIndex, disp)
    global X64_FIST_M32
    this.emitFPU_m(X64_FIST_M32, regBase, scale, regIndex, disp)
  endmethod

  method ficom_m16(regBase, scale, regIndex, disp)
    global X64_FICOM_M16
    this.emitFPU_m(X64_FICOM_M16, regBase, scale, regIndex, disp)
  endmethod

  method ficom_m32(regBase, scale, regIndex, disp)
    global X64_FICOM_M32
    this.emitFPU_m(X64_FICOM_M32, regBase, scale, regIndex, disp)
  endmethod

  method ficomp_m16(regBase, scale, regIndex, disp)
    global X64_FICOMP_M16
    this.emitFPU_m(X64_FICOMP_M16, regBase, scale, regIndex, disp)
  endmethod

  method ficomp_m32(regBase, scale, regIndex, disp)
    global X64_FICOMP_M32
    this.emitFPU_m(X64_FICOMP_M32, regBase, scale, regIndex, disp)
  endmethod

  method ffree_sti(sti)
    global X64_FFREE_STI
    this.emitFPU_sti(X64_FFREE_STI, sti)
  endmethod

  # fld m32 | m64 | m80 | sti
  method fld_m32(regBase, scale, regIndex, disp)
    global X64_FLD_M32
    this.emitFPU_m(X64_FLD_M32, regBase, scale, regIndex, disp)
  endmethod

  method fld_m64(regBase, scale, regIndex, disp)
    global X64_FLD_M64
    this.emitFPU_m(X64_FLD_M64, regBase, scale, regIndex, disp)
  endmethod

  method fld_m80(regBase, scale, regIndex, disp)
    global X64_FLD_M80
    this.emitFPU_m(X64_FLD_M80, regBase, scale, regIndex, disp)
  endmethod

  method fld_sti(stDst)
    global X64_FLD_STI
    this.emitFPU_sti(X64_FLD_STI, stDst)
  endmethod

  # fst m32 | m64 | m80 | sti
  method fstp_m32(regBase, scale, regIndex, disp)
    global X64_FSTP_M32
    this.emitFPU_m(X64_FSTP_M32, regBase, scale, regIndex, disp)
  endmethod

  method fstp_m64(regBase, scale, regIndex, disp)
    global X64_FSTP_M64
    this.emitFPU_m(X64_FSTP_M64, regBase, scale, regIndex, disp)
  endmethod

  method fstp_m80(regBase, scale, regIndex, disp)
    global X64_FSTP_M80
    this.emitFPU_m(X64_FSTP_M80, regBase, scale, regIndex, disp)
  endmethod

  method fstp_sti(stSrc)
    global X64_FSTP_STI
    this.emitFPU_sti(X64_FSTP_STI, stSrc)
  endmethod

  # fst m32 | m64 | sti
  method fst_m32(regBase, scale, regIndex, disp)
    global X64_FST_M32
    this.emitFPU_m(X64_FST_M32, regBase, scale, regIndex, disp)
  endmethod

  method fst_m64(regBase, scale, regIndex, disp)
    global X64_FST_M64
    this.emitFPU_m(X64_FST_M64, regBase, scale, regIndex, disp)
  endmethod

  method fst_sti(stSrc)
    global X64_FST_STI
    this.emitFPU_sti(X64_FST_STI, stSrc)
  endmethod

  method fnstsw_ax()
    global X64_FNSTSW_AX
    this.emitWord(X64_FNSTSW_AX)
  endmethod

  method fnstsw_m16(regBase, scale, regIndex, disp)
    global X64_FNSTSW_M16
    this.emitFPU_m(X64_FNSTSW_M16, regBase, scale, regIndex, disp)
  endmethod

  method fstsw_ax()
    this.fwait()
    this.fnstsw_ax()
  endmethod

  method fstsw_m16(regBase, scale, regIndex, disp)
   this.fwait()
   this.fnstsw_m16(regBase, scale, regIndex, disp)
  endmethod

  method frstor_m(regBase, scale, regIndex, disp)
    global X64_FRSTOR
    this.emitFPU_m(X64_FRSTOR, regBase, scale, regIndex, disp)
  endmethod

  method fnsave_m(regBase, scale, regIndex, disp)
    global X64_FNSAVE
    this.emitFPU_m(X64_FNSAVE, regBase, scale, regIndex, disp)
  endmethod

  method fsave_m(regBase, scale, regIndex, disp)
   this.fwait()
   this.fnsave_m(regBase, scale, regIndex, disp)
  endmethod

  method fnstenv_m(regBase, scale, regIndex, disp)
    global X64_FNSTENV
    this.emitFPU_m(X64_FNSTENV, regBase, scale, regIndex, disp)
  endmethod

  method fnstenvw_m(regBase, scale, regIndex, disp)
    this.emitPrefix16()
    this.fnstenv_m(regBase, scale, regIndex, disp)
  endmethod

  method fstenv_m(regBase, scale, regIndex, disp)
    this.fwait()
    this.fnstenv_m(regBase, scale, regIndex, disp)
  endmethod

  method fnstcw_m(regBase, scale, regIndex, disp)
    global X64_FNSTCW
    this.emitFPU_m(X64_FNSTCW, regBase, scale, regIndex, disp)
  endmethod

  method fldcw_m(regBase, scale, regIndex, disp)
    global X64_FLDCW
    this.emitFPU_m(X64_FLDCW, regBase, scale, regIndex, disp)
  endmethod

  method fstcw_m(regBase, scale, regIndex, disp)
    this.fwait()
    this.fnstcw_m(regBase, scale, regIndex, disp)
  endmethod

  method fbld_m(regBase, scale, regIndex, disp)
    global X64_FBLD
    this.emitFPU_m(X64_FBLD, regBase, scale, regIndex, disp)
  endmethod

  method fbstp_m(regBase, scale, regIndex, disp)
    global X64_FBSTP
    this.emitFPU_m(X64_FBSTP, regBase, scale, regIndex, disp)
  endmethod

  method fldenv_m(regBase, scale, regIndex, disp)
    global X64_FLDENV
    this.emitFPU_m(X64_FLDENV, regBase, scale, regIndex, disp)
  endmethod

  method fldenvw_m(regBase, scale, regIndex, disp)
    this.emitPrefix16()
    this.fldenv_m(regBase, scale, regIndex, disp)
  endmethod

  method fnsavew_m(regBase, scale, regIndex, disp)
    this.emitPrefix16()
    this.fnsave_m(regBase, scale, regIndex, disp)
  endmethod

  method frstorw_m(regBase, scale, regIndex, disp)
    this.emitPrefix16()
    this.frstor_m(regBase, scale, regIndex, disp)
  endmethod

  method fsavew_m(regBase, scale, regIndex, disp)
    this.fwait()
    this.fnsavew_m(regBase, scale, regIndex, disp)
  endmethod

  method fstenvw_m(regBase, scale, regIndex, disp)
    this.fwait()
    this.fnstenvw_m(regBase, scale, regIndex, disp)
  endmethod

  method f2xm1()
    global X64_F2XM1
    this.emitWord(X64_F2XM1)
  endmethod

  method fabs()
    global X64_FABS
    this.emitWord(X64_FABS)
  endmethod

  method fchs()
    global X64_FCHS
    this.emitWord(X64_FCHS)
  endmethod

  method fclex()
    this.fwait()
    this.fnclex()
  endmethod

  method fcompp()
    global X64_FCOMPP
    this.emitWord(X64_FCOMPP)
  endmethod

  method fdecstp()
    global X64_FDECSTP
    this.emitWord(X64_FDECSTP)
  endmethod

  method fincstp()
    global X64_FINCSTP
    this.emitWord(X64_FINCSTP)
  endmethod

  method finit()
    this.fwait()
    this.fninit()
  endmethod

  method fld1()
    global X64_FLD1
    this.emitWord(X64_FLD1)
  endmethod

  method fldl2e()
    global X64_FLDL2E
    this.emitWord(X64_FLDL2E)
  endmethod

  method fldl2t()
    global X64_FLDL2T
    this.emitWord(X64_FLDL2T)
  endmethod

  method fldlg2()
    global X64_FLDLG2
    this.emitWord(X64_FLDLG2)
  endmethod

  method fldln2()
    global X64_FLDLN2
    this.emitWord(X64_FLDLN2)
  endmethod

  method fldpi()
    global X64_FLDPI
    this.emitWord(X64_FLDPI)
  endmethod

  method fldz()
    global X64_FLDZ
    this.emitWord(X64_FLDZ)
  endmethod

  method fnclex()
    global X64_FNCLEX
    this.emitWord(X64_FNCLEX)
  endmethod

  method fninit()
    global X64_FNINIT
    this.emitWord(X64_FNINIT)
  endmethod

  method fnop()
    global X64_FNOP
    this.emitWord(X64_FNOP)
  endmethod

  method fpatan()
    global X64_FPATAN
    this.emitWord(X64_FPATAN)
  endmethod

  method fprem()
    global X64_FPREM
    this.emitWord(X64_FPREM)
  endmethod

  method fptan()
    global X64_FPTAN
    this.emitWord(X64_FPTAN)
  endmethod

  method frndint()
    global X64_FRNDINT
    this.emitWord(X64_FRNDINT)
  endmethod

  method fscale()
    global X64_FSCALE
    this.emitWord(X64_FSCALE)
  endmethod

  method fsqrt()
    global X64_FSQRT
    this.emitWord(X64_FSQRT)
  endmethod

  method ftst()
    global X64_FTST
    this.emitWord(X64_FTST)
  endmethod

  method fwait()
    this.wait()
  endmethod

  method fxam()
    global X64_FXAM
    this.emitWord(X64_FXAM)
  endmethod

  method fxtract()
    global X64_FXTRACT
    this.emitWord(X64_FXTRACT)
  endmethod

  method fyl2x()
    global X64_FYL2X
    this.emitWord(X64_FYL2X)
  endmethod

  method fyl2xp1()
    global X64_FYL2XP1
    this.emitWord(X64_FYL2XP1)
  endmethod

  # ------------------------------------------------------------------------------
  # FPU mnemonics added with 80287.
  # fsetpm - 80287 only
  # ------------------------------------------------------------------------------

  # ------------------------------------------------------------------------------
  # FPU mnemonics added with 80387.
  # ------------------------------------------------------------------------------

  method fucom_sti(stSrc)
    global X64_FUCOM_STI
    this.emitFPU_sti(X64_FUCOM_STI, stSrc)
  endmethod

  method fucomp_sti(stSrc)
    global X64_FUCOMP_STI
    this.emitFPU_sti(X64_FUCOMP_STI, stSrc)
  endmethod

  method fucom()
    this.fucom_sti(1)
  endmethod

  method fucomp()
    this.fucomp_sti(1)
  endmethod

  method fsin()
    global X64_FSIN
    this.emitWord(X64_FSIN)
  endmethod

  method fcos()
    global X64_FCOS
    this.emitWord(X64_FCOS)
  endmethod

  method fsincos()
    global X64_FSINCOS
    this.emitWord(X64_FSINCOS)
  endmethod

  method fprem1()
    global X64_FPREM1
    this.emitWord(X64_FPREM1)
  endmethod

  method fucompp()
    global X64_FUCOMPP
    this.emitWord(X64_FUCOMPP)
  endmethod

  # ------------------------------------------------------------------------------
  # FPU mnemonics added with Penium Pro.
  # ------------------------------------------------------------------------------

  method fcmovb_st0_sti(sti)
    global X64_FCMOVB
    this.emitFPU_sti(X64_FCMOVB, sti)
  endmethod

  method fcmovbe_st0_sti(sti)
    global X64_FCMOVBE
    this.emitFPU_sti(X64_FCMOVBE, sti)
  endmethod

  method fcmove_st0_sti(sti)
    global X64_FCMOVE
    this.emitFPU_sti(X64_FCMOVE, sti)
  endmethod

  method fcmovnb_st0_sti(sti)
    global X64_FCMOVNB
    this.emitFPU_sti(X64_FCMOVNB, sti)
  endmethod

  method fcmovnbe_st0_sti(sti)
    global X64_FCMOVNBE
    this.emitFPU_sti(X64_FCMOVNBE, sti)
  endmethod

  method fcmovne_st0_sti(sti)
    global X64_FCMOVNE
    this.emitFPU_sti(X64_FCMOVNE, sti)
  endmethod

  method fcmovnu_st0_sti(sti)
    global X64_FCMOVNU
    this.emitFPU_sti(X64_FCMOVNU, sti)
  endmethod

  method fcmovu_st0_sti(sti)
    global X64_FCMOVU
    this.emitFPU_sti(X64_FCMOVU, sti)
  endmethod

  method fcomi_st0_sti(stSrc)
    global X64_FCOMI
    this.emitFPU_sti(X64_FCOMI, stSrc)
  endmethod

  method fcomip_st0_sti(stSrc)
    global X64_FUCOMIP
    this.emitFPU_sti(X64_FUCOMIP, stSrc)
  endmethod

  method fucomi_st0_sti(stSrc)
    global X64_FUCOMI
    this.emitFPU_sti(X64_FUCOMI, stSrc)
  endmethod

  method fucomip_st0_sti(stSrc)
    global X64_FUCOMIP
    this.emitFPU_sti(X64_FUCOMIP, stSrc)
  endmethod

  # ------------------------------------------------------------------------------
  # FPU mnemonics added with SSE extension.
  # ------------------------------------------------------------------------------

  method fxsave_m(regBase, scale, regIndex, disp)
    global X64_GROUP_STATE
    this.emitCore_group_m(X64_GROUP_STATE, 0, regBase, scale, regIndex, disp)
  endmethod

  method fxrstor_m(regBase, scale, regIndex, disp)
    global X64_GROUP_STATE
    this.emitCore_group_m(X64_GROUP_STATE, 1, regBase, scale, regIndex, disp)
  endmethod

  # ------------------------------------------------------------------------------
  # FPU mnemonics added with SSE3 extension.
  # ------------------------------------------------------------------------------

  method fisttp_m16(regBase, scale, regIndex, disp)
    global X64_FISTTP_M16
    this.emitFPU_m(X64_FISTTP_M16, regBase, scale, regIndex, disp)
  endmethod

  method fisttp_m32(regBase, scale, regIndex, disp)
    global X64_FISTTP_M32
    this.emitFPU_m(X64_FISTTP_M32, regBase, scale, regIndex, disp)
  endmethod

  method fisttp_m64(regBase, scale, regIndex, disp)
    global X64_FISTTP_M64
    this.emitFPU_m(X64_FISTTP_M64, regBase, scale, regIndex, disp)
  endmethod

  #
  # Other
  #

  method getCurrentPosition() -> rv
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass

#encoder = new X64Encoder()
#this.rcl_r_imm(X64_RBX, 1)
