################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Libs/BitwiseHack.mold'

/*
TODO
marco DEFINE_OPCODE_CORE_R_R(mnemonic, opcode)
  method ${mnemonic}_r_r(regDst, regSrc)
    this.emitCore_r_r(opcode, regDst, regSrc)
  endmethod
endmacro

DEFINE_OPCODE_CORE_R_R(add, X64_ADD)
DEFINE_OPCODE_CORE_R_R(sub, X64_SUB)
DEFINE_OPCODE_CORE_R_R(xor, X64_XOR)
DEFINE_OPCODE_CORE_R_R(or,  X64_OR)
DEFINE_OPCODE_CORE_R_R(and, X64_AND)
...
*/

class X64Encoder
  method constructor()
    this.outputObject = false
#    this.pos = 0
  endmethod

  method emitByte(x)
    this.outputObject.emitByte(x)
#    this.pos = this.pos + 1
  endmethod

  method emitWord(x)
    this.outputObject.emitWord(x)
#    this.pos = this.pos + 2
  endmethod

  method emitDword(x)
    this.outputObject.emitDword(x)
#    this.pos = this.pos + 4
  endmethod

  method emitQword(x)
    this.outputObject.emitQword(x)
#    this.pos = this.pos + 8
  endmethod

  # ----------------------------------------------------------------------------
  #                             Common helpers
  # ----------------------------------------------------------------------------

  method emitModRegRM(addressMode, reg, rm)
    # 7 6 | 5 4 3 | 2 1 0
    # mod | reg   | r/m
    reg = bitand(reg, 0x7)
    rm  = bitand(rm,  0x7)
    this.emitByte(addressMode * 64 + reg * 8 + rm)
  endmethod

  method emitPrimaryOpcode(opcodeMask, direct, size)
    # 7 6 5 4 3 2 | 1 0
    # opcode      | d s
    this.emitByte(opcodeMask + direct * 2 + size)
  endmethod

  method emitPrefix16()
    this.emitByte(0x66)
  endmethod

  method emitPrefix64()
    this.emitByte(0x48)
  endmethod

  method emitSizePrefixIfNeeded(reg)
    if X64_IsReg16(reg) is true
      # 16-bit: Emit operand size prefix.
      this.emitPrefix16()

    elif X64_IsReg64(reg) is true
      # 64-bit: Emit REX.W prefix.
      this.emitPrefix64()
    endif
  endmethod

  # ----------------------------------------------------------------------------
  #                        Core encoding patterns
  # ----------------------------------------------------------------------------

  method emitCore(opcode, mode, reg, rm)
    # opcode | mod-reg-rm | SIB    | displacement | immediate
    # 1-2B   | 0 or 1     | 0 or 1 | 0, 1, 2 or 4 | 0, 1, 2 or 4
    # bytes  | byte       | byte   | bytes        | bytes

    global X64_SIZE16_32_64

    # Emit prefixes if needed.
    if X64_IsReg8(reg) is false
      # 16, 32 or 64-bit operand(s)
      # 32-bit is default (no prefix needed)
      # Set size bit in primary operand byte.
      opcode = bitor(opcode, X64_SIZE16_32_64)
      this.emitSizePrefixIfNeeded(reg)
    endif

    # Primary opcode.
    if opcode > 255
      this.emitWord(opcode)
    else
      this.emitByte(opcode)
    endif

    # Mod-Reg-R/M byte.
    this.emitModRegRM(mode, reg, rm)
  endmethod

  method emitCore_r_r(opcode, regDst, regSrc)
    global X64_MOD_REGISTER
    this.emitCore(opcode, X64_MOD_REGISTER, regSrc, regDst)
  endmethod

  method emitCore_m_r(opcode, regBase, scale, regIndex, disp, regSrc)
    global X64_MOD_INDIRECT, X64_MOD_DISP8, X64_MOD_DISP32
    global X64_RM_SIB_MODE, X64_RM_RIP_DISP_MODE
    global X64_SIB_BASE_NONE
    global X64_RIP, X64_EBP, X64_RBP, X64_RSP

    if regIndex is X64_RSP
      die('error: rsp register cannot be used as index')
    endif

    if (scale is 2) and (regBase is -1)
      # Fasm like optimization.
      # [2*rsi] -> [rsi + 1*rsi]
      regBase = regIndex
      scale   = 1
    endif

    if (regBase is X64_RSP) and (scale is -1)
      # Special case: [ rsp ]
      regIndex = X64_RSP
      scale    = 1
    endif

    if regBase is X64_RIP
      # Code independent address: [rip + disp32]
      # In this mode displacement is always 32-bit.
      # MOD = 00  = INDIRECT,
      # R/M = RBP = displacement only.
      this.emitCore(opcode, X64_MOD_INDIRECT, regSrc, X64_RM_RIP_DISP_MODE)
      this.emitDword(disp)

    elif (regBase is -1) and (scale is -1) and (regIndex is -1)
      # Absolute ds:[disp32] address.
      # In this mode displacement is always 32-bit.
      #
      # https://wiki.osdev.org/X86-64_Instruction_Encoding#32.2F64-bit_addressing_2
      # http://www.c-jump.com/CIS77/CPU/x86/lecture.html#X77_0100_sib_byte_layout
      #
      # MOD       = INDIRECT
      # SIB.scale = 1
      # SIB.index = 100 = ILLEGAL
      # SIB.base  = 101 = displacement only.
      this.emitCore(opcode, X64_MOD_INDIRECT, regSrc, X64_RM_SIB_MODE)
      this.emitByte(0x25)
      this.emitDword(disp)

    else
      # General case.
      if (regBase isnt X64_RBP) and ((disp is 0) or (regBase is -1))
        # [r], r
        # [disp], r
        mode = X64_MOD_INDIRECT

      elif (disp >= -127) and (disp <= 128)
        # [disp8], r
        # [r + disp8], r
        mode = X64_MOD_DISP8

      else
        # [disp32], r
        # [r + disp32], r
        mode = X64_MOD_DISP32
      endif

      # Enable Scaled Index Base (SIB) mode.
      if scale > 0
        # Full SIB: [base + scale * index + disp]
        rm = X64_RM_SIB_MODE
      else
        # Base and displacement: [base + disp]
        rm = regBase
      endif

      # Primary opcode and Mod-Reg-R/M byte.
      this.emitCore(opcode, mode, regSrc, rm)

      # Emit SIB byte if needed.
      if scale > 0
        if scale is 1
          # [base + index + disp]
          scaleMask = 0x00

        elif scale is 2
          # [base + 2*index + disp]
          scaleMask = 0x40

        elif scale is 4
          # [base + 4*index + disp]
          scaleMask = 0x80

        elif scale is 8
          # [base + 8*index + disp]
          scaleMask = 0xc0

        else
          # Error - unexpected scale.
          scaleMask = -1
          die('error: only 1, 2, 4 or 8 scale is available')
        endif

        if regBase is -1
          # [scale * index + disp32]
          # Displacement is always 32-bit and is emited even if zero.
          regBaseMask = X64_SIB_BASE_NONE
          mode        = X64_MOD_DISP32
        else
          # [base + scale * index + disp8/32]
          regBaseMask = bitand(regBase, 0x7)
        endif

        regIndexMask = bitand(regIndex, 0x7) * 8

        this.emitByte(scaleMask + regIndexMask + regBaseMask)
      endif

      # Emit displacement if needed.
      if mode is X64_MOD_DISP8
        # 8-bit displacemnt.
        this.emitByte(disp)

      elif mode is X64_MOD_DISP32
        # 32-bit displacement
        this.emitDword(disp)
      endif
    endif
  endmethod

  method emitCore_r_m(opcode, regDst, regBase, scale, regIndex, disp)
    # Set direction flag in primary opcode byte to swap r<->m direction.
    opcode = bitor(opcode, 2)
    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, regDst)
  endmethod

  method emitCore_r_imm(opcode, regDst, imm)
    global X64_MOD_REGISTER
    global X64_ALU_RM8_IMM8_GROUP
    global X64_ALU_RM32_IMM32_GROUP
    global X64_ALU_RM32_IMM8_GROUP
    global X64_AL

    # Sub-opcode to encode inside Reg-Mod-RM byte.
    operationId = opcode // 8

    if regDst is X64_AL
      # Special case for AL register.
      this.emitByte(opcode + 4)
      this.emitByte(imm)

    elif X64_IsReg8(regDst) is true
      # General 8-bit destination.
      this.emitByte(X64_ALU_RM8_IMM8_GROUP)
      this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
      this.emitByte(imm)

    else
      # 16-bit, 32-bit or 64-bit destination.
      # 32-bit is default (no prefix needed).
      this.emitSizePrefixIfNeeded(regDst)

      if (imm >= -127) and (imm <= 128)
        # r16, imm8
        # r32, imm8
        # r64, imm8
        this.emitByte(X64_ALU_RM32_IMM8_GROUP)
        this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
        this.emitByte(imm)

      else
        # r16, imm32
        # r32, imm32
        # r64, imm32
        if bitand(regDst, 0x7) is X64_AL
          # Special case for ax, eax, rax.
          this.emitByte(opcode + 5)

        else
          this.emitByte(X64_ALU_RM32_IMM32_GROUP)
          this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
        endif

        # Emit immediate.
        if X64_IsReg16(regDst) is true
          this.emitWord(imm)
        else
          this.emitDword(imm)
        endif
      endif
    endif
  endmethod

  method emitCore_m_imm(opcode, regBase, scale, regIndex, disp, imm, dataSize)
    global X64_ALU_RM8_IMM8_GROUP
    global X64_ADC, X64_ADD, X64_AND, X64_CMP, X64_SBB, X64_SUB, X64_OR, X64_XOR

    # TODO: Clean up this mess.
    if dataSize is 2
      this.emitPrefix16()
    elif dataSize is 8
      this.emitPrefix64()
    endif

    if ((opcode is X64_ADC) or
        (opcode is X64_ADD) or
        (opcode is X64_AND) or
        (opcode is X64_CMP) or
        (opcode is X64_SBB) or
        (opcode is X64_SUB) or
        (opcode is X64_OR) or
        (opcode is X64_XOR))

      # Sub-opcode to encode inside Reg-Mod-RM byte.
      operationId = opcode // 8
      opcode      = X64_ALU_RM8_IMM8_GROUP
    else
      operationId = 0
    endif

    if dataSize > 1
      # Non 8-bit mode.
      opcode = opcode + 1
    endif

    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, operationId)

    if dataSize is 1
      # 8-bit immediate.
      this.emitByte(imm)
    elif dataSize is 2
      # 16-bit immediate.
      this.emitWord(imm)
    else
      # 32-bit immediate.
      # There is no 64-bit immediates even if qword
      # is accessed in memory.
      this.emitDword(imm)
    endif
  endmethod

  method emitCore_group_r(opcodeBase, operationId, reg)
    global X64_MOD_REGISTER
    if X64_IsReg8(reg) is true
      # neg r8 like.
      this.emitByte(opcodeBase)
    else
      # neg r16/32/64 like.
      # 32-bit is default.
      this.emitSizePrefixIfNeeded(reg)
      this.emitByte(opcodeBase + 1)
    endif

    # Emit Mod-Reg-R/M byte.
    # Reg field stores operation id (sub-opcode).
    this.emitModRegRM(X64_MOD_REGISTER, operationId, reg)
  endmethod

  method emitCore_group_m(opcodeBase, operationId, base, scale, index, disp)
    this.emitCore_m_r(opcodeBase, base, scale, index, disp, operationId)
  endmethod

  method emitCore_unaryGroup_r(operationId, reg)
    global X64_UNARY8_GROUP
    this.emitCore_group_r(X64_UNARY8_GROUP, operationId, reg)
  endmethod

  method emitCore_unaryGroup_m(operationId, base, scale, index, disp, dataSize)
    global X64_UNARY8_GROUP
    if dataSize is 2
      # access word (2-bytes)
      operationId = operationId + 16

    elif dataSize is 4
      # access word (2-bytes)
      operationId = operationId + 32

    elif dataSize is 8
      # access qword (8-bytes)
      operationId = operationId + 48
    endif

    this.emitCore_group_m(X64_UNARY8_GROUP, operationId, base, scale, index, disp)
  endmethod

  # ----------------------------------------------------------------------------
  #                       Public API: 64 instruction set
  # ----------------------------------------------------------------------------

  #
  # Core ALU: add, or, adc, sbb, and, sub, xor, cmp, neg, not
  #

  # alu r, r
  method add_r_r(regDst, regSrc)
    global X64_ADD
    this.emitCore_r_r(X64_ADD, regDst, regSrc)
  endmethod

  method or_r_r(regDst, regSrc)
    global X64_OR
    this.emitCore_r_r(X64_OR, regDst, regSrc)
  endmethod

  method adc_r_r(regDst, regSrc)
    global X64_ADC
    this.emitCore_r_r(X64_ADC, regDst, regSrc)
  endmethod

  method sbb_r_r(regDst, regSrc)
    global X64_SBB
    this.emitCore_r_r(X64_SBB, regDst, regSrc)
  endmethod

  method and_r_r(regDst, regSrc)
    global X64_AND
    this.emitCore_r_r(X64_AND, regDst, regSrc)
  endmethod

  method sub_r_r(regDst, regSrc)
    global X64_SUB
    this.emitCore_r_r(X64_SUB, regDst, regSrc)
  endmethod

  method xor_r_r(regDst, regSrc)
    global X64_XOR
    this.emitCore_r_r(X64_XOR, regDst, regSrc)
  endmethod

  method cmp_r_r(regDst, regSrc)
    global X64_CMP
    this.emitCore_r_r(X64_CMP, regDst, regSrc)
  endmethod

  # alu r, imm
  method add_r_imm(regDst, imm)
    global X64_ADD
    this.emitCore_r_imm(X64_ADD, regDst, imm)
  endmethod

  method or_r_imm(regDst, imm)
    global X64_OR
    this.emitCore_r_imm(X64_OR, regDst, imm)
  endmethod

  method adc_r_imm(regDst, imm)
    global X64_ADC
    this.emitCore_r_imm(X64_ADC, regDst, imm)
  endmethod

  method sbb_r_imm(regDst, imm)
    global X64_SBB
    this.emitCore_r_imm(X64_SBB, regDst, imm)
  endmethod

  method and_r_imm(regDst, imm)
    global X64_AND
    this.emitCore_r_imm(X64_AND, regDst, imm)
  endmethod

  method sub_r_imm(regDst, imm)
    global X64_SUB
    this.emitCore_r_imm(X64_SUB, regDst, imm)
  endmethod

  method xor_r_imm(regDst, imm)
    global X64_XOR
    this.emitCore_r_imm(X64_XOR, regDst, imm)
  endmethod

  method cmp_r_imm(regDst, imm)
    global X64_CMP
    this.emitCore_r_imm(X64_CMP, regDst, imm)
  endmethod

  # alu r, m
  method add_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_ADD
    this.emitCore_r_m(X64_ADD, regDst, regBase, scale, regIndex, disp)
  endmethod

  method or_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_OR
    this.emitCore_r_m(X64_OR, regDst, regBase, scale, regIndex, disp)
  endmethod

  method adc_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_ADC
    this.emitCore_r_m(X64_ADC, regDst, regBase, scale, regIndex, disp)
  endmethod

  method sbb_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_SBB
    this.emitCore_r_m(X64_SBB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method and_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_AND
    this.emitCore_r_m(X64_AND, regDst, regBase, scale, regIndex, disp)
  endmethod

  method sub_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_SUB
    this.emitCore_r_m(X64_SUB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method xor_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_XOR
    this.emitCore_r_m(X64_XOR, regBase, scale, regIndex, disp)
  endmethod

  method cmp_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMP
    this.emitCore_r_m(X64_CMP, regBase, scale, regIndex, disp)
  endmethod

  # alu m, r
  method add_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_ADD
    this.emitCore_r_m(X64_ADD, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method or_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_OR
    this.emitCore_r_m(X64_OR, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method adc_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_ADC
    this.emitCore_r_m(X64_ADC, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method sbb_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_SBB
    this.emitCore_r_m(X64_SBB, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method and_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_AND
    this.emitCore_r_m(X64_AND, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method sub_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_SUB
    this.emitCore_r_m(X64_SUB, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method xor_m_r(regDst, regBase, scale, regIndex, disp)
    global X64_XOR
    this.emitCore_r_m(X64_XOR, regBase, scale, regIndex, disp)
  endmethod

  method cmp_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_CMP
    this.emitCore_r_m(X64_CMP, regBase, scale, regIndex, disp, regSrc)
  endmethod

  #
  # Core ALU: inc, dec
  #

  method inc_r(reg)
    global X64_INC_DEC_RM8_GROUP
    this.emitCore_group_r(X64_INC_DEC_RM8_GROUP, 0, reg)
  endmethod

  method inc_m(regBase, scale, regIndex, disp)
    die('not implemented: inc m')
  endmethod

  method dec_r(reg)
    global X64_INC_DEC_RM8_GROUP
    this.emitCore_group_r(X64_INC_DEC_RM8_GROUP, 1, reg)
  endmethod

  method dec_m(regBase, scale, regIndex, disp)
    die('not implemented: dec m')
  endmethod

  #
  # Bit test: test
  #

  method test_r_r(reg1, reg2)
    global X64_TEST_RM8_R8
    this.emitCore_r_r(X64_TEST_RM8_R8, reg1, reg2)
  endmethod

  method test_m_r(regBase, scale, regIndex, disp, reg2)
    global X64_TEST_RM8_R8
    this.emitCore_m_r(X64_TEST_RM8_R8, regBase, scale, regIndex, disp, reg2)
  endmethod

  method test_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_unaryGroup_m(0, regBase, scale, regIndex, disp, dataSize)

    # TODO: Clean up this mess.
    if dataSize is 1
      # 8-bit immediate.
      this.emitByte(imm)
    elif dataSize is 2
      # 16-bit immediate.
      this.emitWord(imm)
    else
      # 32-bit immediate.
      # There is no 64-bit immediates even if qword
      # is accessed in memory.
      this.emitDword(imm)
    endif
  endmethod

  method test_r_imm(reg, imm)
    global X64_TEST_AL_IMM8
    global X64_TEST_EAX_IMM32
    global X64_AL, X64_AX
    global X64_MOD_REGISTER

    if bitand(reg, 0xf) is X64_AL
      # Special case:
      # - test al, imm8
      # - test ax, imm16  (16-bit prefix)
      # - test eax, imm32 (default)
      # - test rax, imm32 (REX.w prefix)
      if reg is X64_AL
        # test al, imm8
        this.emitByte(X64_TEST_AL_IMM8)

      else
        # Test ax, eax or rax register.
        this.emitSizePrefixIfNeeded(reg)
        this.emitByte(X64_TEST_EAX_IMM32)
      endif

    else
      # General case:
      # - test r8, imm8
      # - test r16, imm16 (16-bit prefix)
      # - test r32, imm32 (default)
      # - test r64, imm32 (REX.w prefix)
      this.emitCore_unaryGroup_r(0, reg)
    endif

    # Emit immediate.
    if X64_IsReg8(reg) is true
      # Test 8-bit register.
      this.emitByte(imm)

    elif X64_IsReg16(reg) is true
      # Test 16-bit register.
      this.emitWord(imm)

    else
      # Test 32 or 64-bit register.
      # Immediate is always 32-bit.
      this.emitDword(imm)
    endif
  endmethod

  #
  # Integer multiplication and division: mul, imul, div, idiv
  #

  # opcode r
  method not_r(reg)
    this.emitCore_unaryGroup_r(2, reg)
  endmethod

  method neg_r(reg)
    this.emitCore_unaryGroup_r(3, reg)
  endmethod

  method mul_r(reg)
    this.emitCore_unaryGroup_r(4, reg)
  endmethod

  method imul_r(reg)
    this.emitCore_unaryGroup_r(5, reg)
  endmethod

  method div_r(reg)
    this.emitCore_unaryGroup_r(6, reg)
  endmethod

  method idiv_r(reg)
    this.emitCore_unaryGroup_r(7, reg)
  endmethod

  # opcode m
  method not_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(2, base, scale, index, disp)
  endmethod

  method neg_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(3, base, scale, index, disp)
  endmethod

  method mul_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(4, base, scale, index, disp)
  endmethod

  method imul_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(5, base, scale, index, disp)
  endmethod

  method div_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(6, base, scale, index, disp)
  endmethod

  method idiv_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(7, base, scale, index, disp)
  endmethod

  #
  # Stack: push, pusha, pushad, pushf, pop, popa, popad, popf
  #

  method emitCore_pushPop_r(opcode, reg)
    if X64_IsReg16(reg)
      # push r16
      this.emitPrefix16()

    elif X64_IsReg64(reg)
      # push r64
      # Default scenario - nothing to do.

    else
      die('error: push/pop r8/32 are unavailable in 64-bit mode')
    endif

    this.emitByte(opcode + bitand(reg, 0x7))
  endmethod

  method push_r(reg)
    global X64_PUSH_R64
    this.emitCore_pushPop_r(X64_PUSH_R64, reg)
  endmethod

  method pop_r(reg)
    global X64_POP_R64
    this.emitCore_pushPop_r(X64_POP_R64, reg)
  endmethod

  method push_imm8(imm)
    global X64_PUSH_IMM8
    this.emitByte(X64_PUSH_IMM8)
    this.emitByte(imm)
  endmethod

  method push_imm32(imm)
    global X64_PUSH_IMM32
    this.emitByte(X64_PUSH_IMM32)
    this.emitDword(imm)
  endmethod

  method pushf()
    die('not implemented: pushf')
  endmethod

  method popf()
    die('not implemented: popf')
  endmethod

  #
  # Ports: in, out,
  #        insb, insw, insd, insq,
  #        outsb, outsw, outsd, outsq.
  #

  method emitCore_inOut(opcode, regData, portNumber)
    global X64_AL, X64_AX, X64_EAX
    global X64_DX

    if regData is X64_AL
      this.emitByte(opcode)

    elif regData is X64_AX
      this.emitPrefix16()
      this.emitByte(opcode + 1)

    elif regData is X64_EAX
      this.emitByte(opcode + 1)

    else
      die('error: only al, ax or eax can be used with in/out opcodes')
    endif

    if portNumber >= 0
      # Emit port number as 8-bit immediate.
      this.emitByte(portNumber)

    elif portNumber isnt -X64_DX
      die('error: port must be imm8 or dx register for in/out opcodes')
    endif
  endmethod

  method in_r_imm(regDst, imm)
    global X64_IN_AL_IMM8
    this.emitCore_inOut(X64_IN_AL_IMM8, regDst, imm)
  endmethod

  method out_imm_r(imm, regSrc)
    global X64_OUT_IMM8_AL
    this.emitCore_inOut(X64_OUT_IMM8_AL, regSrc, imm)
  endmethod

  method in_r_r(regDst, regDX)
    global X64_IN_AL_DX
    this.emitCore_inOut(X64_IN_AL_DX, regDst, -regDX)
  endmethod

  method out_r_r(regDX, regSrc)
    global X64_OUT_DX_AL
    this.emitCore_inOut(X64_OUT_DX_AL, regSrc, -regDX)
  endmethod

  method insb()
    global X64_INSB
    this.emitByte(X64_INSB)
  endmethod

  method insw()
    this.emitPrefix16()
    this.insd()
  endmethod

  method outsb()
    global X64_OUTSB
    this.emitByte(X64_OUTSB)
  endmethod

  method outsw()
    this.emitPrefix16()
    this.outsd()
  endmethod

  # Strings: movsb, movsw, movsd, movsq,
  #          cmpsb, cmpsw, cmpsd, cmpsq,
  #          stosb, stosw, stosd, stosq,
  #          lodsb, lodsw, lodsd, lodsq,
  #          scasb, scasw, scasd, scasq,
  #          repne, repe.

  method movsb()
    global X64_MOVSB
    this.emitByte(X64_MOVSB)
  endmethod

  method movsw()
    this.emitPrefix16()
    this.movsd()
  endmethod

  method movsq()
    this.emitPrefix64()
    this.movsd()
  endmethod

  method cmpsb()
    global X64_CMPSB
    this.emitByte(X64_CMPSB)
  endmethod

  method cmpsw()
    this.emitPrefix16()
    this.cmpsd()
  endmethod

  method stosb()
    global X64_STOSB
    this.emitByte(X64_STOSB)
  endmethod

  method stosw()
    this.emitPrefix16()
    this.stosd()
  endmethod

  method lodsb()
    global X64_LODSB
    this.emitByte(X64_LODSB)
  endmethod

  method lodsw()
    this.emitPrefix16()
    this.lodsd()
  endmethod

  method scasb()
    global X64_SCASB
    this.emitByte(X64_SCASB)
  endmethod

  method scasw()
    this.emitPrefix16()
    this.scasd()
  endmethod

  method repne()
    global X64_PREFIX_REPNE
    this.emitByte(X64_PREFIX_REPNE)
  endmethod

  method repe()
    global X64_PREFIX_REPE
    this.emitByte(X64_PREFIX_REPE)
  endmethod

  #
  # Unconditional jumps.
  #

  method emitCore_jmp_rel8(opcode, rel)
    this.emitByte(opcode)
    this.emitByte(rel)
  endmethod

  method emitCore_jmp_rel32(opcode, rel)
    this.emitByte(opcode)
    this.emitDword(rel)
  endmethod

  method emitCore_jxx_rel(opcode, rel)
    # TODO: Review it.
    if (rel >= -126) and (rel <= 128)
      # jxx rel8
      this.emitByte(opcode)
      this.emitByte(rel - 2)

    else
      # jxx rel32
      # 0f 8x = two bytes jxx jump
      # TODO: Avoid hardcoded opcode.
      this.emitByte(0x0f)
      this.emitByte(opcode + 0x10)
      this.emitDword(rel - 6)
    endif
  endmethod

  method jmp_rel(rel)
    global X64_JMP_REL8
    global X64_JMP_REL32

    # TODO: Review it.
    if (rel >= -126) and (rel <= 128 + 5)
      # jmp rel8
      this.emitCore_jmp_rel8(X64_JMP_REL8, rel - 2)
    else
      # jmp rel32
      this.emitCore_jmp_rel32(X64_JMP_REL32, rel - 5)
    endif
  endmethod

  #
  # Conditional jumps: jxx, loopnz, loopz, loop, jrcxz, jecxz
  #

  method jo_rel(rel)
    global X64_JO
    this.emitCore_jxx_rel(X64_JO, rel)
  endmethod

  method jno_rel(rel)
    global X64_JNO
    this.emitCore_jxx_rel(X64_JNO, rel)
  endmethod

  method jb_rel(rel)
    global X64_JB
    this.emitCore_jxx_rel(X64_JB, rel)
  endmethod

  method jae_rel(rel)
    global X64_JAE
    this.emitCore_jxx_rel(X64_JAE, rel)
  endmethod

  method jz_rel(rel)
    global X64_JZ
    this.emitCore_jxx_rel(X64_JZ, rel)
  endmethod

  method jnz_rel(rel)
    global X64_JNZ
    this.emitCore_jxx_rel(X64_JNZ, rel)
  endmethod

  method jbe_rel(rel)
    global X64_JBE
    this.emitCore_jxx_rel(X64_JBE, rel)
  endmethod

  method ja_rel(rel)
    global X64_JA
    this.emitCore_jxx_rel(X64_JA, rel)
  endmethod

  method js_rel(rel)
    global X64_JS
    this.emitCore_jxx_rel(X64_JS, rel)
  endmethod

  method jns_rel(rel)
    global X64_JNS
    this.emitCore_jxx_rel(X64_JNS, rel)
  endmethod

  method jp_rel(rel)
    global X64_JP
    this.emitCore_jxx_rel(X64_JP, rel)
  endmethod

  method jnp_rel(rel)
    global X64_JNP
    this.emitCore_jxx_rel(X64_JNP, rel)
  endmethod

  method jl_rel(rel)
    global X64_JL
    this.emitCore_jxx_rel(X64_JL, rel)
  endmethod

  method jge_rel(rel)
    global X64_JGE
    this.emitCore_jxx_rel(X64_JGE, rel)
  endmethod

  method jle_rel(rel)
    global X64_JLE
    this.emitCore_jxx_rel(X64_JLE, rel)
  endmethod

  method jg_rel(rel)
    global X64_JG
    this.emitCore_jxx_rel(X64_JG, rel)
  endmethod

  method loopz_rel(rel)
    global X64_LOOPZ_REL8
    this.emitCore_jmp_rel8(X64_LOOPZ_REL8, rel - 2)
  endmethod

  method loopnz_rel(rel)
    global X64_LOOPNZ_REL8
    this.emitCore_jmp_rel8(X64_LOOPNZ_REL8, rel - 2)
  endmethod

  method loop_rel(rel)
    global X64_LOOP_REL8
    this.emitCore_jmp_rel8(X64_LOOP_REL8, rel - 2)
  endmethod

  method jecxz_rel(rel)
    global X64_JRCXZ_REL8
    this.emitByte(0x67)
    this.emitCore_jmp_rel8(X64_JRCXZ_REL8, rel - 3)
  endmethod

  method jrcxz_rel(rel)
    global X64_JRCXZ_REL8
    this.emitCore_jmp_rel8(X64_JRCXZ_REL8, rel - 2)
  endmethod

  #
  # Procedures: call, ret
  #

  method call_rel(rel)
    global X64_CALL_REL32
    this.emitCore_jmp_rel32(X64_CALL_REL32, rel - 5)
  endmethod

  method call_r(reg)
    die('not implemented: call r')
  endmethod

  method call_m(regBase, scale, regIndex, disp)
    global X64_CALL_GROUP
    this.emitCore_group_m(X64_CALL_GROUP, 2, regBase, scale, regIndex, disp)
  endmethod

  method ret()
    global X64_RET
    this.emitByte(X64_RET)
  endmethod

  method ret_imm(imm)
    global X64_RET_IMM16
    this.emitByte(X64_RET_IMM16)
    this.emitWord(imm)
  endmethod

  #
  # Data move: mov, xchg
  #

  method mov_r_r(regDst, regSrc)
    global X64_MOV_RM8_R8
    this.emitCore_r_r(X64_MOV_RM8_R8, regDst, regSrc)
  endmethod

  method mov_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_MOV_RM8_R8
    this.emitCore_r_m(X64_MOV_RM8_R8, regDst, regBase, scale, regIndex, disp)
  endmethod

  method mov_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_MOV_RM8_R8
    this.emitCore_m_r(X64_MOV_RM8_R8, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method mov_r_imm(regDst, imm)
    global X64_MOV_R8_IMM8
    global X64_MOV_R32_IMM32
    global X64_MOV_RM32_IMM32
    global X64_MOD_REGISTER

    regDstId = bitand(regDst, 0x7)

    if X64_IsReg8(regDst) is true
      # mov r8, imm8
      this.emitByte(X64_MOV_R8_IMM8 + regDstId)
      this.emitByte(imm)

    else
      # Move 16, 32 or 64 bits.
      # 32-bit is default (no prefix needed).
      if X64_IsReg16(regDst) is true
        # mov r16, imm16
        this.emitPrefix16()
        this.emitByte(X64_MOV_R32_IMM32 + regDstId)
        this.emitWord(imm)

      elif X64_IsReg32(regDst) is true
        # mov r32, imm32
        this.emitByte(X64_MOV_R32_IMM32 + regDstId)
        this.emitDword(imm)

      else
        # mov r64, imm32
        this.emitPrefix64()
        this.emitCore(X64_MOV_RM32_IMM32, X64_MOD_REGISTER, 0, regDst)
        this.emitDword(imm)
      endif
    endif
  endmethod

  method mov_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    global X64_MOV_RM8_IMM8
    this.emitCore_m_imm(X64_MOV_RM8_IMM8, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method xchg_r_r(reg1, reg2)
    global X64_XCHG_RM8_R8, X64_XCHG_EAX_R32, X64_NOP
    global X64_AL, X64_EAX, X64_RAX

    if X64_IsReg8(reg1) is true
      # xchg r8, r8
      this.emitCore_r_r(X64_XCHG_RM8_R8, reg2, reg1)

    elif (reg1 is X64_EAX) and (reg2 is X64_EAX)
      # Avoid emitting optimized one byte version for
      # xchg eax, eax
      # to distinguish from explicit nop opcode.
      this.emitWord(0xc087)

    else
      regMask1 = bitand(reg1, 0x7)
      regMask2 = bitand(reg2, 0x7)

      if regMask1 is X64_AL
        # Use optimized one-byte version if first operand is rax.
        # xchg ax/eax/rax, r
        this.emitSizePrefixIfNeeded(reg1)
        this.emitByte(X64_XCHG_EAX_R32 + regMask2)

      elif regMask2 is X64_AL
        # xchg r, ax/eax/rax
        # Swap arguments and use optimized rax version.
        this.emitSizePrefixIfNeeded(reg1)
        this.emitByte(X64_XCHG_EAX_R32 + regMask1)

      else
        # General case: xchg r, r
        this.emitCore_r_r(X64_XCHG_RM8_R8, reg2, reg1)
      endif
    endif
  endmethod

  # Conversion: cbw, cwd
  method cbw()
    this.emitPrefix16()
    this.cwde()
  endmethod

  method cwd()
    this.emitPrefix16()
    this.cdqe()
  endmethod

  #
  # Interrupts: int, into, int1, int3, iret
  #

  method int(imm8)
    global X64_INT_IMM8
    global X64_INTO, X64_INT1, X64_INT3

    if imm8 is 0
      this.emitByte(X64_INTO)

    elif imm8 is 1
      this.emitByte(X64_INT1)

    elif imm8 is 3
      this.emitByte(X64_INT3)

    else
      this.emitByte(X64_INT_IMM8)
      this.emitByte(imm8)
    endif
  endmethod

  method iret()
    global X64_IRET
    this.emitByte(X64_IRET)
  endmethod

  #
  # Flags: clc, stc, cli, sti, cld, std
  #

  method clc()
    global X64_CLC
    this.emitByte(X64_CLC)
  endmethod

  method stc()
    global X64_STC
    this.emitByte(X64_STC)
  endmethod

  method cli()
    global X64_CLI
    this.emitByte(X64_CLI)
  endmethod

  method sti()
    global X64_STI
    this.emitByte(X64_STI)
  endmethod

  method cld()
    global X64_CLD
    this.emitByte(X64_CLD)
  endmethod

  method std()
    global X64_STD
    this.emitByte(X64_STD)
  endmethod

  #
  # Core other: lea, nop, xlatb, hlt, cmc
  #

  method lea_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LEA_R32_M64
    this.emitCore_m_r(X64_LEA_R32_M64, regBase, scale, regIndex, disp, regDst)
  endmethod

  #
  #  lock
  #

  method lock()
    global X64_PREFIX_LOCK
    this.emitByte(X64_PREFIX_LOCK)
  endmethod

  method connectTo(outputObject) -> rv
    this.outputObject = outputObject
    rv = outputObject
  endmethod

  # aaa     invalid in 64-bit mode
  # aad     invalid in 64-bit mode
  # aam     invalid in 64-bit mode
  # lahf    invalid in 64-bit mode
  # aas     invalid in 64-bit mode
  # das     invalid in 64-bit mode
  # sahf    invalid in 64-bit mode
  # lds     invalid in 64-bit mode
  # les     invalid in 64-bit mode
  # daa     invalid in 64-bit mode
  # into    invalid in 64-bit mode

  #
  # Bit shifts and rotations: rol, ror, rcl, rcr, shl, rhr, sar
  #

  method rcl_r_cl(regDst)
    die('not implemented: rcl r,cl')
  endmethod

  method rcl_r_imm(regDst, imm)
    die('not implemented: rcl r,imm')
  endmethod

  method rcl_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: rcl m,cl')
  endmethod

  method rcl_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: rcl m,imm')
  endmethod

  method rcr_r_cl(regDst)
    die('not implemented: rcr r,cl')
  endmethod

  method rcr_r_imm(regDst, imm)
    die('not implemented: rcr r,imm')
  endmethod

  method rcr_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: rcr m,cl')
  endmethod

  method rcr_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: rcr m,imm')
  endmethod

  method rol_r_cl(regDst)
    die('not implemented: rol r,cl')
  endmethod

  method rol_r_imm(regDst, imm)
    die('not implemented: rol r,imm')
  endmethod

  method rol_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: rol m,cl')
  endmethod

  method rol_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: rol m,imm')
  endmethod

  method ror_r_cl(regDst)
    die('not implemented: ror r,cl')
  endmethod

  method ror_r_imm(regDst, imm)
    die('not implemented: ror r,imm')
  endmethod

  method ror_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: ror m,cl')
  endmethod

  method ror_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: ror m,imm')
  endmethod

  method sal_r_cl(regDst)
    die('not implemented: sal r,cl')
  endmethod

  method sal_r_imm(regDst, imm)
    die('not implemented: sal r,imm')
  endmethod

  method sal_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: sal m,cl')
  endmethod

  method sal_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: sal m,imm')
  endmethod

  method sar_r_cl(regDst)
    die('not implemented: sar r,cl')
  endmethod

  method sar_r_imm(regDst, imm)
    die('not implemented: sar r,imm')
  endmethod

  method sar_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: sar m,cl')
  endmethod

  method sar_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: sar m,imm')
  endmethod

  method shl_r_cl(regDst)
    die('not implemented: shl r,cl')
  endmethod

  method shl_r_imm(regDst, imm)
    die('not implemented: shl r,imm')
  endmethod

  method shl_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: shl m,cl')
  endmethod

  method shl_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: shl m,imm')
  endmethod

  method shr_r_cl(regDst)
    die('not implemented: shr r,cl')
  endmethod

  method shr_r_imm(regDst, imm)
    die('not implemented: shr r,imm')
  endmethod

  method shr_m_cl(regBase, scale, regIndex, disp)
    die('not implemented: shr m,cl')
  endmethod

  method shr_m_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: shr m,imm')
  endmethod

  #
  # No operation (nop).
  #

  method nop()
    die('not implemented: nop')
  endmethod

  method nop_r(regDst)
    die('not implemented: nop r')
  endmethod

  method nop_m(regBase, scale, regIndex, disp)
    die('not implemented: nop m')
  endmethod

  method cmc()
    die('not implemented: cmc')
  endmethod

  method hlt()
    die('not implemented: hlt')
  endmethod

  method wait()
    die('not implemented: wait')
  endmethod

  method xlatb()
    die('not implemented: xlatb')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80186 processor.
  #
  # Skipped mnemonics:
  #   bound    - invalid in 64-bit mode
  #   popa     - invalid in 64-bit mode
  #   pusha    - invalid in 64-bit mode
  #   push imm - already handled
  #   imul imm - already handled
  #   shl  imm - already handled
  #   shr  imm - already handled
  #   sal  imm - already handled
  #   sar  imm - already handled
  #   rol  imm - already handled
  #   ror  imm - already handled
  #   rcl  imm - already handled
  #   rcr  imm - already handled
  #-----------------------------------------------------------------------------

  # Only [edi/rdi] or [esi/rsi] addresses are available.
  # TODO:
  # ins  m8,dx | m32,dx | m32,dx
  # outs dx,m8 | dx,m16 | dx,m32

  method enter_imm16_imm8(disp, level)
    global X64_ENTER_IMM16_IMM8
    this.emitByte(X64_ENTER_IMM16_IMM8)
    this.emitWord(disp)
    this.emitByte(level)
  endmethod

  method leave()
    global X64_LEAVE
    this.emitByte(X64_LEAVE)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80286 processor.
  #
  # Skipped mnemonics:
  #   arpl    - invalid in 64-bit mode
  #   loadall - 80286 only
  #-----------------------------------------------------------------------------

  method sldt_r(regDst)
    die('not implemented: sldt r')
  endmethod

  method sldt_m(regBase, scale, regIndex, disp)
    die('not implemented: sldt m')
  endmethod

  method lar_r_r(regDst, regSrc)
    die('not implemented: lar r,r')
  endmethod

  method lar_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: lar r,m')
  endmethod

  method lsl_r_r(regDst, regSrc)
    die('not implemented: lsl r,r')
  endmethod

  method lsl_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: lsl r,m')
  endmethod

  method smsw_r(regDst)
    die('not implemented: smsw r')
  endmethod

  method smsw_m(regBase, scale, regIndex, disp)
    die('not implemented: smsw m')
  endmethod

  method str_r(regDst)
    die('not implemented: str r')
  endmethod

  method str_m(regBase, scale, regIndex, disp)
    die('not implemented: str m')
  endmethod

  method lldt_r(regDst)
    die('not implemented: lldt r')
  endmethod

  method lldt_m(regBase, scale, regIndex, disp)
    die('not implemented: lldt m')
  endmethod

  method lmsw_r(regDst)
    die('not implemented: lmsw r')
  endmethod

  method lmsw_m(regBase, scale, regIndex, disp)
    die('not implemented: lmsw m')
  endmethod

  method ltr_r(regDst)
    die('not implemented: ltr r')
  endmethod

  method ltr_m(regBase, scale, regIndex, disp)
    die('not implemented: ltr m')
  endmethod

  method verr_r(regDst)
    die('not implemented: verr r')
  endmethod

  method verr_m(regBase, scale, regIndex, disp)
    die('not implemented: verr m')
  endmethod

  method verw_r(regDst)
    die('not implemented: verw r')
  endmethod

  method verw_m(regBase, scale, regIndex, disp)
    die('not implemented: verw m')
  endmethod

  method lgdt_m(regBase, scale, regIndex, disp)
    die('not implemented: lgdt m')
  endmethod

  method lidt_m(regBase, scale, regIndex, disp)
    die('not implemented: lidt m')
  endmethod

  method sgdt_m(regBase, scale, regIndex, disp)
    die('not implemented: sgdt m')
  endmethod

  method sidt_m(regBase, scale, regIndex, disp)
    die('not implemented: sidt m')
  endmethod

  method clts()
    die('not implemented: clts')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80386 processor.
  #
  # Skipped mnemonics:
  #   pushad   - invalid in 64-bit mode
  #   popad    - invalid in 64-bit mode
  #   pushfd   - invalid in 64-bit mode
  #   popfd    - invalid in 64-bit mode
  #   loadalld - 80386 only
  #   ibts     - 80386 before B1 step only
  #   xbts     - 80386 before B1 step only
  #-----------------------------------------------------------------------------

  # TODO: mov to/from CR/DR/TR (already handled)

  method bsf_r_r(regDst, regSrc)
    die('not implemented: bsf r,r')
  endmethod

  method bsf_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: bsf r,m')
  endmethod

  method bsr_r_r(regDst, regSrc)
    die('not implemented: bsr r,r')
  endmethod

  method bsr_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: bsr r,m')
  endmethod

  method bt_r_r(regDst, regSrc)
    die('not implemented: bt r,r')
  endmethod

  method bt_m_r(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: bt m,r')
  endmethod

  method btc_r_r(regDst, regSrc)
    die('not implemented: btc r,r')
  endmethod

  method btc_m_r(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: btc m,r')
  endmethod

  method btr_r_r(regDst, regSrc)
    die('not implemented: btr r,r')
  endmethod

  method btr_m_r(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: btr m,r')
  endmethod

  method bts_r_r(regDst, regSrc)
    die('not implemented: bts r,r')
  endmethod

  method bts_m_r(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: bts m,r')
  endmethod

  method lfs_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: lfs r,m')
  endmethod

  method lgs_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: lgs r,m')
  endmethod

  method lss_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: lss r,m')
  endmethod

  method movsxd_r64_r32(regDst, regSrc)
    global X64_MOVSXD_R32_RM32
    this.emitCore_r_r(X64_MOVSXD_R32_RM32, regSrc, regDst)
  endmethod

  method movsxd_r64_m32(regDst, regBase, scale, regIndex, disp)
    global X64_MOVSXD_R32_RM32
    this.emitCore_r_m(X64_MOVSXD_R32_RM32, regDst, regBase, scale, regIndex, disp)
  endmethod

  method movzx_r_r(regDst, regSrc)
    die('not implemented: movzx r,r')
  endmethod

  method movzx_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: movzx r,m')
  endmethod

  method shld_r_r_cl(regDst, regSrc)
    die('not implemented: shld r,r,cl')
  endmethod

  method shld_r_r_imm(regDst, regSrc, imm)
    die('not implemented: shld r,r,imm')
  endmethod

  method shld_r_r_cl(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: shld m,r,cl')
  endmethod

  method shld_m_r_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: shld m,r,imm')
  endmethod

  method shrd_r_r_cl(regDst, regSrc)
    die('not implemented: shrd r,r,cl')
  endmethod

  method shrd_r_r_imm(regDst, regSrc, imm)
    die('not implemented: shrd r,r,imm')
  endmethod

  method shrd_r_r_cl(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: shrd m,r,cl')
  endmethod

  method shrd_m_r_imm(regBase, scale, regIndex, disp, imm)
    die('not implemented: shrd m,r,imm')
  endmethod

  method seta_r(regDst)
    die('not implemented: seta r')
  endmethod

  method seta_m(regBase, scale, regIndex, disp)
    die('not implemented: seta m')
  endmethod

  method setae_r(regDst)
    die('not implemented: setae r')
  endmethod

  method setae_m(regBase, scale, regIndex, disp)
    die('not implemented: setae m')
  endmethod

  method setb_r(regDst)
    die('not implemented: setb r')
  endmethod

  method setb_m(regBase, scale, regIndex, disp)
    die('not implemented: setb m')
  endmethod

  method setbe_r(regDst)
    die('not implemented: setbe r')
  endmethod

  method setbe_m(regBase, scale, regIndex, disp)
    die('not implemented: setbe m')
  endmethod

  method setc_r(regDst)
    die('not implemented: setc r')
  endmethod

  method setc_m(regBase, scale, regIndex, disp)
    die('not implemented: setc m')
  endmethod

  method sete_r(regDst)
    die('not implemented: sete r')
  endmethod

  method sete_m(regBase, scale, regIndex, disp)
    die('not implemented: sete m')
  endmethod

  method setg_r(regDst)
    die('not implemented: setg r')
  endmethod

  method setg_m(regBase, scale, regIndex, disp)
    die('not implemented: setg m')
  endmethod

  method setge_r(regDst)
    die('not implemented: setge r')
  endmethod

  method setge_m(regBase, scale, regIndex, disp)
    die('not implemented: setge m')
  endmethod

  method setl_r(regDst)
    die('not implemented: setl r')
  endmethod

  method setl_m(regBase, scale, regIndex, disp)
    die('not implemented: setl m')
  endmethod

  method setle_r(regDst)
    die('not implemented: setle r')
  endmethod

  method setle_m(regBase, scale, regIndex, disp)
    die('not implemented: setle m')
  endmethod

  method setna_r(regDst)
    die('not implemented: setna r')
  endmethod

  method setna_m(regBase, scale, regIndex, disp)
    die('not implemented: setna m')
  endmethod

  method setnae_r(regDst)
    die('not implemented: setnae r')
  endmethod

  method setnae_m(regBase, scale, regIndex, disp)
    die('not implemented: setnae m')
  endmethod

  method setnb_r(regDst)
    die('not implemented: setnb r')
  endmethod

  method setnb_m(regBase, scale, regIndex, disp)
    die('not implemented: setnb m')
  endmethod

  method setnbe_r(regDst)
    die('not implemented: setnbe r')
  endmethod

  method setnbe_m(regBase, scale, regIndex, disp)
    die('not implemented: setnbe m')
  endmethod

  method setnc_r(regDst)
    die('not implemented: setnc r')
  endmethod

  method setnc_m(regBase, scale, regIndex, disp)
    die('not implemented: setnc m')
  endmethod

  method setne_r(regDst)
    die('not implemented: setne r')
  endmethod

  method setne_m(regBase, scale, regIndex, disp)
    die('not implemented: setne m')
  endmethod

  method setng_r(regDst)
    die('not implemented: setng r')
  endmethod

  method setng_m(regBase, scale, regIndex, disp)
    die('not implemented: setng m')
  endmethod

  method setnge_r(regDst)
    die('not implemented: setnge r')
  endmethod

  method setnge_m(regBase, scale, regIndex, disp)
    die('not implemented: setnge m')
  endmethod

  method setnl_r(regDst)
    die('not implemented: setnl r')
  endmethod

  method setnl_m(regBase, scale, regIndex, disp)
    die('not implemented: setnl m')
  endmethod

  method setnle_r(regDst)
    die('not implemented: setnle r')
  endmethod

  method setnle_m(regBase, scale, regIndex, disp)
    die('not implemented: setnle m')
  endmethod

  method setno_r(regDst)
    die('not implemented: setno r')
  endmethod

  method setno_m(regBase, scale, regIndex, disp)
    die('not implemented: setno m')
  endmethod

  method setnp_r(regDst)
    die('not implemented: setnp r')
  endmethod

  method setnp_m(regBase, scale, regIndex, disp)
    die('not implemented: setnp m')
  endmethod

  method setns_r(regDst)
    die('not implemented: setns r')
  endmethod

  method setns_m(regBase, scale, regIndex, disp)
    die('not implemented: setns m')
  endmethod

  method setnz_r(regDst)
    die('not implemented: setnz r')
  endmethod

  method setnz_m(regBase, scale, regIndex, disp)
    die('not implemented: setnz m')
  endmethod

  method seto_r(regDst)
    die('not implemented: seto r')
  endmethod

  method seto_m(regBase, scale, regIndex, disp)
    die('not implemented: seto m')
  endmethod

  method setp_r(regDst)
    die('not implemented: setp r')
  endmethod

  method setp_m(regBase, scale, regIndex, disp)
    die('not implemented: setp m')
  endmethod

  method setpe_r(regDst)
    die('not implemented: setpe r')
  endmethod

  method setpe_m(regBase, scale, regIndex, disp)
    die('not implemented: setpe m')
  endmethod

  method setpo_r(regDst)
    die('not implemented: setpo r')
  endmethod

  method setpo_m(regBase, scale, regIndex, disp)
    die('not implemented: setpo m')
  endmethod

  method sets_r(regDst)
    die('not implemented: sets r')
  endmethod

  method sets_m(regBase, scale, regIndex, disp)
    die('not implemented: sets m')
  endmethod

  method setz_r(regDst)
    die('not implemented: setz r')
  endmethod

  method setz_m(regBase, scale, regIndex, disp)
    die('not implemented: setz m')
  endmethod

  method cwde()
    global X64_CWDE
    this.emitByte(X64_CWDE)
  endmethod

  method cdq()
    die('not implemented: cdq')
  endmethod

  method iretd()
    die('not implemented: iretd')
  endmethod

  method movsd()
    global X64_MOVSD
    this.emitByte(X64_MOVSD)
  endmethod

  method cmpsd()
    global X64_CMPSD
    this.emitByte(X64_CMPSD)
  endmethod

  method lodsd()
    global X64_LODSD
    this.emitByte(X64_LODSD)
  endmethod

  method stosd()
    global X64_STOSD
    this.emitByte(X64_STOSD)
  endmethod

  method scasd()
    global X64_SCASD
    this.emitByte(X64_SCASD)
  endmethod

  method insd()
    global X64_INSD
    this.emitByte(X64_INSD)
  endmethod

  method outsd()
    global X64_OUTSD
    this.emitByte(X64_OUTSD)
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with 80486 processor:
  #-----------------------------------------------------------------------------

  method bswap_r(reg)
    global X64_BSWAP
    this.emitSizePrefixIfNeeded(reg)
    this.emitWord(X64_BSWAP + 256 * bitand(reg, 0x7))
  endmethod

  method cmpxchg_r_r(regDst, regSrc)
    die('not implemented: cmpxchg r,r')
  endmethod

  method cmpxchg_m_r(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: cmpxchg m,r')
  endmethod

  method xadd_r_r(regDst, regSrc)
    die('not implemented: xadd r,r')
  endmethod

  method xadd_m_r(regBase, scale, regIndex, disp, regSrc)
    die('not implemented: xadd m,r')
  endmethod

  method invlpg_m(regBase, scale, regIndex, disp)
    die('not implemented: invlpg m')
  endmethod

  method invd()
    die('not implemented: invd')
  endmethod

  method wbinvd()
    die('not implemented: wbinvd')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Pentium processor:
  #-----------------------------------------------------------------------------

  method cmpxchg8b_m(regBase, scale, regIndex, disp)
    die('not implemented: cmpxchg8b m')
  endmethod

  method cpuid()
    die('not implemented: cpuid')
  endmethod

  method rdmsr()
    die('not implemented: rdmsr')
  endmethod

  method rdtsc()
    die('not implemented: rdtsc')
  endmethod

  method wrmsr()
    die('not implemented: wrmsr')
  endmethod

  method rsm()
    die('not implemented: rsm')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Penitum Pro processor:
  #-----------------------------------------------------------------------------
  method cmova_r_r(regDst, regSrc)
    die('not implemented: cmova r,r')
  endmethod

  method cmova_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmova r,m')
  endmethod

  method cmovae_r_r(regDst, regSrc)
    die('not implemented: cmovae r,r')
  endmethod

  method cmovae_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovae r,m')
  endmethod

  method cmovb_r_r(regDst, regSrc)
    die('not implemented: cmovb r,r')
  endmethod

  method cmovb_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovb r,m')
  endmethod

  method cmovbe_r_r(regDst, regSrc)
    die('not implemented: cmovbe r,r')
  endmethod

  method cmovbe_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovbe r,m')
  endmethod

  method cmovc_r_r(regDst, regSrc)
    die('not implemented: cmovc r,r')
  endmethod

  method cmovc_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovc r,m')
  endmethod

  method cmove_r_r(regDst, regSrc)
    die('not implemented: cmove r,r')
  endmethod

  method cmove_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmove r,m')
  endmethod

  method cmovg_r_r(regDst, regSrc)
    die('not implemented: cmovg r,r')
  endmethod

  method cmovg_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovg r,m')
  endmethod

  method cmovge_r_r(regDst, regSrc)
    die('not implemented: cmovge r,r')
  endmethod

  method cmovge_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovge r,m')
  endmethod

  method cmovl_r_r(regDst, regSrc)
    die('not implemented: cmovl r,r')
  endmethod

  method cmovl_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovl r,m')
  endmethod

  method cmovle_r_r(regDst, regSrc)
    die('not implemented: cmovle r,r')
  endmethod

  method cmovle_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovle r,m')
  endmethod

  method cmovna_r_r(regDst, regSrc)
    die('not implemented: cmovna r,r')
  endmethod

  method cmovna_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovna r,m')
  endmethod

  method cmovnae_r_r(regDst, regSrc)
    die('not implemented: cmovnae r,r')
  endmethod

  method cmovnae_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnae r,m')
  endmethod

  method cmovnb_r_r(regDst, regSrc)
    die('not implemented: cmovnb r,r')
  endmethod

  method cmovnb_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnb r,m')
  endmethod

  method cmovnbe_r_r(regDst, regSrc)
    die('not implemented: cmovnbe r,r')
  endmethod

  method cmovnbe_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnbe r,m')
  endmethod

  method cmovnc_r_r(regDst, regSrc)
    die('not implemented: cmovnc r,r')
  endmethod

  method cmovnc_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnc r,m')
  endmethod

  method cmovne_r_r(regDst, regSrc)
    die('not implemented: cmovne r,r')
  endmethod

  method cmovne_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovne r,m')
  endmethod

  method cmovng_r_r(regDst, regSrc)
    die('not implemented: cmovng r,r')
  endmethod

  method cmovng_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovng r,m')
  endmethod

  method cmovnge_r_r(regDst, regSrc)
    die('not implemented: cmovnge r,r')
  endmethod

  method cmovnge_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnge r,m')
  endmethod

  method cmovnl_r_r(regDst, regSrc)
    die('not implemented: cmovnl r,r')
  endmethod

  method cmovnl_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnl r,m')
  endmethod

  method cmovnle_r_r(regDst, regSrc)
    die('not implemented: cmovnle r,r')
  endmethod

  method cmovnle_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnle r,m')
  endmethod

  method cmovno_r_r(regDst, regSrc)
    die('not implemented: cmovno r,r')
  endmethod

  method cmovno_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovno r,m')
  endmethod

  method cmovnp_r_r(regDst, regSrc)
    die('not implemented: cmovnp r,r')
  endmethod

  method cmovnp_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnp r,m')
  endmethod

  method cmovns_r_r(regDst, regSrc)
    die('not implemented: cmovns r,r')
  endmethod

  method cmovns_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovns r,m')
  endmethod

  method cmovnz_r_r(regDst, regSrc)
    die('not implemented: cmovnz r,r')
  endmethod

  method cmovnz_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovnz r,m')
  endmethod

  method cmovo_r_r(regDst, regSrc)
    die('not implemented: cmovo r,r')
  endmethod

  method cmovo_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovo r,m')
  endmethod

  method cmovp_r_r(regDst, regSrc)
    die('not implemented: cmovp r,r')
  endmethod

  method cmovp_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovp r,m')
  endmethod

  method cmovpe_r_r(regDst, regSrc)
    die('not implemented: cmovpe r,r')
  endmethod

  method cmovpe_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovpe r,m')
  endmethod

  method cmovpo_r_r(regDst, regSrc)
    die('not implemented: cmovpo r,r')
  endmethod

  method cmovpo_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovpo r,m')
  endmethod

  method cmovs_r_r(regDst, regSrc)
    die('not implemented: cmovs r,r')
  endmethod

  method cmovs_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovs r,m')
  endmethod

  method cmovz_r_r(regDst, regSrc)
    die('not implemented: cmovz r,r')
  endmethod

  method cmovz_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: cmovz r,m')
  endmethod

  method ud2()
    die('not implemented: ud2')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Penium MMX processor:
  #-----------------------------------------------------------------------------

  method rdpmc()
    die('not implemented: rdpmc')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with AMD K6 processor:
  #-----------------------------------------------------------------------------

  method syscall()
    die('not implemented: syscall')
  endmethod

  method sysret()
    die('not implemented: sysret')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Penitum II:
  #-----------------------------------------------------------------------------

  method sysenter()
    die('not implemented: sysenter')
  endmethod

  method sysexit()
    die('not implemented: sysexit')
  endmethod

  #-----------------------------------------------------------------------------
  # Mnemonics added with Amd64:
  #-----------------------------------------------------------------------------

  method movsxd_r_r(regDst, regSrc)
    die('not implemented: movsxd r,r')
  endmethod

  method movsxd_r_m(regDst, regBase, scale, regIndex, disp)
    die('not implemented: movsxd r,m')
  endmethod

  method cmpxchg16b_m(regBase, scale, regIndex, disp)
    die('not implemented: cmpxchg16b m')
  endmethod

  method cdqe()
    this.emitPrefix64()
    this.cwde()
  endmethod

  method cqo()
    die('not implemented: cqo')
  endmethod

  method cmpsq()
    this.emitPrefix64()
    this.cmpsd()
  endmethod

  method stosq()
    this.emitPrefix64()
    this.stosd()
  endmethod

  method lodsq()
    this.emitPrefix64()
    this.lodsd()
  endmethod

  method scasq()
    this.emitPrefix64()
    this.scasd()
  endmethod

  method iretq()
    die('not implemented: iretq')
  endmethod

  method popfq()
    die('not implemented: popfq')
  endmethod

  method pushfq()
    die('not implemented: pushfq')
  endmethod

  method rdtscp()
    die('not implemented: rdtscp')
  endmethod

  method swapgs()
    die('not implemented: swapgs')
  endmethod

  #
  # Other
  #

  method getCurrentPosition() -> rv
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass

#machineEncoder = new MachineEncoderX64()
#machineEncoder.mov_r_m(X64_BL, X64_RAX, 1, X64_RBX, 0)
