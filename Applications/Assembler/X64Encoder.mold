################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Libs/BitwiseHack.mold'

/*
TODO
marco DEFINE_OPCODE_CORE_R_R(mnemonic, opcode)
  method ${mnemonic}_r_r(regDst, regSrc)
    this.emitCore_r_r(opcode, regDst, regSrc)
  endmethod
endmacro

DEFINE_OPCODE_CORE_R_R(add, X64_ADD)
DEFINE_OPCODE_CORE_R_R(sub, X64_SUB)
DEFINE_OPCODE_CORE_R_R(xor, X64_XOR)
DEFINE_OPCODE_CORE_R_R(or,  X64_OR)
DEFINE_OPCODE_CORE_R_R(and, X64_AND)
...
*/

class X64Encoder
  method constructor()
    this.outputObject = false
#    this.pos = 0
  endmethod

  method emitByte(x)
    this.outputObject.emitByte(x)
#    this.pos = this.pos + 1
  endmethod

  method emitWord(x)
    this.outputObject.emitWord(x)
#    this.pos = this.pos + 2
  endmethod

  method emitDword(x)
    this.outputObject.emitDword(x)
#    this.pos = this.pos + 4
  endmethod

  method emitQword(x)
    this.outputObject.emitQword(x)
#    this.pos = this.pos + 8
  endmethod

  # ----------------------------------------------------------------------------
  #                             Common helpers
  # ----------------------------------------------------------------------------

  method emitModRegRM(addressMode, reg, rm)
    # 7 6 | 5 4 3 | 2 1 0
    # mod | reg   | r/m
    reg = bitand(reg, 0x7)
    rm  = bitand(rm,  0x7)
    this.emitByte(addressMode * 64 + reg * 8 + rm)
  endmethod

  method emitPrimaryOpcode(opcodeMask, direct, size)
    # 7 6 5 4 3 2 | 1 0
    # opcode      | d s
    this.emitByte(opcodeMask + direct * 2 + size)
  endmethod

  method emitPrefix16()
    this.emitByte(0x66)
  endmethod

  method emitPrefix64()
    this.emitByte(0x48)
  endmethod

  method emitSizePrefixIfNeeded(reg)
    if X64_IsReg16(reg) is true
      # 16-bit: Emit operand size prefix.
      this.emitPrefix16()

    elif X64_IsReg64(reg) is true
      # 64-bit: Emit REX.W prefix.
      this.emitPrefix64()
    endif
  endmethod

  # ----------------------------------------------------------------------------
  #                        Core encoding patterns
  # ----------------------------------------------------------------------------

  method emitCore(opcode, mode, reg, rm)
    # opcode | mod-reg-rm | SIB    | displacement | immediate
    # 1-2B   | 0 or 1     | 0 or 1 | 0, 1, 2 or 4 | 0, 1, 2 or 4
    # bytes  | byte       | byte   | bytes        | bytes

    global X64_SIZE16_32_64

    # Emit prefixes if needed.
    if X64_IsReg8(reg) is false
      # 16, 32 or 64-bit operand(s)
      # 32-bit is default (no prefix needed)
      # Set size bit in primary operand byte.
      opcode = bitor(opcode, X64_SIZE16_32_64)
      this.emitSizePrefixIfNeeded(reg)
    endif

    # Primary opcode.
    this.emitByte(opcode)

    # Mod-Reg-R/M byte.
    this.emitModRegRM(mode, reg, rm)
  endmethod

  method emitCore_r_r(opcode, regDst, regSrc)
    global X64_MOD_REGISTER
    this.emitCore(opcode, X64_MOD_REGISTER, regSrc, regDst)
  endmethod

  method emitCore_m_r(opcode, regBase, scale, regIndex, disp, regSrc)
    global X64_MOD_INDIRECT, X64_MOD_DISP8, X64_MOD_DISP32
    global X64_RM_SIB_MODE, X64_RM_RIP_DISP_MODE
    global X64_SIB_BASE_NONE
    global X64_RIP, X64_EBP, X64_RBP, X64_RSP

    if regIndex is X64_RSP
      die('error: rsp register cannot be used as index')
    endif

    if (scale is 2) and (regBase is -1)
      # Fasm like optimization.
      # [2*rsi] -> [rsi + 1*rsi]
      regBase = regIndex
      scale   = 1
    endif

    if (regBase is X64_RSP) and (scale is -1)
      # Special case: [ rsp ]
      regIndex = X64_RSP
      scale    = 1
    endif

    if regBase is X64_RIP
      # Code independent address: [rip + disp32]
      # In this mode displacement is always 32-bit.
      # MOD = 00  = INDIRECT,
      # R/M = RBP = displacement only.
      this.emitCore(opcode, X64_MOD_INDIRECT, regSrc, X64_RM_RIP_DISP_MODE)
      this.emitDword(disp)

    elif (regBase is -1) and (scale is -1) and (regIndex is -1)
      # Absolute ds:[disp32] address.
      # In this mode displacement is always 32-bit.
      #
      # https://wiki.osdev.org/X86-64_Instruction_Encoding#32.2F64-bit_addressing_2
      # http://www.c-jump.com/CIS77/CPU/x86/lecture.html#X77_0100_sib_byte_layout
      #
      # MOD       = INDIRECT
      # SIB.scale = 1
      # SIB.index = 100 = ILLEGAL
      # SIB.base  = 101 = displacement only.
      this.emitCore(opcode, X64_MOD_INDIRECT, regSrc, X64_RM_SIB_MODE)
      this.emitByte(0x25)
      this.emitDword(disp)

    else
      # General case.
      if (regBase isnt X64_RBP) and ((disp is 0) or (regBase is -1))
        # [r], r
        # [disp], r
        mode = X64_MOD_INDIRECT

      elif (disp >= -127) and (disp <= 128)
        # [disp8], r
        # [r + disp8], r
        mode = X64_MOD_DISP8

      else
        # [disp32], r
        # [r + disp32], r
        mode = X64_MOD_DISP32
      endif

      # Enable Scaled Index Base (SIB) mode.
      if scale > 0
        # Full SIB: [base + scale * index + disp]
        rm = X64_RM_SIB_MODE
      else
        # Base and displacement: [base + disp]
        rm = regBase
      endif

      # Primary opcode and Mod-Reg-R/M byte.
      this.emitCore(opcode, mode, regSrc, rm)

      # Emit SIB byte if needed.
      if scale > 0
        if scale is 1
          # [base + index + disp]
          scaleMask = 0x00

        elif scale is 2
          # [base + 2*index + disp]
          scaleMask = 0x40

        elif scale is 4
          # [base + 4*index + disp]
          scaleMask = 0x80

        elif scale is 8
          # [base + 8*index + disp]
          scaleMask = 0xc0

        else
          # Error - unexpected scale.
          scaleMask = -1
          die('error: only 1, 2, 4 or 8 scale is available')
        endif

        if regBase is -1
          # [scale * index + disp32]
          # Displacement is always 32-bit and is emited even if zero.
          regBaseMask = X64_SIB_BASE_NONE
          mode        = X64_MOD_DISP32
        else
          # [base + scale * index + disp8/32]
          regBaseMask = bitand(regBase, 0x7)
        endif

        regIndexMask = bitand(regIndex, 0x7) * 8

        this.emitByte(scaleMask + regIndexMask + regBaseMask)
      endif

      # Emit displacement if needed.
      if mode is X64_MOD_DISP8
        # 8-bit displacemnt.
        this.emitByte(disp)

      elif mode is X64_MOD_DISP32
        # 32-bit displacement
        this.emitDword(disp)
      endif
    endif
  endmethod

  method emitCore_r_m(opcode, regDst, regBase, scale, regIndex, disp)
    # Set direction flag in primary opcode byte to swap r<->m direction.
    opcode = bitor(opcode, 2)
    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, regDst)
  endmethod

  method emitCore_r_imm(opcode, regDst, imm)
    global X64_MOD_REGISTER
    global X64_ALU_RM8_IMM8_GROUP
    global X64_ALU_RM32_IMM32_GROUP
    global X64_ALU_RM32_IMM8_GROUP
    global X64_AL

    # Sub-opcode to encode inside Reg-Mod-RM byte.
    operationId = opcode // 8

    if regDst is X64_AL
      # Special case for AL register.
      this.emitByte(opcode + 4)
      this.emitByte(imm)

    elif X64_IsReg8(regDst) is true
      # General 8-bit destination.
      this.emitByte(X64_ALU_RM8_IMM8_GROUP)
      this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
      this.emitByte(imm)

    else
      # 16-bit, 32-bit or 64-bit destination.
      # 32-bit is default (no prefix needed).
      this.emitSizePrefixIfNeeded(regDst)

      if (imm >= -127) and (imm <= 128)
        # r16, imm8
        # r32, imm8
        # r64, imm8
        this.emitByte(X64_ALU_RM32_IMM8_GROUP)
        this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
        this.emitByte(imm)

      else
        # r16, imm32
        # r32, imm32
        # r64, imm32
        if bitand(regDst, 0x7) is X64_AL
          # Special case for ax, eax, rax.
          this.emitByte(opcode + 5)

        else
          this.emitByte(X64_ALU_RM32_IMM32_GROUP)
          this.emitModRegRM(X64_MOD_REGISTER, operationId, regDst)
        endif

        # Emit immediate.
        if X64_IsReg16(regDst) is true
          this.emitWord(imm)
        else
          this.emitDword(imm)
        endif
      endif
    endif
  endmethod

  method emitCore_m_imm(opcode, regBase, scale, regIndex, disp, imm, dataSize)
    global X64_ALU_RM8_IMM8_GROUP
    global X64_ADC, X64_ADD, X64_AND, X64_CMP, X64_SBB, X64_SUB, X64_OR, X64_XOR

    # TODO: Clean up this mess.
    if dataSize is 2
      this.emitPrefix16()
    elif dataSize is 8
      this.emitPrefix64()
    endif

    if ((opcode is X64_ADC) or
        (opcode is X64_ADD) or
        (opcode is X64_AND) or
        (opcode is X64_CMP) or
        (opcode is X64_SBB) or
        (opcode is X64_SUB) or
        (opcode is X64_OR) or
        (opcode is X64_XOR))

      # Sub-opcode to encode inside Reg-Mod-RM byte.
      operationId = opcode // 8
      opcode      = X64_ALU_RM8_IMM8_GROUP
    else
      operationId = 0
    endif

    if dataSize > 1
      # Non 8-bit mode.
      opcode = opcode + 1
    endif

    this.emitCore_m_r(opcode, regBase, scale, regIndex, disp, operationId)

    if dataSize is 1
      # 8-bit immediate.
      this.emitByte(imm)
    elif dataSize is 2
      # 16-bit immediate.
      this.emitWord(imm)
    else
      # 32-bit immediate.
      # There is no 64-bit immediates even if qword
      # is accessed in memory.
      this.emitDword(imm)
    endif
  endmethod

  method emitCore_group_r(opcodeBase, operationId, reg)
    global X64_MOD_REGISTER
    if X64_IsReg8(reg) is true
      # neg r8 like.
      this.emitByte(opcodeBase)
    else
      # neg r16/32/64 like.
      # 32-bit is default.
      this.emitSizePrefixIfNeeded(reg)
      this.emitByte(opcodeBase + 1)
    endif

    # Emit Mod-Reg-R/M byte.
    # Reg field stores operation id (sub-opcode).
    this.emitModRegRM(X64_MOD_REGISTER, operationId, reg)
  endmethod

  method emitCore_group_m(opcodeBase, operationId, base, scale, index, disp)
    this.emitCore_m_r(opcodeBase, base, scale, index, disp, operationId)
  endmethod

  method emitCore_unaryGroup_r(operationId, reg)
    global X64_UNARY8_GROUP
    this.emitCore_group_r(X64_UNARY8_GROUP, operationId, reg)
  endmethod

  method emitCore_unaryGroup_m(operationId, base, scale, index, disp, dataSize)
    global X64_UNARY8_GROUP
    if dataSize is 2
      # access word (2-bytes)
      operationId = operationId + 16

    elif dataSize is 4
      # access word (2-bytes)
      operationId = operationId + 32

    elif dataSize is 8
      # access qword (8-bytes)
      operationId = operationId + 48
    endif

    this.emitCore_group_m(X64_UNARY8_GROUP, operationId, base, scale, index, disp)
  endmethod

  # ----------------------------------------------------------------------------
  #                       Public API: 64 instruction set
  # ----------------------------------------------------------------------------

  #
  # Core ALU: add, or, adc, sbb, and, sub, xor, cmp, neg, not
  #

  # alu r, r
  method add_r_r(regDst, regSrc)
    global X64_ADD
    this.emitCore_r_r(X64_ADD, regDst, regSrc)
  endmethod

  method or_r_r(regDst, regSrc)
    global X64_OR
    this.emitCore_r_r(X64_OR, regDst, regSrc)
  endmethod

  method adc_r_r(regDst, regSrc)
    global X64_ADC
    this.emitCore_r_r(X64_ADC, regDst, regSrc)
  endmethod

  method sbb_r_r(regDst, regSrc)
    global X64_SBB
    this.emitCore_r_r(X64_SBB, regDst, regSrc)
  endmethod

  method and_r_r(regDst, regSrc)
    global X64_AND
    this.emitCore_r_r(X64_AND, regDst, regSrc)
  endmethod

  method sub_r_r(regDst, regSrc)
    global X64_SUB
    this.emitCore_r_r(X64_SUB, regDst, regSrc)
  endmethod

  method xor_r_r(regDst, regSrc)
    global X64_XOR
    this.emitCore_r_r(X64_XOR, regDst, regSrc)
  endmethod

  method cmp_r_r(regDst, regSrc)
    global X64_CMP
    this.emitCore_r_r(X64_CMP, regDst, regSrc)
  endmethod

  # alu r, imm
  method add_r_imm(regDst, imm)
    global X64_ADD
    this.emitCore_r_imm(X64_ADD, regDst, imm)
  endmethod

  method or_r_imm(regDst, imm)
    global X64_OR
    this.emitCore_r_imm(X64_OR, regDst, imm)
  endmethod

  method adc_r_imm(regDst, imm)
    global X64_ADC
    this.emitCore_r_imm(X64_ADC, regDst, imm)
  endmethod

  method sbb_r_imm(regDst, imm)
    global X64_SBB
    this.emitCore_r_imm(X64_SBB, regDst, imm)
  endmethod

  method and_r_imm(regDst, imm)
    global X64_AND
    this.emitCore_r_imm(X64_AND, regDst, imm)
  endmethod

  method sub_r_imm(regDst, imm)
    global X64_SUB
    this.emitCore_r_imm(X64_SUB, regDst, imm)
  endmethod

  method xor_r_imm(regDst, imm)
    global X64_XOR
    this.emitCore_r_imm(X64_XOR, regDst, imm)
  endmethod

  method cmp_r_imm(regDst, imm)
    global X64_CMP
    this.emitCore_r_imm(X64_CMP, regDst, imm)
  endmethod

  # alu r, m
  method add_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_ADD
    this.emitCore_r_m(X64_ADD, regDst, regBase, scale, regIndex, disp)
  endmethod

  method or_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_OR
    this.emitCore_r_m(X64_OR, regDst, regBase, scale, regIndex, disp)
  endmethod

  method adc_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_ADC
    this.emitCore_r_m(X64_ADC, regDst, regBase, scale, regIndex, disp)
  endmethod

  method sbb_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_SBB
    this.emitCore_r_m(X64_SBB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method and_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_AND
    this.emitCore_r_m(X64_AND, regDst, regBase, scale, regIndex, disp)
  endmethod

  method sub_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_SUB
    this.emitCore_r_m(X64_SUB, regDst, regBase, scale, regIndex, disp)
  endmethod

  method xor_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_XOR
    this.emitCore_r_m(X64_XOR, regBase, scale, regIndex, disp)
  endmethod

  method cmp_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_CMP
    this.emitCore_r_m(X64_CMP, regBase, scale, regIndex, disp)
  endmethod

  # alu m, r
  method add_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_ADD
    this.emitCore_r_m(X64_ADD, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method or_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_OR
    this.emitCore_r_m(X64_OR, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method adc_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_ADC
    this.emitCore_r_m(X64_ADC, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method sbb_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_SBB
    this.emitCore_r_m(X64_SBB, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method and_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_AND
    this.emitCore_r_m(X64_AND, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method sub_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_SUB
    this.emitCore_r_m(X64_SUB, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method xor_m_r(regDst, regBase, scale, regIndex, disp)
    global X64_XOR
    this.emitCore_r_m(X64_XOR, regBase, scale, regIndex, disp)
  endmethod

  method cmp_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_CMP
    this.emitCore_r_m(X64_CMP, regBase, scale, regIndex, disp, regSrc)
  endmethod

  #
  # Core ALU: inc, dec
  #

  method inc_r(reg)
    global X64_INC_DEC_RM8_GROUP
    this.emitCore_group_r(X64_INC_DEC_RM8_GROUP, 0, reg)
  endmethod

  method inc_m(regBase, scale, regIndex, disp)
    die('not implemented: inc m')
  endmethod

  method dec_r(reg)
    global X64_INC_DEC_RM8_GROUP
    this.emitCore_group_r(X64_INC_DEC_RM8_GROUP, 1, reg)
  endmethod

  method dec_m(regBase, scale, regIndex, disp)
    die('not implemented: dec m')
  endmethod

  #
  # Bit test: test
  #

  method test_r_r(reg1, reg2)
    global X64_TEST_RM8_R8
    this.emitCore_r_r(X64_TEST_RM8_R8, reg1, reg2)
  endmethod

  method test_m_r(regBase, scale, regIndex, disp, reg2)
    global X64_TEST_RM8_R8
    this.emitCore_m_r(X64_TEST_RM8_R8, regBase, scale, regIndex, disp, reg2)
  endmethod

  method test_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    this.emitCore_unaryGroup_m(0, regBase, scale, regIndex, disp, dataSize)

    # TODO: Clean up this mess.
    if dataSize is 1
      # 8-bit immediate.
      this.emitByte(imm)
    elif dataSize is 2
      # 16-bit immediate.
      this.emitWord(imm)
    else
      # 32-bit immediate.
      # There is no 64-bit immediates even if qword
      # is accessed in memory.
      this.emitDword(imm)
    endif
  endmethod

  method test_r_imm(reg, imm)
    global X64_TEST_AL_IMM8
    global X64_TEST_EAX_IMM32
    global X64_AL, X64_AX
    global X64_MOD_REGISTER

    if bitand(reg, 0xf) is X64_AL
      # Special case:
      # - test al, imm8
      # - test ax, imm16  (16-bit prefix)
      # - test eax, imm32 (default)
      # - test rax, imm32 (REX.w prefix)
      if reg is X64_AL
        # test al, imm8
        this.emitByte(X64_TEST_AL_IMM8)

      else
        # Test ax, eax or rax register.
        this.emitSizePrefixIfNeeded(reg)
        this.emitByte(X64_TEST_EAX_IMM32)
      endif

    else
      # General case:
      # - test r8, imm8
      # - test r16, imm16 (16-bit prefix)
      # - test r32, imm32 (default)
      # - test r64, imm32 (REX.w prefix)
      this.emitCore_unaryGroup_r(0, reg)
    endif

    # Emit immediate.
    if X64_IsReg8(reg) is true
      # Test 8-bit register.
      this.emitByte(imm)

    elif X64_IsReg16(reg) is true
      # Test 16-bit register.
      this.emitWord(imm)

    else
      # Test 32 or 64-bit register.
      # Immediate is always 32-bit.
      this.emitDword(imm)
    endif
  endmethod

  #
  # Integer multiplication and division: mul, imul, div, idiv
  #

  # opcode r
  method not_r(reg)
    this.emitCore_unaryGroup_r(2, reg)
  endmethod

  method neg_r(reg)
    this.emitCore_unaryGroup_r(3, reg)
  endmethod

  method mul_r(reg)
    this.emitCore_unaryGroup_r(4, reg)
  endmethod

  method imul_r(reg)
    this.emitCore_unaryGroup_r(5, reg)
  endmethod

  method div_r(reg)
    this.emitCore_unaryGroup_r(6, reg)
  endmethod

  method idiv_r(reg)
    this.emitCore_unaryGroup_r(7, reg)
  endmethod

  # opcode m
  method not_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(2, base, scale, index, disp)
  endmethod

  method neg_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(3, base, scale, index, disp)
  endmethod

  method mul_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(4, base, scale, index, disp)
  endmethod

  method imul_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(5, base, scale, index, disp)
  endmethod

  method div_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(6, base, scale, index, disp)
  endmethod

  method idiv_m(base, scale, index, disp)
    this.emitCore_unaryGroup_m(7, base, scale, index, disp)
  endmethod

  #
  # Stack: push, pusha, pushad, pushf, pop, popa, popad, popf
  #

  method emitCore_pushPop_r(opcode, reg)
    if X64_IsReg16(reg)
      # push r16
      this.emitPrefix16()

    elif X64_IsReg64(reg)
      # push r64
      # Default scenario - nothing to do.

    else
      die('error: push/pop r8/32 are unavailable in 64-bit mode')
    endif

    this.emitByte(opcode + bitand(reg, 0x7))
  endmethod

  method push_r(reg)
    global X64_PUSH_R64
    this.emitCore_pushPop_r(X64_PUSH_R64, reg)
  endmethod

  method pop_r(reg)
    global X64_POP_R64
    this.emitCore_pushPop_r(X64_POP_R64, reg)
  endmethod

  method push_imm8(imm)
    global X64_PUSH_IMM8
    this.emitByte(X64_PUSH_IMM8)
    this.emitByte(imm)
  endmethod

  method push_imm32(imm)
    global X64_PUSH_IMM32
    this.emitByte(X64_PUSH_IMM32)
    this.emitDword(imm)
  endmethod

  #
  # Bit shifts and rotations: rol, ror, rcl, rcr, shl, rhr, sar
  #

  #
  # Ports: in, out,
  #        insb, insw, insd, insq,
  #        outsb, outsw, outsd, outsq.
  #

  method insb()
    global X64_INSB
    this.emitByte(X64_INSB)
  endmethod

  method insw()
    this.emitPrefix16()
    this.insd()
  endmethod

  method insd()
    global X64_INSD
    this.emitByte(X64_INSD)
  endmethod

  method insq()
    this.emitPrefix64()
    this.insd()
  endmethod

  method outsb()
    global X64_OUTSB
    this.emitByte(X64_OUTSB)
  endmethod

  method outsw()
    this.emitPrefix16()
    this.outsd()
  endmethod

  method outsd()
    global X64_OUTSD
    this.emitByte(X64_OUTSD)
  endmethod

  method outsq()
    this.emitPrefix64()
    this.outsd()
  endmethod

  # Strings: movsb, movsw, movsd, movsq,
  #          cmpsb, cmpsw, cmpsd, cmpsq,
  #          stosb, stosw, stosd, stosq,
  #          lodsb, lodsw, lodsd, lodsq,
  #          scasb, scasw, scasd, scasq,
  #          repne, repe.

  method movsb()
    global X64_MOVSB
    this.emitByte(X64_MOVSB)
  endmethod

  method movsw()
    this.emitPrefix16()
    this.movsd()
  endmethod

  method movsd()
    global X64_MOVSD
    this.emitByte(X64_MOVSD)
  endmethod

  method movsq()
    this.emitPrefix64()
    this.movsd()
  endmethod

  method cmpsb()
    global X64_CMPSB
    this.emitByte(X64_CMPSB)
  endmethod

  method cmpsw()
    this.emitPrefix16()
    this.cmpsd()
  endmethod

  method cmpsd()
    global X64_CMPSD
    this.emitByte(X64_CMPSD)
  endmethod

  method cmpsq()
    this.emitPrefix64()
    this.cmpsd()
  endmethod

  method stosb()
    global X64_STOSB
    this.emitByte(X64_STOSB)
  endmethod

  method stosw()
    this.emitPrefix16()
    this.stosd()
  endmethod

  method stosd()
    global X64_STOSD
    this.emitByte(X64_STOSD)
  endmethod

  method stosq()
    this.emitPrefix64()
    this.stosd()
  endmethod

  method lodsb()
    global X64_LODSB
    this.emitByte(X64_LODSB)
  endmethod

  method lodsw()
    this.emitPrefix16()
    this.lodsd()
  endmethod

  method lodsd()
    global X64_LODSD
    this.emitByte(X64_LODSD)
  endmethod

  method lodsq()
    this.emitPrefix64()
    this.lodsd()
  endmethod

  method scasb()
    global X64_SCASB
    this.emitByte(X64_SCASB)
  endmethod

  method scasw()
    this.emitPrefix16()
    this.scasd()
  endmethod

  method scasd()
    global X64_SCASD
    this.emitByte(X64_SCASD)
  endmethod

  method scasq()
    this.emitPrefix64()
    this.scasd()
  endmethod

  method repne()
    global X64_PREFIX_REPNE
    this.emitByte(X64_PREFIX_REPNE)
  endmethod

  method repe()
    global X64_PREFIX_REPE
    this.emitByte(X64_PREFIX_REPE)
  endmethod

  #
  # Unconditional jumps.
  #

  method emitCore_jump_rel8(opcode, rel)
    this.emitByte(opcode)
    this.emitByte(rel)
  endmethod

  method emitCore_jump_rel32(opcode, rel)
    this.emitByte(opcode)
    this.emitDword(rel)
  endmethod

  method jmp_rel(rel)
    global X64_JMP_REL8
    global X64_JMP_REL32

    if (rel >= -127) and (rel <= 128)
      # jmp rel8
      this.emitCore_jump_rel8(X64_JMP_REL8, rel)
    else
      # jmp rel32
      this.emitCore_jump_rel32(X64_JMP_REL32, rel)
    endif
  endmethod

  #
  # Conditional jumps: jxx, loopnz, loopz, loop, jrcxz, jecxz
  #

  method jo_rel(rel)
    global X64_JO
    this.emitCore_jump_rel8(X64_JO, rel)
  endmethod

  method jno_rel(rel)
    global X64_JNO
    this.emitCore_jump_rel8(X64_JNO, rel)
  endmethod

  method jb_rel(rel)
    global X64_JB
    this.emitCore_jump_rel8(X64_JB, rel)
  endmethod

  method jae_rel(rel)
    global X64_JAE
    this.emitCore_jump_rel8(X64_JAE, rel)
  endmethod

  method jz_rel(rel)
    global X64_JZ
    this.emitCore_jump_rel8(X64_JZ, rel)
  endmethod

  method jnz_rel(rel)
    global X64_JNZ
    this.emitCore_jump_rel8(X64_JNZ, rel)
  endmethod

  method jbe_rel(rel)
    global X64_JBE
    this.emitCore_jump_rel8(X64_JBE, rel)
  endmethod

  method ja_rel(rel)
    global X64_JA
    this.emitCore_jump_rel8(X64_JA, rel)
  endmethod

  method js_rel(rel)
    global X64_JS
    this.emitCore_jump_rel8(X64_JS, rel)
  endmethod

  method jns_rel(rel)
    global X64_JNS
    this.emitCore_jump_rel8(X64_JNS, rel)
  endmethod

  method jp_rel(rel)
    global X64_JP
    this.emitCore_jump_rel8(X64_JP, rel)
  endmethod

  method jnp_rel(rel)
    global X64_JNP
    this.emitCore_jump_rel8(X64_JNP, rel)
  endmethod

  method jl_rel(rel)
    global X64_JL
    this.emitCore_jump_rel8(X64_JL, rel)
  endmethod

  method jge_rel(rel)
    global X64_JGE
    this.emitCore_jump_rel8(X64_JGE, rel)
  endmethod

  method jle_rel(rel)
    global X64_JLE
    this.emitCore_jump_rel8(X64_JLE, rel)
  endmethod

  method jg_rel(rel)
    global X64_JG
    this.emitCore_jump_rel8(X64_JG, rel)
  endmethod

  method loopz_rel(rel)
    global X64_LOOPZ_REL8
    this.emitCore_jump_rel8(X64_LOOPZ_REL8, rel)
  endmethod

  method loopnz_rel(rel)
    global X64_LOOPNZ_REL8
    this.emitCore_jump_rel8(X64_LOOPNZ_REL8, rel)
  endmethod

  method loop_rel(rel)
    global X64_LOOP_REL8
    this.emitCore_jump_rel8(X64_LOOP_REL8, rel)
  endmethod

  method jecxz_rel(rel)
    global X64_JRCXZ_REL8
    this.emitByte(0x67)
    this.emitCore_jump_rel8(X64_JRCXZ_REL8, rel)
  endmethod

  method jrcxz_rel(rel)
    global X64_JRCXZ_REL8
    this.emitCore_jump_rel8(X64_JRCXZ_REL8, rel)
  endmethod

  #
  # Procedures: call, ret, retn, enter, leave
  #

  method call_rel(rel)
    global X64_CALL_REL32
    this.emitCore_jump_rel32(X64_CALL_REL32, rel)
  endmethod

  method call_r(reg)
    die('not implemented: call r')
  endmethod

  method call_m(regBase, scale, regIndex, disp)
    die('not implemented: call m')
  endmethod

  method ret()
    global X64_RET
    this.emitByte(X64_RET)
  endmethod

  method ret_imm8(imm)
    global X64_RET_IMM8
    this.emitByte(X64_RET_IMM8)
    this.emitByte(imm)
  endmethod

  method enter_imm16_imm8(disp, level)
    global X64_ENTER_IMM16_IMM8
    this.emitByte(X64_ENTER_IMM16_IMM8)
    this.emitWord(disp)
    this.emitByte(level)
  endmethod

  method leave()
    global X64_LEAVE
    this.emitByte(X64_LEAVE)
  endmethod

  #
  # Data move: mov, xchg
  #

  method mov_r_r(regDst, regSrc)
    global X64_MOV_RM8_R8
    this.emitCore_r_r(X64_MOV_RM8_R8, regDst, regSrc)
  endmethod

  method mov_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_MOV_RM8_R8
    this.emitCore_r_m(X64_MOV_RM8_R8, regDst, regBase, scale, regIndex, disp)
  endmethod

  method mov_m_r(regBase, scale, regIndex, disp, regSrc)
    global X64_MOV_RM8_R8
    this.emitCore_m_r(X64_MOV_RM8_R8, regBase, scale, regIndex, disp, regSrc)
  endmethod

  method mov_r_imm(regDst, imm)
    global X64_MOV_R8_IMM8
    global X64_MOV_R32_IMM32
    global X64_MOV_RM32_IMM32
    global X64_MOD_REGISTER

    regDstId = bitand(regDst, 0x7)

    if X64_IsReg8(regDst) is true
      # mov r8, imm8
      this.emitByte(X64_MOV_R8_IMM8 + regDstId)
      this.emitByte(imm)

    else
      # Move 16, 32 or 64 bits.
      # 32-bit is default (no prefix needed).
      if X64_IsReg16(regDst) is true
        # mov r16, imm16
        this.emitPrefix16()
        this.emitByte(X64_MOV_R32_IMM32 + regDstId)
        this.emitWord(imm)

      elif X64_IsReg32(regDst) is true
        # mov r32, imm32
        this.emitByte(X64_MOV_R32_IMM32 + regDstId)
        this.emitDword(imm)

      else
        # mov r64, imm32
        this.emitPrefix64()
        this.emitCore(X64_MOV_RM32_IMM32, X64_MOD_REGISTER, 0, regDst)
        this.emitDword(imm)
      endif
    endif
  endmethod

  method mov_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
    global X64_MOV_RM8_IMM8
    this.emitCore_m_imm(X64_MOV_RM8_IMM8, regBase, scale, regIndex, disp, imm, dataSize)
  endmethod

  method xchg_r_r(reg1, reg2)
    global X64_XCHG_RM8_R8, X64_XCHG_EAX_R32, X64_NOP
    global X64_AL, X64_EAX, X64_RAX

    if X64_IsReg8(reg1) is true
      # xchg r8, r8
      this.emitCore_r_r(X64_XCHG_RM8_R8, reg2, reg1)

    elif (reg1 is X64_EAX) and (reg2 is X64_EAX)
      # Avoid emitting optimized one byte version for
      # xchg eax, eax
      # to distinguish from explicit nop opcode.
      this.emitWord(0xc087)

    else
      regMask1 = bitand(reg1, 0x7)
      regMask2 = bitand(reg2, 0x7)

      if regMask1 is X64_AL
        # Use optimized one-byte version if first operand is rax.
        # xchg ax/eax/rax, r
        this.emitSizePrefixIfNeeded(reg1)
        this.emitByte(X64_XCHG_EAX_R32 + regMask2)

      elif regMask2 is X64_AL
        # xchg r, ax/eax/rax
        # Swap arguments and use optimized rax version.
        this.emitSizePrefixIfNeeded(reg1)
        this.emitByte(X64_XCHG_EAX_R32 + regMask1)

      else
        # General case: xchg r, r
        this.emitCore_r_r(X64_XCHG_RM8_R8, reg2, reg1)
      endif
    endif
  endmethod

  # Conversion: cbw, cwd, cdq, movsxd
  method movsxd_r_r(regDst, regSrc)
    global X64_MOVSXD_R32_RM32
    this.emitCore_r_r(X64_MOVSXD_R32_RM32, regDst, regSrc)
  endmethod

  method movsxd_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_MOVSXD_R32_RM32
    this.emitCore_r_m(X64_MOVSXD_R32_RM32, regBase, scale, regIndex, disp)
  endmethod

  method cwde()
    global X64_CWDE
    this.emitByte(X64_CWDE)
  endmethod

  method cbw()
    this.emitPrefix16()
    this.cwde()
  endmethod

  method cdqe()
    this.emitPrefix64()
    this.cwde()
  endmethod

  #
  # Interrupts: int, into, int1, int3, iret
  #

  method int(imm8)
    global X64_INT_IMM8
    global X64_INTO, X64_INT1, X64_INT3

    if imm8 is 0
      this.emitByte(X64_INTO)

    elif imm8 is 1
      this.emitByte(X64_INT1)

    elif imm8 is 3
      this.emitByte(X64_INT3)

    else
      this.emitByte(X64_INT_IMM8)
      this.emitByte(imm8)
    endif
  endmethod

  method iret()
    global X64_IRET
    this.emitByte(X64_IRET)
  endmethod

  #
  # Flags: clc, stc, cli, sti, cld, std
  #

  method clc()
    global X64_CLC
    this.emitByte(X64_CLC)
  endmethod

  method stc()
    global X64_STC
    this.emitByte(X64_STC)
  endmethod

  method cli()
    global X64_CLI
    this.emitByte(X64_CLI)
  endmethod

  method sti()
    global X64_STI
    this.emitByte(X64_STI)
  endmethod

  method cld()
    global X64_CLD
    this.emitByte(X64_CLD)
  endmethod

  method std()
    global X64_STD
    this.emitByte(X64_STD)
  endmethod

  #
  # Core other: lea, nop, xlat, hlt, cmc
  #

  method lea_r_m(regDst, regBase, scale, regIndex, disp)
    global X64_LEA_R32_M64
    this.emitCore_r_m(regDst, regBase, scale, regIndex, disp)
  endmethod

  #
  #  lock
  #

  method lock()
    global X64_PREFIX_LOCK
    this.emitByte(X64_PREFIX_LOCK)
  endmethod

  method connectTo(outputObject) -> rv
    this.outputObject = outputObject
    rv = outputObject
  endmethod

  #
  # Other
  #

  method getCurrentPosition() -> rv
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass

#machineEncoder = new MachineEncoderX64()
#machineEncoder.mov_r_m(X64_BL, X64_RAX, 1, X64_RBX, 0)
