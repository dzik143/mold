################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Compiler/Utils/PipeAbstract.mold'

# Encoding handlers: no operands (opcode only).
X64_HANDLER_OPCODE_ONLY_BYTE     = 0x00000000
X64_HANDLER_OPCODE_ONLY_WORD     = 0x01000000
X64_HANDLER_OPCODE_ONLY_0F_XX_YY = 0x02000000

# Encoding handlers: one operands.
X64_HANDLER_CORE_ALU1            = 0x10000000
X64_HANDLER_JCC                  = 0x11000000
X64_HANDLER_JUMPS_REL8           = 0x12000000
X64_HANDLER_JUMPS_REL8_2BYTES    = 0x13000000
X64_HANDLER_0F_01_GROUP          = 0x14000000
X64_HANDLER_SETCC                = 0x15000000
X64_HANDLER_CUSTOM_X             = 0x16000000

# Encoding handlers: two operands with equal size.
X64_HANDLER_CORE_ALU2            = 0x20000000
X64_HANDLER_CORE2                = 0x21000000

# Encoding handler: two operands (generic).
X64_HANDLER_SHIFT_GROUP          = 0x30000000
X64_HANDLER_MOV_EXTEND           = 0x31000000
X64_HANDLER_286                  = 0x32000000
X64_HANDLER_CUSTOM_X_Y           = 0x33000000

# Other.
X64_HANDLER_0F_00_GROUP          = 0xf0000000
X64_HANDLER_CUSTOM               = 0xfd000000
X64_HANDLER_DO_NOTHING           = 0xfe000000
X64_HANDLER_INVALID_IN_64        = 0xff000000

                 #  0 1 2 3 4 5 6 7 8  bytes
X64_DATA_SIZE_ID = [0,0,1,1,2,2,2,2,3]

# Common operands combinations for generic syntax checking.
X64_SYNTAX_ZERO_OPERANDS           = 0x00000000
X64_SYNTAX_ONE_OPERAND             = 0x10000000
X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE = 0x20000000
X64_SYNTAX_TWO_OPERANDS            = 0x30000000

# Opcodes, that does not require any operands.
# We can emit them as is.
X64_OPCODES_MAP = {
  'use64':      X64_HANDLER_DO_NOTHING,

  'das':        X64_HANDLER_INVALID_IN_64,
  'aas':        X64_HANDLER_INVALID_IN_64,
  'bound':      X64_HANDLER_INVALID_IN_64,
  'sahf':       X64_HANDLER_INVALID_IN_64,
  'lahf':       X64_HANDLER_INVALID_IN_64,
  'les':        X64_HANDLER_INVALID_IN_64,
  'lds':        X64_HANDLER_INVALID_IN_64,
  'aam':        X64_HANDLER_INVALID_IN_64,
  'aad':        X64_HANDLER_INVALID_IN_64,
  'arpl':       X64_HANDLER_INVALID_IN_64,
  'pusha':      X64_HANDLER_INVALID_IN_64,
  'popa':       X64_HANDLER_INVALID_IN_64,
  'pushad':     X64_HANDLER_INVALID_IN_64,
  'popad':      X64_HANDLER_INVALID_IN_64,
  'pushfd':     X64_HANDLER_INVALID_IN_64,
  'popfd':      X64_HANDLER_INVALID_IN_64,
  'into':       X64_HANDLER_INVALID_IN_64,

  'cwde':       X64_CWDE, # - (no operands)
  'cdq':        X64_CDQ,  # - (no operands)

  'clc':        X64_CLC, # - (no operands)
  'cld':        X64_CLD, # - (no operands)
  'cli':        X64_CLI, # - (no operands)
  'stc':        X64_STC, # - (no operands)
  'std':        X64_STD, # - (no operands)
  'sti':        X64_STI, # - (no operands)
  'cmc':        X64_CMC, # - (no operands)

  'cmpsb':      X64_CMPSB, # - (no operands)
  'cmpsd':      X64_CMPSD, # - (no operands)
  'movsb':      X64_MOVSB, # - (no operands)
  'movsd':      X64_MOVSD, # - (no operands)
  'lodsb':      X64_LODSB, # - (no operands)
  'lodsd':      X64_LODSD, # - (no operands)
  'stosb':      X64_STOSB, # - (no operands)
  'stosd':      X64_STOSD, # - (no operands)
  'scasb':      X64_SCASB, # - (no operands)
  'scasd':      X64_SCASD, # - (no operands)
  'insb' :      X64_INSB,  # - (no operands)
  'insd' :      X64_INSD,  # - (no operands)
  'outsb':      X64_OUTSB, # - (no operands)
  'outsd':      X64_OUTSD, # - (no operands)

  'rep':        X64_PREFIX_REPE, # - (no operands)
  'repe':       X64_PREFIX_REPE, # - (no operands)
  'repz':       X64_PREFIX_REPE, # - (no operands)
  'repne':      X64_PREFIX_REPNE,# - (no operands)
  'repnz':      X64_PREFIX_REPNE,# - (no operands)

  'hlt':        X64_HLT,         # - (no operands)
  'lock':       X64_PREFIX_LOCK, # - (no operands)
  'xlatb':      X64_XLATB,       # - (no operands)

  'int1':       X64_INT1, # - (no operands)
  'int3':       X64_INT3, # - (no operands)
  'iret':       X64_IRET, # - (no operands)
  'iretd':      X64_IRET, # - (no operands)

  'pushf':      X64_PUSHF, # - (no operands)
  'pushfq':     X64_PUSHF, # - (no operands)
  'popf':       X64_POPF,  # - (no operands)
  'popfq':      X64_POPF,  # - (no operands)

  'leave':      X64_LEAVE, # - (no operands)
  'wait':       X64_FWAIT, # - (no operands)
  'fwait':      X64_FWAIT, # - (no operands)

  'cmpsw':      X64_CMPSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cmpsq':      X64_CMPSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'movsw':      X64_MOVSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'movsq':      X64_MOVSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'lodsw':      X64_LODSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'lodsq':      X64_LODSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'stosw':      X64_STOSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'stosq':      X64_STOSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'scasw':      X64_SCASW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'scasq':      X64_SCASQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'insw' :      X64_INSW     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'outsw':      X64_OUTSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cbw':        X64_CBW      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cdqe':       X64_CDQE     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cwd':        X64_CWD      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cqo':        X64_CQO      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iretq':      X64_IRETQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'pushfw':     X64_PUSHFW   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'popfw':      X64_POPFW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'clts':       X64_CLTS     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cpuid':      X64_CPUID    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'wrmsr':      X64_WRMSR    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdtsc':      X64_RDTSC    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdmsr':      X64_RDMSR    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdpmc':      X64_RDPMC    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rsm':        X64_RSM      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'invd':       X64_INVD     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'wbinvd':     X64_WBINVD   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'syscall':    X64_SYSCALL  + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysret':     X64_SYSRET   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysenter':   X64_SYSENTER + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysexit':    X64_SYSEXIT  + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'ud2':        X64_UD2      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)

  'rdtscp':     X64_RDTSCP + X64_HANDLER_OPCODE_ONLY_0F_XX_YY, # - (no operands)
  'swapgs':     X64_SWAPGS + X64_HANDLER_OPCODE_ONLY_0F_XX_YY, # - (no operands)

  'adc':        X64_ADC            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'add':        X64_ADD            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'and':        X64_AND            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'cmp':        X64_CMP            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'sbb':        X64_SBB            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'sub':        X64_SUB            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'or':         X64_OR             + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'xor':        X64_XOR            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm

  'bt':         X64_BT_RM_R        + X64_HANDLER_CORE_ALU2, # rd,rd | md,rd
  'btc':        X64_BTC_RM_R       + X64_HANDLER_CORE_ALU2, # rd,rd | md,rd
  'btr':        X64_BTR_RM_R       + X64_HANDLER_CORE_ALU2, # rd,rd | md,rd
  'bts':        X64_BTS_RM_R       + X64_HANDLER_CORE_ALU2, # rd,rd | md,rd
  'cmpxchg':    X64_CMPXCHG_RM8_R8 + X64_HANDLER_CORE_ALU2, # rd,rd | md,rd
  'xadd':       X64_XADD_RM8_R8    + X64_HANDLER_CORE_ALU2, # rd,rd | md,rd

  'bsf':        X64_BSF     + X64_HANDLER_CORE2, # rd,rd | rd,md
  'bsr':        X64_BSR     + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovo':      X64_CMOVO   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovno':     X64_CMOVNO  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovb':      X64_CMOVB   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnae':    X64_CMOVB   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovc':      X64_CMOVB   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnb':     X64_CMOVAE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovae':     X64_CMOVAE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnc':     X64_CMOVAE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovz':      X64_CMOVE   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmove':      X64_CMOVE   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnz':     X64_CMOVNE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovne':     X64_CMOVNE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovbe':     X64_CMOVBE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovna':     X64_CMOVBE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnbe':    X64_CMOVA   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmova':      X64_CMOVA   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovs':      X64_CMOVS   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovns':     X64_CMOVNS  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovp':      X64_CMOVP   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovpe':     X64_CMOVP   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnp':     X64_CMOVNP  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovpo':     X64_CMOVNP  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovl':      X64_CMOVL   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnge':    X64_CMOVL   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovge':     X64_CMOVGE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnl':     X64_CMOVGE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovle':     X64_CMOVLE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovng':     X64_CMOVLE  + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovnle':    X64_CMOVG   + X64_HANDLER_CORE2, # rd,rd | rd,md
  'cmovg':      X64_CMOVG   + X64_HANDLER_CORE2, # rd,rd | rd,md

  'not':        2 + X64_HANDLER_CORE_ALU1, # r | m
  'neg':        3 + X64_HANDLER_CORE_ALU1, # r | m
  'mul':        4 + X64_HANDLER_CORE_ALU1, # r | m
  'imul':       5 + X64_HANDLER_CORE_ALU1, # r | m | rd,md | rd,md,imm
  'div':        6 + X64_HANDLER_CORE_ALU1, # r | m
  'idiv':       7 + X64_HANDLER_CORE_ALU1, # r | m

  'lar':        X64_LAR + X64_HANDLER_286, # rd,r16    | rd,m16
  'lss':        X64_LSS + X64_HANDLER_286, # rd,md-far
  'lfs':        X64_LFS + X64_HANDLER_286, # rd,md-far
  'lgs':        X64_LGS + X64_HANDLER_286, # rd,md-far

  'sldt':       0 + X64_HANDLER_0F_00_GROUP, # r16 | r64 | m16
  'str':        1 + X64_HANDLER_0F_00_GROUP, # rd  | m16
  'lldt':       2 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'ltr':        3 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'verr':       4 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'verw':       5 + X64_HANDLER_0F_00_GROUP, # r16 | m16

  'sgdt':       0 + X64_HANDLER_0F_01_GROUP, # m80
  'sidt':       1 + X64_HANDLER_0F_01_GROUP, # m80
  'lgdt':       2 + X64_HANDLER_0F_01_GROUP, # m48
  'lidt':       3 + X64_HANDLER_0F_01_GROUP, # m48
  'smsw':       4 + X64_HANDLER_0F_01_GROUP, # rd | m16
  'lmsw':       6 + X64_HANDLER_0F_01_GROUP, # rd | m16
  'invlpg':     7 + X64_HANDLER_0F_01_GROUP, # m

  'jo':         X64_JO  + X64_HANDLER_JCC, # rel8 | rel32
  'jno':        X64_JNO + X64_HANDLER_JCC, # rel8 | rel32
  'jb':         X64_JB  + X64_HANDLER_JCC, # rel8 | rel32
  'jae':        X64_JAE + X64_HANDLER_JCC, # rel8 | rel32
  'jz':         X64_JZ  + X64_HANDLER_JCC, # rel8 | rel32
  'je':         X64_JZ  + X64_HANDLER_JCC, # rel8 | rel32
  'jnz':        X64_JNZ + X64_HANDLER_JCC, # rel8 | rel32
  'jne':        X64_JNZ + X64_HANDLER_JCC, # rel8 | rel32
  'jbe':        X64_JBE + X64_HANDLER_JCC, # rel8 | rel32
  'ja':         X64_JA  + X64_HANDLER_JCC, # rel8 | rel32
  'js':         X64_JS  + X64_HANDLER_JCC, # rel8 | rel32
  'jns':        X64_JNS + X64_HANDLER_JCC, # rel8 | rel32
  'jp':         X64_JP  + X64_HANDLER_JCC, # rel8 | rel32
  'jnp':        X64_JNP + X64_HANDLER_JCC, # rel8 | rel32
  'jl':         X64_JL  + X64_HANDLER_JCC, # rel8 | rel32
  'jge':        X64_JGE + X64_HANDLER_JCC, # rel8 | rel32
  'jle':        X64_JLE + X64_HANDLER_JCC, # rel8 | rel32
  'jg':         X64_JG  + X64_HANDLER_JCC, # rel8 | rel32

  'loop':       X64_LOOP_REL8   + X64_HANDLER_JUMPS_REL8, # rel8
  'loopz':      X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8
  'loopnz':     X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8, # rel8
  'loope':      X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8
  'loopne':     X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8, # rel8
  'jrcxz':      X64_JRCXZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8

  'loopd':      X64_LOOP_REL8   + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopzd':     X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopnzd':    X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'looped':     X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopned':    X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'jecxz':      X64_JRCXZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8

  'rol':        0 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'ror':        1 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'rcl':        2 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'rcr':        3 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'shl':        4 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'sal':        4 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'shr':        5 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'sar':        7 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8

  'movsx':      X64_MOVSX_R_RM8 + X64_HANDLER_MOV_EXTEND, # rd,r8 | rd,m8 | r32,r16 | r32,m16 | r64,r16 | r64,m16
  'movzx':      X64_MOVZX_R_RM8 + X64_HANDLER_MOV_EXTEND, # rd,r8 | rd,m8 | r32,r16 | r32,m16 | r64,r16 | r64,m16

  'seto':       X64_SETO  + X64_HANDLER_SETCC, # r8 | m8
  'setno':      X64_SETNO + X64_HANDLER_SETCC, # r8 | m8
  'setb':       X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setnae':     X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setc':       X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setnb':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setae':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setnc':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setz':       X64_SETE  + X64_HANDLER_SETCC, # r8 | m8
  'sete':       X64_SETE  + X64_HANDLER_SETCC, # r8 | m8
  'setnz':      X64_SETNE + X64_HANDLER_SETCC, # r8 | m8
  'setne':      X64_SETNE + X64_HANDLER_SETCC, # r8 | m8
  'setbe':      X64_SETBE + X64_HANDLER_SETCC, # r8 | m8
  'setna':      X64_SETBE + X64_HANDLER_SETCC, # r8 | m8
  'setnbe':     X64_SETA  + X64_HANDLER_SETCC, # r8 | m8
  'seta':       X64_SETA  + X64_HANDLER_SETCC, # r8 | m8
  'sets':       X64_SETS  + X64_HANDLER_SETCC, # r8 | m8
  'setns':      X64_SETNS + X64_HANDLER_SETCC, # r8 | m8
  'setp':       X64_SETP  + X64_HANDLER_SETCC, # r8 | m8
  'setpe':      X64_SETP  + X64_HANDLER_SETCC, # r8 | m8
  'setnp':      X64_SETNP + X64_HANDLER_SETCC, # r8 | m8
  'setpo':      X64_SETNP + X64_HANDLER_SETCC, # r8 | m8
  'setl':       X64_SETL  + X64_HANDLER_SETCC, # r8 | m8
  'setnge':     X64_SETL  + X64_HANDLER_SETCC, # r8 | m8
  'setge':      X64_SETGE + X64_HANDLER_SETCC, # r8 | m8
  'setnl':      X64_SETGE + X64_HANDLER_SETCC, # r8 | m8
  'setle':      X64_SETLE + X64_HANDLER_SETCC, # r8 | m8
  'setng':      X64_SETLE + X64_HANDLER_SETCC, # r8 | m8
  'setnle':     X64_SETG  + X64_HANDLER_SETCC, # r8 | m8
  'setg':       X64_SETG  + X64_HANDLER_SETCC, # r8 | m8

  'mov':        X64_MOV         + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r | r,imm | m,imm | r64,imm64
  'test':       X64_TEST        + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r | r,imm | m,imm
  'xchg':       X64_XCHG        + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r
  'out':        X64_OUT_IMM8_AL + X64_HANDLER_CUSTOM_X_Y, # imm8,al | imm8,ax | imm8,eax | dx,al | dx,ax | dx,eax
  'in':         X64_IN_AL_IMM8  + X64_HANDLER_CUSTOM_X_Y, # al,imm8 | ax,imm8 | eax,imm8 | al,dx | ax,dx | eax,dx
  'lsl':        X64_LSL         + X64_HANDLER_CUSTOM_X_Y, # rd,r16  | rd,m16
  'movsxd':     X64_MOVSXD      + X64_HANDLER_CUSTOM_X_Y, # r64,r32 | r64,m32
  'lea':        X64_LEA         + X64_HANDLER_CUSTOM_X_Y, # rd,m

  'call':       X64_CALL_REL32  + X64_HANDLER_CUSTOM_X, #       rel16 | rel32 | r16 | r64 | m16 | m64
  'jmp':        X64_JMP_REL32   + X64_HANDLER_CUSTOM_X, # rel8| rel16 | rel32 | r16 | r64 | m16 | m64
  'push':       X64_PUSH_R64    + X64_HANDLER_CUSTOM_X, # r16 | m16 | r64 | m64 | imm8 | imm16
  'pop':        X64_POP_R64     + X64_HANDLER_CUSTOM_X, # r16 | m16 | r64 | m64
  'bswap':      X64_BSWAP       + X64_HANDLER_CUSTOM_X, # r32 | r64
  'cmpxchg8b':  X64_CMPXCHG8B   + X64_HANDLER_CUSTOM_X, # m64
  'cmpxchg16b': X64_CMPXCHG16B  + X64_HANDLER_CUSTOM_X, # m128
  'inc':        X64_INC_R32     + X64_HANDLER_CUSTOM_X, # r | m
  'dec':        X64_DEC_R32     + X64_HANDLER_CUSTOM_X, # r | m
  'int':        X64_INT         + X64_HANDLER_CUSTOM_X, # imm8

  'enter':      X64_ENTER       + X64_HANDLER_CUSTOM, # imm16, imm8
  'retf':       X64_RETF        + X64_HANDLER_CUSTOM, # - | imm16
  'ret':        X64_RET         + X64_HANDLER_CUSTOM, # - | imm16
  'nop':        X64_NOP         + X64_HANDLER_CUSTOM  # - | rd | md
}

class X64Translator extends PipeAbstract
  method emitCore_x_y(opcode, item)
    emiter   = this.outputObject
    reg      = item.reg
    regBase  = item.base
    regIndex = item.index
    disp     = item.disp
    scale    = item.scale

    if item.imm is defined
      if reg isnt -1
        # opcode r, imm
        emiter.emitCore_r_imm(opcode, reg, item.imm)
      else
        # opcode m, imm
        emiter.emitCore_m_imm(
          opcode, regBase, scale, regIndex, disp, item.imm, item.dataSize)
      endif

    elif reg isnt -1
      if item.rm isnt -1
        # opcode r, r
        regSrc = item.rm
        emiter.emitCore_r_r(opcode, reg, regSrc)

      elif item.scale is defined
        # opcode r, m
        # opcode m, r
        # opcode m, imm
        if item.imm is defined
          emiter.emitCore_m_imm(opcode, regBase, scale, regIndex, disp, item.imm)

        elif item.isWriteToMemory is true
          emiter.emitCore_m_r(opcode, regBase, scale, regIndex, disp, reg)

        else
          emiter.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)
        endif
      endif
    endif
  endmethod

  method emitCoreALU2(opcode, item)
    # TODO: Review it.
    # Why we need to swap regs here?
    reg = item.reg
    rm  = item.rm

    if (reg isnt -1) and (item.rm isnt -1)
      item.reg = item.rm
      item.rm  = reg
    endif

    # Recognized common two-operands opcode.
    if item.imm is undefined
      if (X64_IsReg8(item.reg) is true) or (item.dataSize is 1)
        # 8-bit operands. Do nothing.

      elif opcode < 256
        # Set size bit in primary opcode to enable operands
        # greater than 8-bit.
        # This is old encoding pattern from original 8086 processor.
        opcode = opcode + 1

      else
        # 2-byte opcode. Primary opcode is in the higher byte.
        opcode = bitor(opcode, 256)
      endif
    endif

    # Generic two operands handler.
    this.emitCore_x_y(opcode, item)
  endmethod

  method _validateNumberOfOperands(cnt, expectedCnt)
    if cnt < expectedCnt
      die('error: not enough operands')
    elif cnt > expectedCnt
      die('error: too many operands')
    endif
  endmethod

  method _validateOperandSizes(reg, rm, dataSize, imm)
    global X64_DATA_SIZE_ID

    if imm is undefined
      # r,r
      # r,m
      # m,r
      regSizeId  = reg // 16
      rmSizeId   = rm  // 16
      dataSizeId = X64_DATA_SIZE_ID[dataSize]

      if (((rm isnt -1)       and (regSizeId isnt rmSizeId)) or # r,r
         ((dataSize isnt -1) and (regSizeId isnt dataSizeId))) # r,m or m,r
        die('error: operand sizes do not match')
      endif
    endif
  endmethod

  method processOneItem(item)
    global X64_OPCODES_MAP
    global X64_CMPXCHG_RM8_R8, X64_CMPXCHG_RM32_R32
    global X64_XADD_RM8_R8, X64_XADD_RM32_R32
    global X64_HANDLER_CORE_ALU1, X64_HANDLER_CORE_ALU2
    global X64_HANDLER_CORE2, X64_HANDLER_JCC, X64_HANDLER_JUMPS_REL8
    global X64_HANDLER_JUMPS_REL8_2BYTES, X64_HANDLER_286
    global X64_HANDLER_0F_00_GROUP, X64_HANDLER_0F_01_GROUP
    global X64_HANDLER_SHIFT_GROUP, X64_HANDLER_SETCC, X64_HANDLER_DO_NOTHING
    global X64_HANDLER_INVALID_IN_64, X64_HANDLER_OPCODE_ONLY_0F_XX_YY
    global X64_HANDLER_CUSTOM, X64_HANDLER_OPCODE_ONLY_BYTE
    global X64_HANDLER_OPCODE_ONLY_WORD, X64_HANDLER_MOV_EXTEND
    global X64_LEA, X64_MOV, X64_TEST, X64_XCHG, X64_CALL_REL32, X64_NOP
    global X64_IN, X64_OUT, X64_JMP_REL32, X64_PUSH_R64, X64_POP_R64
    global X64_RET, X64_RETF, X64_BSWAP, X64_CMPXCHG8B, X64_CMPXCHG16B
    global X64_INC_R32, X64_DEC_R32, X64_ENTER, X64_LEAVE, X64_INT
    global X64_SYNTAX_ZERO_OPERANDS, X64_SYNTAX_ONE_OPERAND
    global X64_SYNTAX_TWO_OPERANDS, X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE
    global X64_HANDLER_CUSTOM_X, X64_HANDLER_CUSTOM_X_Y
    global X64_LSL, X64_MOVSXD

    encoder = this.outputObject

    if item.type is 'instruction'
      # Parse one code line.
      # Fetch instruction info.
      mnemonic         = item.mnemonic
      reg              = item.reg
      rm               = item.rm
      regBase          = item.base
      regIndex         = item.index
      disp             = item.disp
      scale            = item.scale
      imm              = item.imm
      dataSize         = item.dataSize
      numberOfOperands = item.numberOfOperands

      # Search for mnemonic.
      opcodeInfo = X64_OPCODES_MAP[mnemonic]
      if opcodeInfo is undefined
        die("error: invalid instruction: '" + mnemonic + "'")
      endif

      # Decode handler and opcode.
      opcode    = bitand(opcodeInfo, 0x00ffffff)
      handlerId = bitand(opcodeInfo, 0xff000000)
      syntaxId  = bitand(opcodeInfo, 0xf0000000)

      # Generic syntax checking for most common rules.
      if syntaxId is X64_SYNTAX_ZERO_OPERANDS
        this._validateNumberOfOperands(numberOfOperands, 0)

      elif syntaxId is X64_SYNTAX_ONE_OPERAND
        this._validateNumberOfOperands(numberOfOperands, 1)

      elif syntaxId is X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE
        this._validateNumberOfOperands(numberOfOperands, 2)
        this._validateOperandSizes(reg, rm, dataSize, imm)

      elif syntaxId is X64_SYNTAX_TWO_OPERANDS
        this._validateNumberOfOperands(numberOfOperands, 2)
      endif

      # Dispatch opcode handler.
      if handlerId is X64_HANDLER_OPCODE_ONLY_BYTE
        # Recognized no-operands opcode.
        # Just emit opcode as is.
        encoder.emitByte(opcode)

      elif handlerId is X64_HANDLER_OPCODE_ONLY_BYTE
        # Single byte opcode without operands: xx
        # Just emit opcode as is.
        encoder.emitByte(opcode)

      elif handlerId is X64_HANDLER_OPCODE_ONLY_WORD
        # Two bytes opcode without operands: xx yy
        # Just emit opcode as is.
        encoder.emitWord(opcode)

      elif handlerId is X64_HANDLER_OPCODE_ONLY_0F_XX_YY
        # Three bytes opcode without operands: 0f xx yy
        # Just emit opcode as is.
        encoder.emitByte(0x0f)
        encoder.emitWord(opcode)

      elif handlerId is X64_HANDLER_CORE_ALU1
        if reg is -1
          # not/neg/mul/div/imul/idiv m
          encoder.emitCore_unaryGroup_m(opcode, regBase, scale, regIndex, disp, dataSize)
        else
          # not/neg/mul/div/imul/idiv r
          encoder.emitCore_unaryGroup_r(opcode, reg)
        endif

      elif handlerId is X64_HANDLER_CORE_ALU2
        this.emitCoreALU2(opcode, item)

      elif handlerId is X64_HANDLER_CORE2
        this.emitCore_x_y(opcode, item)

      elif handlerId is X64_HANDLER_JCC
        # jcc rel8/32
        encoder.emitCore_jcc_rel(opcode, imm - item.offset)

      elif handlerId is X64_HANDLER_JUMPS_REL8
        # One byte jump with rel8 always.
        # loopz rel8 like.
        encoder.emitCore_jmp_rel8(opcode, imm - item.offset - 2)

      elif handlerId is X64_HANDLER_JUMPS_REL8_2BYTES
        # One byte jump with rel8 always and 0x67 prefix.
        # loopz rel8 like.
        # TODO: Clean up this mess.
        encoder.emitByte(0x67)
        encoder.emitCore_jmp_rel8(opcode, imm - item.offset - 3)

      elif handlerId is X64_HANDLER_286
        if scale is defined
          # r,m
          encoder.emitCore286_r_m(opcode, reg, regBase, scale, regIndex, disp)
        else
          # r,r
          encoder.emitCore286_r_r(opcode, reg, rm)
        endif

      elif handlerId is X64_HANDLER_0F_00_GROUP
        # 0f 00 /x
        if scale is defined
          # m
          encoder.emitCore_group0f_00_m(opcode, regBase, scale, regIndex, disp)
        else
          # r
          encoder.emitCore_group0f_00_r(opcode, reg)
        endif

      elif handlerId is X64_HANDLER_0F_01_GROUP
        # 0f 01 /x
        if scale is defined
          # m
          encoder.emitCore_group0f_01_m(opcode, regBase, scale, regIndex, disp)
        else
          # r
          encoder.emitCore_group0f_01_r(opcode, reg)
        endif

      elif handlerId is X64_HANDLER_SHIFT_GROUP
        if scale is defined
          if imm is defined
            # m, imm8
            encoder.emitCore_shiftGroup_m_imm8(opcode, regBase, scale, regIndex, disp, imm, dataSize)
          else
            # m, cl
            encoder.emitCore_shiftGroup_m_cl(opcode, regBase, scale, regIndex, disp, dataSize)
          endif

        elif imm is defined
          # r, imm8
          encoder.emitCore_shiftGroup_r_imm8(opcode, reg, imm)
        else
          # r, cl
          encoder.emitCore_shiftGroup_r_cl(opcode, reg)
        endif

      elif handlerId is X64_HANDLER_SETCC
        if scale is defined
          # setcc m8
          encoder.emitCore_m(opcode, regBase, scale, regIndex, disp)
        else
          # setcc r8
          encoder.emitCore_r(opcode, reg)
        endif

      elif handlerId is X64_HANDLER_MOV_EXTEND
        if scale is defined
          # movsx r16/32/64, m8/16
          # movzx r16/32/64, m8/16
          if dataSize is 2
            opcode = bitor(opcode, 256)
          endif
          encoder.emitCore_movExtend_r_m(opcode, reg, regBase, scale, regIndex, disp)

        else
          # movsx r16/32/64, r8/16
          # movzx r16/32/64, r8/16
          encoder.emitCore_movExtend_r_r(opcode, reg, rm)
        endif

      elif handlerId is X64_HANDLER_DO_NOTHING
        # Do nothing.

      elif handlerId is X64_HANDLER_CUSTOM_X_Y
        # Custom handler for two operands opcode
        # opcode x,y
        if opcode is X64_MOV
          if imm is defined
            if reg isnt -1
              # mov r, imm
              encoder.mov_r_imm(reg, imm)
            else
              # mov m, imm
              encoder.mov_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
            endif
          else
            this.emitCoreALU2(opcode, item)
          endif

        elif opcode is X64_LEA
          encoder.lea_r_m(reg, regBase, scale, regIndex, disp)

        elif opcode is X64_TEST
          if imm is defined
            if reg isnt -1
              # test r, imm
              encoder.test_r_imm(reg, imm)
            else
              # test m, imm
              encoder.test_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
            endif
          else
            # Opcodes have fixed diretion flag, but other assemblers accept both and
            # swap operands silently if needed.
            # Only test r/m, r/imm exists.
            item.isWriteToMemory = true
            this.emitCoreALU2(opcode, item)
          endif

        elif opcode is X64_XCHG
          if (reg isnt -1) and (rm isnt -1)
            # xchg r, r
            encoder.xchg_r_r(reg, rm)
          else
            # Opcodes have fixed diretion flag, but other assemblers accept both and
            # swap operands silently if needed.
            # Only xchg r, r/m exists.
            item.isWriteToMemory = false
            this.emitCoreALU2(opcode, item)
          endif

        elif opcode is X64_OUT
          if imm is defined
            encoder.out_imm_r(imm, reg)
          else
            encoder.out_r_r(reg, rm)
          endif

        elif opcode is X64_IN
          if imm is defined
            encoder.in_r_imm(reg, imm)
          else
            encoder.in_r_r(reg, rm)
          endif

        elif opcode is X64_LSL
          this.emitCore_x_y(opcode, item)

        elif opcode is X64_MOVSXD
          this.emitCore_x_y(opcode, item)
        endif

      elif handlerId is X64_HANDLER_CUSTOM_X
        # Custom handler for one operand opcode
        # opcode x
        if opcode is X64_PUSH_R64
          if reg isnt -1
            # push r
            encoder.push_r(reg)

          elif imm is defined
            if (imm >= -127) and (imm <= 128)
              # push imm8
              encoder.push_imm8(imm)
            else
              # push imm32
              encoder.push_imm32(imm)
             endif
          else
            # push m
            encoder.push_m(regBase, scale, regIndex, disp, dataSize)
          endif

        elif opcode is X64_POP_R64
          if reg isnt -1
            encoder.pop_r(reg)
          else
            encoder.pop_m(regBase, scale, regIndex, disp, dataSize)
          endif

        elif opcode is X64_CALL_REL32
          if reg isnt -1
            # call r
            encoder.call_r(reg)

          elif scale is defined
            # call m
            encoder.call_m(regBase, scale, regIndex, disp, dataSize)

          else
            # call rel32
            encoder.call_rel(imm - item.offset)
          endif

        elif opcode is X64_JMP_REL32
          if reg isnt -1
            # jmp r
            encoder.jmp_r(reg)
          elif scale is defined
            # jmp m
            encoder.jmp_m(regBase, scale, regIndex, disp, dataSize)
          else
            # jmp rel8/32
            encoder.jmp_rel(imm - item.offset)
          endif

        elif opcode is X64_BSWAP
          encoder.bswap_r(reg)

        elif opcode is X64_CMPXCHG8B
          # TODO: Don't compare strings.
          if mnemonic is 'cmpxchg8b'
            encoder.cmpxchg8b_m(regBase, scale, regIndex, disp)
          else
            encoder.cmpxchg16b_m(regBase, scale, regIndex, disp)
          endif

        elif opcode is X64_INC_R32
          if reg isnt -1
            # inc r
            encoder.inc_r(reg)
          else
            # inc m
            encoder.inc_m(regBase, scale, regIndex, disp, dataSize)
          endif

        elif opcode is X64_DEC_R32
          if reg isnt -1
            # dec r
            encoder.dec_r(reg)
          else
            # dec m
            encoder.dec_m(regBase, scale, regIndex, disp, dataSize)
          endif

        elif opcode is X64_INT
          # int imm8
          encoder.int_imm(imm)
        endif

      elif handlerId is X64_HANDLER_CUSTOM
        # Custom handler for opcodes with variable numberof operands.
        # Dispatch opcode.
        if opcode is X64_RET
          if imm is defined
            encoder.ret_imm(imm)
          else
            encoder.ret()
          endif

        elif opcode is X64_RETF
          if imm is defined
            encoder.retf_imm(imm)
          else
            encoder.retf()
          endif

        elif opcode is X64_ENTER
          # enter imm16, imm8
          encoder.enter_imm16_imm8(imm, item.imm2)

        elif opcode is X64_NOP
          if scale is defined
            # nop m
            encoder.nop_m(regBase, scale, regIndex, disp, dataSize)
          elif reg isnt -1
            # nop r
            encoder.nop_r(reg)
          else
           # One byte nop.
           encoder.nop()
          endif
        endif

      elif handlerId is X64_HANDLER_INVALID_IN_64
        # Instruction is correct, but not allowed in native 64-bit mode.
        die("error: not allowed in long mode: '" + mnemonic + "'")

      else
        # Error - unexpected handler id.
        # Should never happen on production.
        die('error: unknown opcode handler: ' + str(handlerId))
      endif

    elif item.type is 'label'
      # Collect label positions.
      this.labelsMap[item.name] = encoder.getCurrentPosition()

    elif item.type is 'data'
      if item.dataSize is 1
        encoder.emitByte(item.imm)
      elif item.dataSize is 2
        encoder.emitWord(item.imm)
      elif item.dataSize is 4
        encoder.emitDword(item.imm)
      elif item.dataSize is 8
        encoder.emitQword(item.imm)
      endif
    endif
  endmethod

  method getCurrentPosition() -> rv
    # TODO: Clean up this mess.
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass
