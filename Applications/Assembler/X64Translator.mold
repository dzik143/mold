################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Compiler/Utils/PipeAbstract.mold'

# Opcodes, that exists, but are invalid in 64-bit mode.
X64_POOL_OF_MNEMONICS_INVALID64 = [
  'das'   , 'aas'  , 'bound'  , 'sahf'  , 'lahf',
  'les'   , 'lds'  , 'aam'    , 'aad'   , 'arpl',
  'pusha' , 'popa' , 'pushad' , 'popad' , 'pushfd' , 'popfd'
]

# Opcodes, that does not require any operands.
# We can emit them as is.
X64_OPCODES_MAP0 = {
  'cbw':  X64_CWDE * 256 + X64_PREFIX_OPERAND_SIZE,
  'cwde': X64_CWDE,
  'cdqe': X64_CWDE * 256 + X64_PREFIX_REX_W,

  'cwd': X64_CDQ * 256 + X64_PREFIX_OPERAND_SIZE,
  'cdq': X64_CDQ,
  'cqo': X64_CDQ * 256 + X64_PREFIX_REX_W,

  'clc': X64_CLC,
  'cld': X64_CLD,
  'cli': X64_CLI,
  'stc': X64_STC,
  'std': X64_STD,
  'sti': X64_STI,
  'cmc': X64_CMC,

  'cmpsb': X64_CMPSB,
  'cmpsw': X64_CMPSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'cmpsd': X64_CMPSD,
  'cmpsq': X64_CMPSD * 256 + X64_PREFIX_REX_W,

  'movsb': X64_MOVSB,
  'movsw': X64_MOVSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'movsd': X64_MOVSD,
  'movsq': X64_MOVSD * 256 + X64_PREFIX_REX_W,

  'lodsb': X64_LODSB,
  'lodsw': X64_LODSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'lodsd': X64_LODSD,
  'lodsq': X64_LODSD * 256 + X64_PREFIX_REX_W,

  'stosb': X64_STOSB,
  'stosw': X64_STOSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'stosd': X64_STOSD,
  'stosq': X64_STOSD * 256 + X64_PREFIX_REX_W,

  'scasb': X64_SCASB,
  'scasw': X64_SCASD * 256 + X64_PREFIX_OPERAND_SIZE,
  'scasd': X64_SCASD,
  'scasq': X64_SCASD * 256 + X64_PREFIX_REX_W,

  'insb' : X64_INSB,
  'insw' : X64_INSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'insd' : X64_INSD,

  'outsb': X64_OUTSB,
  'outsw': X64_OUTSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'outsd': X64_OUTSD,

  'rep':   X64_PREFIX_REPE,
  'repe':  X64_PREFIX_REPE,
  'repz':  X64_PREFIX_REPE,
  'repne': X64_PREFIX_REPNE,
  'repnz': X64_PREFIX_REPNE,

  'hlt':  X64_HLT,
  'lock': X64_PREFIX_LOCK,
  'xlatb': X64_XLAT,

  'into':  X64_INTO,
  'int1':  X64_INT1,
  'int3':  X64_INT3,
  'iret':  X64_IRET,
  'iretd': X64_IRET,
  'iretq': X64_IRET * 256 + X64_PREFIX_REX_W,

  'pushf':  X64_PUSHF,
  'pushfw': X64_PUSHF * 256 + X64_PREFIX_OPERAND_SIZE,
  'pushfq': X64_PUSHF,

  'popf':   X64_POPF,
  'popfw':  X64_POPF  * 256 + X64_PREFIX_OPERAND_SIZE,
  'popfq':  X64_POPF,

  'leave':  X64_LEAVE,
  'wait':   X64_FWAIT,
  'fwait':  X64_FWAIT,
  'clts':   X64_CLTS,
  'cpuid':  X64_CPUID,
  'wrmsr':  X64_WRMSR,
  'rdtsc':  X64_RDTSC,
  'rdmsr':  X64_RDMSR,
  'rdpmc':  X64_RDPMC,
  'rdtscp': X64_RDTSCP,
  'rsm':    X64_RSM,
  'invd':   X64_INVD,
  'wbinvd': X64_WBINVD,
  'clts':   X64_CLTS,

  'syscall':  X64_SYSCALL,
  'sysret':   X64_SYSRET,
  'sysenter': X64_SYSENTER,
  'sysexit':  X64_SYSEXIT,
  'swapgs':   X64_SWAPGS,
  'ud2':      X64_UD2
}

X64_OPCODES_MAP_CORE_ALU2 = {
  'adc':  X64_ADC,
  'add':  X64_ADD,
  'and':  X64_AND,
  'cmp':  X64_CMP,
  'sbb':  X64_SBB,
  'sub':  X64_SUB,
  'or':   X64_OR,
  'xor':  X64_XOR,
  'mov':  X64_MOV_RM8_R8,
  'test': X64_TEST_RM8_R8,
  'xchg': X64_XCHG_RM8_R8,
  'bt':   X64_BT_RM_R,
  'btc':  X64_BTC_RM_R,
  'btr':  X64_BTR_RM_R,
  'bts':  X64_BTS_RM_R,
  'cmpxchg': X64_CMPXCHG_RM8_R8,
  'xadd':    X64_XADD_RM8_R8
}

# TODO: Review it.
X64_OPCODES_MAP_CORE2 = {
  'bsf':     X64_BSF,
  'bsr':     X64_BSR,
  'cmovo':   X64_CMOVO,
  'cmovno':  X64_CMOVNO,
  'cmovb':   X64_CMOVB,
  'cmovnae': X64_CMOVB,
  'cmovc':   X64_CMOVB,
  'cmovnb':  X64_CMOVAE,
  'cmovae':  X64_CMOVAE,
  'cmovnc':  X64_CMOVAE,
  'cmovz':   X64_CMOVE,
  'cmove':   X64_CMOVE,
  'cmovnz':  X64_CMOVNE,
  'cmovne':  X64_CMOVNE,
  'cmovbe':  X64_CMOVBE,
  'cmovna':  X64_CMOVBE,
  'cmovnbe': X64_CMOVA,
  'cmova':   X64_CMOVA,
  'cmovs':   X64_CMOVS,
  'cmovns':  X64_CMOVNS,
  'cmovp':   X64_CMOVP,
  'cmovpe':  X64_CMOVP,
  'cmovnp':  X64_CMOVNP,
  'cmovpo':  X64_CMOVNP,
  'cmovl':   X64_CMOVL,
  'cmovnge': X64_CMOVL,
  'cmovge':  X64_CMOVGE,
  'cmovnl':  X64_CMOVGE,
  'cmovle':  X64_CMOVLE,
  'cmovng':  X64_CMOVLE,
  'cmovnle': X64_CMOVG,
  'cmovg':   X64_CMOVG,
  'lsl':     X64_LSL
}

X64_OPCODES_MAP_UNARY_GROUP = {
  'not': 2,
  'neg': 3,
  'mul': 4,
  'imul': 5,
  'div': 6,
  'idiv': 7
}

X64_OPCODES_MAP_286_RD_MD = {
  'lar': X64_LAR,
  'lss': X64_LSS,
  'lfs': X64_LFS,
  'lgs': X64_LGS
}

X64_OPCODES_MAP_0F_00_GROUP = {
  'sldt': 0,
  'str':  1,
  'lldt': 2,
  'ltr':  3,
  'verr': 4,
  'verw': 5
}

X64_OPCODES_MAP_0F_01_GROUP = {
  'sgdt': 0,
  'sidt': 1,
  'lgdt': 2,
  'lidt': 3,
  'smsw': 4,
  'lmsw': 6,
  'invlpg': 7
}

X64_OPCODES_JUMPS = {
  'call': X64_CALL_REL32,
  'jo':   X64_JO,
  'jno':  X64_JNO,
  'jb':   X64_JB,
  'jae':  X64_JAE,
  'jz':   X64_JZ,
  'je':   X64_JZ,
  'jnz':  X64_JNZ,
  'jne':  X64_JNZ,
  'jbe':  X64_JBE,
  'ja':   X64_JA,
  'js':   X64_JS,
  'jns':  X64_JNS,
  'jp':   X64_JP,
  'jnp':  X64_JNP,
  'jl':   X64_JL,
  'jge':  X64_JGE,
  'jle':  X64_JLE,
  'jg':   X64_JG,
  'jmp':  X64_JMP_REL32
}

X64_OPCODES_1BYTE_JUMPS_REL8 = {
  'loop':   X64_LOOP_REL8,
  'loopz':  X64_LOOPZ_REL8,
  'loopnz': X64_LOOPNZ_REL8,
  'loope':  X64_LOOPZ_REL8,
  'loopne': X64_LOOPNZ_REL8,
  'jrcxz':  X64_JRCXZ_REL8
}

X64_OPCODES_MAP_SHIFT_GROUP = {
  'rol': 0,
  'ror': 1,
  'rcl': 2,
  'rcr': 3,
  'shl': 4,
  'sal': 4,
  'shr': 5,
  'sar': 7
}

X64_OPCODES_MAP_SETCC = {
  'seto':   X64_SETO,
  'setno':  X64_SETNO,
  'setb':   X64_SETB,
  'setnae': X64_SETB,
  'setc':   X64_SETB,
  'setnb':  X64_SETAE,
  'setae':  X64_SETAE,
  'setnc':  X64_SETAE,
  'setz':   X64_SETE,
  'sete':   X64_SETE,
  'setnz':  X64_SETNE,
  'setne':  X64_SETNE,
  'setbe':  X64_SETBE,
  'setna':  X64_SETBE,
  'setnbe': X64_SETA,
  'seta':   X64_SETA,
  'sets':   X64_SETS,
  'setns':  X64_SETNS,
  'setp':   X64_SETP,
  'setpe':  X64_SETP,
  'setnp':  X64_SETNP,
  'setpo':  X64_SETNP,
  'setl':   X64_SETL,
  'setnge': X64_SETL,
  'setge':  X64_SETGE,
  'setnl':  X64_SETGE,
  'setle':  X64_SETLE,
  'setng':  X64_SETLE,
  'setnle': X64_SETG,
  'setg':   X64_SETG
}

class X64Translator extends PipeAbstract
  method emitCore_x_y(opcode, item)
    emiter   = this.outputObject
    reg      = item.reg
    regBase  = item.base
    regIndex = item.index
    disp     = item.disp
    scale    = item.scale

    if item.imm is defined
      if reg isnt -1
        # opcode r, imm
        emiter.emitCore_r_imm(opcode, reg, item.imm)
      else
        # opcode m, imm
        emiter.emitCore_m_imm(
          opcode, regBase, scale, regIndex, disp, item.imm, item.dataSize)
      endif

    elif reg isnt -1
      if item.rm isnt -1
        # opcode r, r
        regSrc = item.rm
        emiter.emitCore_r_r(opcode, reg, regSrc)

      elif item.scale is defined
        # opcode r, m
        # opcode m, r
        # opcode m, imm
        if item.imm is defined
          emiter.emitCore_m_imm(opcode, regBase, scale, regIndex, disp, item.imm)

        elif item.isWriteToMemory is true
          emiter.emitCore_m_r(opcode, regBase, scale, regIndex, disp, reg)

        else
          emiter.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)
        endif
      endif
    endif
  endmethod

  method processOneItem(item)
    global X64_OPCODES_MAP0
    global X64_OPCODES_MAP_CORE_ALU2
    global X64_OPCODES_MAP_UNARY_GROUP
    global X64_TEST_RM8_R8
    global X64_OPCODES_JUMPS
    global X64_OPCODES_1BYTE_JUMPS_REL8
    global X64_OPCODES_MAP_CORE2
    global X64_OPCODES_MAP_0F_00_GROUP
    global X64_OPCODES_MAP_0F_01_GROUP
    global X64_OPCODES_MAP_286_RD_MD
    global X64_OPCODES_MAP_SHIFT_GROUP
    global X64_OPCODES_MAP_SETCC
    global X64_CMPXCHG_RM8_R8, X64_CMPXCHG_RM32_R32
    global X64_XADD_RM8_R8, X64_XADD_RM32_R32

    #print item

    encoder = this.outputObject

    if item.type is 'label'
      # Collect label positions.
      this.labelsMap[item.name] = encoder.getCurrentPosition()

    elif item.type is 'instruction'
      # Parse one code line.
      mnemonic = item.mnemonic
      opcode   = X64_OPCODES_MAP0[mnemonic]

      reg      = item.reg
      rm       = item.rm
      regBase  = item.base
      regIndex = item.index
      disp     = item.disp
      scale    = item.scale
      imm      = item.imm

      #print item #'[', mnemonic, item.reg, item.rm, item.imm, ']'

      if opcode is defined
        # Recognized no-operands opcode.
        # Just emit opcode as is.
        if opcode < 256
          encoder.emitByte(opcode)
        elif opcode < 65536
          encoder.emitWord(opcode)
        else
          encoder.emitByte(0x0f)
          encoder.emitWord(opcode // 256)
        endif

      elif (imm is defined) and (mnemonic is 'mov')
        if reg isnt -1
          # mov r, imm
          encoder.mov_r_imm(reg, imm)
        else
          # mov m, imm
          encoder.mov_m_imm(regBase, scale, regIndex, disp, imm, item.dataSize)
        endif

      elif mnemonic is 'lea'
        encoder.lea_r_m(reg, regBase, scale, regIndex, disp)

      elif (imm is defined) and (mnemonic is 'test')
        if reg isnt -1
          # test r, imm
          encoder.test_r_imm(reg, imm)
        else
          # test m, imm
          encoder.test_m_imm(regBase, scale, regIndex, disp, imm, item.dataSize)
        endif

      elif mnemonic is 'push'
        if reg isnt -1
          # push r
          encoder.push_r(reg)

        elif imm is defined
          if (imm >= -127) and (imm <= 128)
            # push imm8
            encoder.push_imm8(imm)
          else
            # push imm32
            encoder.push_imm32(imm)
           endif
        else
          # push m
          encoder.push_m(regBase, scale, regIndex, disp, item.dataSize)
        endif

      elif mnemonic is 'pop'
        if reg isnt -1
          encoder.pop_r(reg)
        else
          encoder.pop_m(regBase, scale, regIndex, disp, item.dataSize)
        endif

      elif (mnemonic is 'xchg') and (reg isnt -1) and (rm isnt -1)
        # xchg r, r
        encoder.xchg_r_r(reg, rm)

      elif mnemonic is 'call'
        if item.scale is defined
          encoder.call_m(regBase, scale, regIndex, disp)
        else
          encoder.call_rel(imm - item.offset)
        endif

      elif mnemonic is 'jmp'
        encoder.jmp_rel(imm - item.offset)

      elif mnemonic is 'jecxz'
        encoder.jecxz_rel(imm - item.offset)

      elif mnemonic is 'ret'
        if imm is defined
          encoder.ret_imm(imm)
        else
          encoder.ret()
        endif

      elif mnemonic is 'retf'
        if imm is defined
          encoder.retf_imm(imm)
        else
          encoder.retf()
        endif

      elif mnemonic is 'leave'
        # Handle two immediates at one opcode.
        die('not implemented: leave imm16, imm8')

      elif mnemonic is 'movsxd'
        if (reg isnt -1) and (rm isnt -1)
          # movsxd r64, r32
          encoder.movsxd_r64_r32(reg, rm)
        else
          # movsxd r64, m32
          encoder.movsxd_r64_m32(reg, regBase, scale, regIndex, disp)
        endif

      elif mnemonic is 'out'
        if imm is defined
          encoder.out_imm_r(imm, reg)
        else
          encoder.out_r_r(reg, rm)
        endif

      elif mnemonic is 'in'
        if imm is defined
          encoder.in_r_imm(reg, imm)
        else
          encoder.in_r_r(reg, rm)
        endif

      elif mnemonic is 'bswap'
        encoder.bswap_r(reg)

      elif mnemonic is 'cmpxchg8b'
        encoder.cmpxchg8b_m(regBase, scale, regIndex, disp)

      elif mnemonic is 'cmpxchg16b'
        encoder.cmpxchg16b_m(regBase, scale, regIndex, disp)

      elif mnemonic is 'inc'
        if reg isnt -1
          # inc r
          encoder.inc_r(reg)
        else
          # inc m
          encoder.inc_m(regBase, scale, regIndex, disp, item.dataSize)
        endif

      elif mnemonic is 'dec'
        if reg isnt -1
          # dec r
          encoder.dec_r(reg)
        else
          # dec m
          encoder.dec_m(regBase, scale, regIndex, disp, item.dataSize)
        endif

      elif mnemonic is 'enter'
        # enter imm16, imm8
        encoder.enter_imm16_imm8(imm, item.imm2)

      elif mnemonic is 'int'
        # int imm8
        encoder.int_imm(imm)

      elif mnemonic is 'lar'
        if (reg isnt -1) and (rm isnt -1)
          # lar r,r
          encoder.lar_r_r(reg, rm)
        else
          # lar r,m
          encoder.lar_r_m16(reg, regBase, scale, regIndex, disp)
        endif

      elif mnemonic is 'movsx'
        if scale is defined
          if item.dataSize is 1
            # movsx r16/32/64, m8
            encoder.movsx_r_m8(reg, regBase, scale, regIndex, disp)
          else
            # movsx r16/32/64, m16
            encoder.movsx_r_m16(reg, regBase, scale, regIndex, disp)
          endif
        else
          # movsx r16/32/64, r8/16
          encoder.movsx_r_r(reg, rm)
        endif

      elif mnemonic is 'movzx'
        if scale is defined
          if item.dataSize is 1
            # movsx r16/32/64, m8
            encoder.movzx_r_m8(reg, regBase, scale, regIndex, disp)
          else
            # movsx r16/32/64, m16
            encoder.movzx_r_m16(reg, regBase, scale, regIndex, disp)
          endif
        else
          # movsx r16/32/64, r8/16
          encoder.movzx_r_r(reg, rm)
        endif

      else
        opcode = X64_OPCODES_MAP_CORE_ALU2[mnemonic]

        if opcode is defined
          # Recognized common two-operands opcode.
          if imm is undefined
            if (X64_IsReg8(reg) is true) or (item.dataSize is 1)
              # 8-bit operands. Do nothing.

            elif opcode < 256
              # Set size bit in primary opcode to enable operands
              # greater than 8-bit.
              # This is old encoding pattern from original 8086 processor.
              opcode = opcode + 1

            else
              # 2-byte opcode. Primary opcode is in the higher byte.
              opcode = bitor(opcode, 256)
            endif
          endif

          # Special case for test and xchg.
          # These opcodes have fixed diretion flag, but other assemblers accept both and
          # swap operands silently if needed.
          if mnemonic is 'test'
            # Only test r/m, r/imm exists.
            item.isWriteToMemory = true

          elif mnemonic is 'xchg'
            # Only xchg r, r/m exists.
            item.isWriteToMemory = false
          endif

          # Generic two operands handler.
          this.emitCore_x_y(opcode, item)

        elif mnemonic is 'nop'
          if scale is defined
            # nop m
            encoder.nop_m(regBase, scale, regIndex, disp, item.dataSize)
          elif reg isnt -1
            # nop r
            encoder.nop_r(reg)
          else
           # One byte nop.
           encoder.nop()
          endif

        else
          operationId = X64_OPCODES_MAP_UNARY_GROUP[mnemonic]

          if operationId is defined
            if reg is -1
              # not/neg/mul/div/imul/idiv m
              encoder.emitCore_unaryGroup_m(
                operationId, regBase, scale, regIndex, disp, item.dataSize)
            else
              # not/neg/mul/div/imul/idiv r
              encoder.emitCore_unaryGroup_r(operationId, reg)
            endif

          else
            opcode = X64_OPCODES_JUMPS[mnemonic]

            if opcode is defined
              # jxx rel8/32
              encoder.emitCore_jxx_rel(opcode, imm - item.offset)

            else
              opcode = X64_OPCODES_1BYTE_JUMPS_REL8[mnemonic]

              if opcode is defined
                # One byte jump with rel8 always.
                # loopz rel8 like.
                encoder.emitCore_jmp_rel8(opcode, imm - item.offset - 2)

              else
                opcode = X64_OPCODES_MAP_CORE2[mnemonic]

                if opcode is defined
                  # TODO: Review it.
                  # Why we need to swap regs here?
                  if (reg isnt -1) and (item.rm isnt -1)
                    item.reg = rm
                    item.rm  = reg
                  endif

                  this.emitCore_x_y(opcode, item)

                else
                  # 0f 00 /x
                  operationId = X64_OPCODES_MAP_0F_00_GROUP[mnemonic]

                  if operationId is defined
                    if scale is defined
                      # m
                      encoder.emitCore_group0f_00_m(operationId, regBase, scale, regIndex, disp)
                    else
                      # r
                      encoder.emitCore_group0f_00_r(operationId, reg)
                    endif

                  else
                    # 0f 01 /x
                    operationId = X64_OPCODES_MAP_0F_01_GROUP[mnemonic]

                    if operationId is defined
                      if scale is defined
                        # m
                        encoder.emitCore_group0f_01_m(operationId, regBase, scale, regIndex, disp)
                      else
                        # r
                        encoder.emitCore_group0f_01_r(operationId, reg)
                      endif


                    else
                      opcode = X64_OPCODES_MAP_286_RD_MD[mnemonic]

                      if opcode is defined
                        encoder.emitCore286_r_m(opcode, reg, regBase, scale, regIndex, disp)

                      else
                        operationId = X64_OPCODES_MAP_SHIFT_GROUP[mnemonic]
                        if operationId is defined
                          if scale is defined

                            if imm is defined
                              # m, imm8
                              encoder.emitCore_shiftGroup_m_imm8(operationId, regBase, scale, regIndex, disp, imm, item.dataSize)
                            else
                              # m, cl
                              encoder.emitCore_shiftGroup_m_cl(operationId, regBase, scale, regIndex, disp, item.dataSize)
                            endif

                          else
                            if imm is defined
                              # r, imm8
                              encoder.emitCore_shiftGroup_r_imm8(operationId, reg, imm)
                            else
                              # r, cl
                              encoder.emitCore_shiftGroup_r_cl(operationId, reg)
                            endif
                          endif

                        else
                          opcode = X64_OPCODES_MAP_SETCC[mnemonic]

                          if opcode is defined
                            if scale is defined
                              # setcc m8
                              encoder.emitCore_m(opcode, regBase, scale, regIndex, disp)
                            else
                              # setcc r8
                              encoder.emitCore_r(opcode, reg)
                            endif

                          elif mnemonic is 'use64'
                           # Nothing to do.

                          else
                            die("error: invalid instruction: '" + mnemonic + "'")
                          endif
                        endif
                      endif
                    endif
                  endif
                endif
              endif
            endif
          endif
        endif
      endif

    elif item.type is 'data'
      if item.dataSize is 1
        encoder.emitByte(item.imm)
      elif item.dataSize is 2
        encoder.emitWord(item.imm)
      elif item.dataSize is 4
        encoder.emitDword(item.imm)
      elif item.dataSize is 8
        encoder.emitQword(item.imm)
      endif
    endif
  endmethod

  method getCurrentPosition() -> rv
    # TODO: Clean up this mess.
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass
