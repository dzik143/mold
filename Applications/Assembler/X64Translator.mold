################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Compiler/Utils/PipeAbstract.mold'

# Encoding handlers: no operands (opcode only).
X64_HANDLER_OPCODE_ONLY_BYTE       = 0x00000000
X64_HANDLER_OPCODE_ONLY_WORD       = 0x01000000
X64_HANDLER_OPCODE_ONLY_3BYTES     = 0x02000000
X64_HANDLER_OPCODE_ONLY_0F_XX_YY   = 0x03000000

# Encoding handlers: one operands (read only).
X64_HANDLER_JCC                  = 0x10000000
X64_HANDLER_JUMPS_REL8           = 0x11000000
X64_HANDLER_JUMPS_REL8_2BYTES    = 0x12000000
X64_HANDLER_CUSTOM_X             = 0x13000000

# Encoding handlers: two operands with equal size.
X64_HANDLER_CORE_ALU2            = 0x20000000
X64_HANDLER_CMOVCC               = 0x21000000
X64_HANDLER_CORE_RMD_RD          = 0x22000000
X64_HANDLER_CORE_RM_R            = 0x23000000
X64_HANDLER_FPU_ST0_STI          = 0x24000000

# Encoding handler: two operands (generic).
X64_HANDLER_SHIFT_GROUP          = 0x30000000
X64_HANDLER_MOV_EXTEND           = 0x31000000
X64_HANDLER_286                  = 0x32000000
X64_HANDLER_CUSTOM_X_Y           = 0x33000000

# Encoding handlers: one operands (read/write).
X64_HANDLER_CORE_ALU1            = 0x40000000
X64_HANDLER_0F_00_GROUP          = 0x41000000
X64_HANDLER_0F_01_GROUP          = 0x42000000
X64_HANDLER_SETCC                = 0x43000000

# Other.
X64_HANDLER_FPU_STI              = 0xfa000000
X64_HANDLER_FPU_MATH_FLOAT       = 0xfb000000
X64_HANDLER_FPU_MATH_FLOAT_POP   = 0xfc000000
X64_HANDLER_CUSTOM               = 0xfd000000
X64_HANDLER_DO_NOTHING           = 0xfe000000
X64_HANDLER_INVALID_IN_64        = 0xff000000

                 #  0 1 2 3 4 5 6 7 8 9 10 bytes
X64_DATA_SIZE_ID = [0,0,1,1,2,2,2,2,3,3,4]

# Common operands combinations for generic syntax checking.
X64_SYNTAX_ZERO_OPERANDS           = 0x00000000
X64_SYNTAX_ONE_OPERAND_READ_ONLY   = 0x10000000
X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE = 0x20000000
X64_SYNTAX_TWO_OPERANDS            = 0x30000000
X64_SYNTAX_ONE_OPERAND_READWRITE   = 0x40000000

# Opcodes, that does not require any operands.
# We can emit them as is.
X64_OPCODES_MAP = {
  'use64':      X64_HANDLER_DO_NOTHING,

  'aaa':        X64_HANDLER_INVALID_IN_64,
  'aad':        X64_HANDLER_INVALID_IN_64,
  'aam':        X64_HANDLER_INVALID_IN_64,
  'lahf':       X64_HANDLER_INVALID_IN_64,
  'aas':        X64_HANDLER_INVALID_IN_64,
  'das':        X64_HANDLER_INVALID_IN_64,
  'sahf':       X64_HANDLER_INVALID_IN_64,
  'lds':        X64_HANDLER_INVALID_IN_64,
  'les':        X64_HANDLER_INVALID_IN_64,
  'daa':        X64_HANDLER_INVALID_IN_64,
  'into':       X64_HANDLER_INVALID_IN_64,
  'bound':      X64_HANDLER_INVALID_IN_64,
  'popa':       X64_HANDLER_INVALID_IN_64,
  'pusha':      X64_HANDLER_INVALID_IN_64,
  'arpl':       X64_HANDLER_INVALID_IN_64,
  'loadall':    X64_HANDLER_INVALID_IN_64,
  'pushad':     X64_HANDLER_INVALID_IN_64,
  'popad':      X64_HANDLER_INVALID_IN_64,
  'pushfd':     X64_HANDLER_INVALID_IN_64,
  'popfd':      X64_HANDLER_INVALID_IN_64,
  'loadalld':   X64_HANDLER_INVALID_IN_64,
  'ibts':       X64_HANDLER_INVALID_IN_64,
  'xbts':       X64_HANDLER_INVALID_IN_64,

  'cwde':       X64_CWDE,  # - (no operands)
  'cdq':        X64_CDQ,   # - (no operands)

  'clc':        X64_CLC,   # - (no operands)
  'cld':        X64_CLD,   # - (no operands)
  'cli':        X64_CLI,   # - (no operands)
  'stc':        X64_STC,   # - (no operands)
  'std':        X64_STD,   # - (no operands)
  'sti':        X64_STI,   # - (no operands)
  'cmc':        X64_CMC,   # - (no operands)

  'cmpsb':      X64_CMPSB, # - (no operands)
  'cmpsd':      X64_CMPSD, # - (no operands)
  'movsb':      X64_MOVSB, # - (no operands)
  'movsd':      X64_MOVSD, # - (no operands)
  'lodsb':      X64_LODSB, # - (no operands)
  'lodsd':      X64_LODSD, # - (no operands)
  'stosb':      X64_STOSB, # - (no operands)
  'stosd':      X64_STOSD, # - (no operands)
  'scasb':      X64_SCASB, # - (no operands)
  'scasd':      X64_SCASD, # - (no operands)
  'insb' :      X64_INSB,  # - (no operands)
  'insd' :      X64_INSD,  # - (no operands)
  'outsb':      X64_OUTSB, # - (no operands)
  'outsd':      X64_OUTSD, # - (no operands)

  'rep':        X64_PREFIX_REPE, # - (no operands)
  'repe':       X64_PREFIX_REPE, # - (no operands)
  'repz':       X64_PREFIX_REPE, # - (no operands)
  'repne':      X64_PREFIX_REPNE,# - (no operands)
  'repnz':      X64_PREFIX_REPNE,# - (no operands)

  'hlt':        X64_HLT,         # - (no operands)
  'lock':       X64_PREFIX_LOCK, # - (no operands)
  'xlatb':      X64_XLATB,       # - (no operands)

  'int1':       X64_INT1,  # - (no operands)
  'int3':       X64_INT3,  # - (no operands)
  'iretd':      X64_IRET,  # - (no operands)

  'iretw':      X64_IRETW + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iret':       X64_IRETQ + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iretq':      X64_IRETQ + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)

  'pushf':      X64_PUSHF, # - (no operands)
  'pushfq':     X64_PUSHF, # - (no operands)
  'popf':       X64_POPF,  # - (no operands)
  'popfq':      X64_POPF,  # - (no operands)

  'leave':      X64_LEAVE, # - (no operands)
  'wait':       X64_WAIT,  # - (no operands)

  'cmpsw':      X64_CMPSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cmpsq':      X64_CMPSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'movsw':      X64_MOVSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'movsq':      X64_MOVSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'lodsw':      X64_LODSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'lodsq':      X64_LODSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'stosw':      X64_STOSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'stosq':      X64_STOSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'scasw':      X64_SCASW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'scasq':      X64_SCASQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'insw' :      X64_INSW     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'outsw':      X64_OUTSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cbw':        X64_CBW      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cdqe':       X64_CDQE     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cwd':        X64_CWD      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cqo':        X64_CQO      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iretq':      X64_IRETQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'pushfw':     X64_PUSHFW   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'popfw':      X64_POPFW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'clts':       X64_CLTS     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cpuid':      X64_CPUID    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'wrmsr':      X64_WRMSR    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdtsc':      X64_RDTSC    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdmsr':      X64_RDMSR    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdpmc':      X64_RDPMC    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rsm':        X64_RSM      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'invd':       X64_INVD     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'wbinvd':     X64_WBINVD   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'syscall':    X64_SYSCALL  + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysret':     X64_SYSRET   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysenter':   X64_SYSENTER + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysexit':    X64_SYSEXIT  + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'ud2':        X64_UD2      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)

  'rdtscp':     X64_RDTSCP + X64_HANDLER_OPCODE_ONLY_0F_XX_YY, # - (no operands)
  'swapgs':     X64_SWAPGS + X64_HANDLER_OPCODE_ONLY_0F_XX_YY, # - (no operands)

  'adc':        X64_ADC            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'add':        X64_ADD            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'and':        X64_AND            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'cmp':        X64_CMP            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'sbb':        X64_SBB            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'sub':        X64_SUB            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'or':         X64_OR             + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'xor':        X64_XOR            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm

  'bt':         X64_BT_RM_R        + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd
  'btc':        X64_BTC_RM_R       + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd
  'btr':        X64_BTR_RM_R       + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd
  'bts':        X64_BTS_RM_R       + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd

  'xadd':       X64_XADD_RM8_R8    + X64_HANDLER_CORE_RM_R, # r,r | m,r
  'cmpxchg':    X64_CMPXCHG_RM8_R8 + X64_HANDLER_CORE_RM_R, # r,r | m,r

  'cmovo':      X64_CMOVO   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovno':     X64_CMOVNO  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovb':      X64_CMOVB   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnae':    X64_CMOVB   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovc':      X64_CMOVB   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnb':     X64_CMOVAE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovae':     X64_CMOVAE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnc':     X64_CMOVAE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovz':      X64_CMOVE   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmove':      X64_CMOVE   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnz':     X64_CMOVNE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovne':     X64_CMOVNE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovbe':     X64_CMOVBE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovna':     X64_CMOVBE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnbe':    X64_CMOVA   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmova':      X64_CMOVA   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovs':      X64_CMOVS   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovns':     X64_CMOVNS  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovp':      X64_CMOVP   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovpe':     X64_CMOVP   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnp':     X64_CMOVNP  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovpo':     X64_CMOVNP  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovl':      X64_CMOVL   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnge':    X64_CMOVL   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovge':     X64_CMOVGE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnl':     X64_CMOVGE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovle':     X64_CMOVLE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovng':     X64_CMOVLE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnle':    X64_CMOVG   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovg':      X64_CMOVG   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'bsf':        X64_BSF     + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'bsr':        X64_BSR     + X64_HANDLER_CMOVCC, # rd,rd | rd,md

  'not':        2 + X64_HANDLER_CORE_ALU1, # r | m
  'neg':        3 + X64_HANDLER_CORE_ALU1, # r | m
  'mul':        4 + X64_HANDLER_CORE_ALU1, # r | m
  'imul':       5 + X64_HANDLER_CORE_ALU1, # r | m | rd,md | rd,md,imm
  'div':        6 + X64_HANDLER_CORE_ALU1, # r | m
  'idiv':       7 + X64_HANDLER_CORE_ALU1, # r | m

  'lar':        X64_LAR + X64_HANDLER_286, # rd,r16    | rd,m16
  'lss':        X64_LSS + X64_HANDLER_286, # rd,md-far
  'lfs':        X64_LFS + X64_HANDLER_286, # rd,md-far
  'lgs':        X64_LGS + X64_HANDLER_286, # rd,md-far

  'sldt':       0 + X64_HANDLER_0F_00_GROUP, # r16 | r64 | m16
  'str':        1 + X64_HANDLER_0F_00_GROUP, # rd  | m16
  'lldt':       2 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'ltr':        3 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'verr':       4 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'verw':       5 + X64_HANDLER_0F_00_GROUP, # r16 | m16

  'sgdt':       0 + X64_HANDLER_0F_01_GROUP, # m80
  'sidt':       1 + X64_HANDLER_0F_01_GROUP, # m80
  'lgdt':       2 + X64_HANDLER_0F_01_GROUP, # m48
  'lidt':       3 + X64_HANDLER_0F_01_GROUP, # m48
  'smsw':       4 + X64_HANDLER_0F_01_GROUP, # rd | m16
  'lmsw':       6 + X64_HANDLER_0F_01_GROUP, # rd | m16
  'invlpg':     7 + X64_HANDLER_0F_01_GROUP, # m

  'jo':         X64_JO  + X64_HANDLER_JCC, # rel8 | rel32
  'jno':        X64_JNO + X64_HANDLER_JCC, # rel8 | rel32
  'jb':         X64_JB  + X64_HANDLER_JCC, # rel8 | rel32
  'jae':        X64_JAE + X64_HANDLER_JCC, # rel8 | rel32
  'jz':         X64_JZ  + X64_HANDLER_JCC, # rel8 | rel32
  'je':         X64_JZ  + X64_HANDLER_JCC, # rel8 | rel32
  'jnz':        X64_JNZ + X64_HANDLER_JCC, # rel8 | rel32
  'jne':        X64_JNZ + X64_HANDLER_JCC, # rel8 | rel32
  'jbe':        X64_JBE + X64_HANDLER_JCC, # rel8 | rel32
  'ja':         X64_JA  + X64_HANDLER_JCC, # rel8 | rel32
  'js':         X64_JS  + X64_HANDLER_JCC, # rel8 | rel32
  'jns':        X64_JNS + X64_HANDLER_JCC, # rel8 | rel32
  'jp':         X64_JP  + X64_HANDLER_JCC, # rel8 | rel32
  'jnp':        X64_JNP + X64_HANDLER_JCC, # rel8 | rel32
  'jl':         X64_JL  + X64_HANDLER_JCC, # rel8 | rel32
  'jge':        X64_JGE + X64_HANDLER_JCC, # rel8 | rel32
  'jle':        X64_JLE + X64_HANDLER_JCC, # rel8 | rel32
  'jg':         X64_JG  + X64_HANDLER_JCC, # rel8 | rel32

  'loop':       X64_LOOP_REL8   + X64_HANDLER_JUMPS_REL8, # rel8
  'loopz':      X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8
  'loopnz':     X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8, # rel8
  'loope':      X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8
  'loopne':     X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8, # rel8
  'jrcxz':      X64_JRCXZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8

  'loopd':      X64_LOOP_REL8   + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopzd':     X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopnzd':    X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'looped':     X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopned':    X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'jecxz':      X64_JRCXZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8

  'rol':        0 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'ror':        1 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'rcl':        2 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'rcr':        3 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'shl':        4 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'sal':        4 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'shr':        5 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'sar':        7 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8

  'movsx':      X64_MOVSX_R_RM8 + X64_HANDLER_MOV_EXTEND, # rd,r8 | rd,m8 | r32,r16 | r32,m16 | r64,r16 | r64,m16
  'movzx':      X64_MOVZX_R_RM8 + X64_HANDLER_MOV_EXTEND, # rd,r8 | rd,m8 | r32,r16 | r32,m16 | r64,r16 | r64,m16

  'seto':       X64_SETO  + X64_HANDLER_SETCC, # r8 | m8
  'setno':      X64_SETNO + X64_HANDLER_SETCC, # r8 | m8
  'setb':       X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setnae':     X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setc':       X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setnb':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setae':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setnc':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setz':       X64_SETE  + X64_HANDLER_SETCC, # r8 | m8
  'sete':       X64_SETE  + X64_HANDLER_SETCC, # r8 | m8
  'setnz':      X64_SETNE + X64_HANDLER_SETCC, # r8 | m8
  'setne':      X64_SETNE + X64_HANDLER_SETCC, # r8 | m8
  'setbe':      X64_SETBE + X64_HANDLER_SETCC, # r8 | m8
  'setna':      X64_SETBE + X64_HANDLER_SETCC, # r8 | m8
  'setnbe':     X64_SETA  + X64_HANDLER_SETCC, # r8 | m8
  'seta':       X64_SETA  + X64_HANDLER_SETCC, # r8 | m8
  'sets':       X64_SETS  + X64_HANDLER_SETCC, # r8 | m8
  'setns':      X64_SETNS + X64_HANDLER_SETCC, # r8 | m8
  'setp':       X64_SETP  + X64_HANDLER_SETCC, # r8 | m8
  'setpe':      X64_SETP  + X64_HANDLER_SETCC, # r8 | m8
  'setnp':      X64_SETNP + X64_HANDLER_SETCC, # r8 | m8
  'setpo':      X64_SETNP + X64_HANDLER_SETCC, # r8 | m8
  'setl':       X64_SETL  + X64_HANDLER_SETCC, # r8 | m8
  'setnge':     X64_SETL  + X64_HANDLER_SETCC, # r8 | m8
  'setge':      X64_SETGE + X64_HANDLER_SETCC, # r8 | m8
  'setnl':      X64_SETGE + X64_HANDLER_SETCC, # r8 | m8
  'setle':      X64_SETLE + X64_HANDLER_SETCC, # r8 | m8
  'setng':      X64_SETLE + X64_HANDLER_SETCC, # r8 | m8
  'setnle':     X64_SETG  + X64_HANDLER_SETCC, # r8 | m8
  'setg':       X64_SETG  + X64_HANDLER_SETCC, # r8 | m8

  'mov':        X64_MOV         + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r | r,imm | m,imm | r64,imm64
  'test':       X64_TEST        + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r | r,imm | m,imm
  'xchg':       X64_XCHG        + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r
  'out':        X64_OUT_IMM8_AL + X64_HANDLER_CUSTOM_X_Y, # imm8,al | imm8,ax | imm8,eax | dx,al | dx,ax | dx,eax
  'in':         X64_IN_AL_IMM8  + X64_HANDLER_CUSTOM_X_Y, # al,imm8 | ax,imm8 | eax,imm8 | al,dx | ax,dx | eax,dx
  'lsl':        X64_LSL         + X64_HANDLER_CUSTOM_X_Y, # rd,r16  | rd,m16
  'movsxd':     X64_MOVSXD      + X64_HANDLER_CUSTOM_X_Y, # r64,r32 | r64,m32
  'lea':        X64_LEA         + X64_HANDLER_CUSTOM_X_Y, # rd,m
  'enter':      X64_ENTER       + X64_HANDLER_CUSTOM_X_Y, # imm16, imm8

  'call':       X64_CALL_REL32  + X64_HANDLER_CUSTOM_X, #        rel16 | rel32 | r16 | r64 | m16 | m64
  'jmp':        X64_JMP_REL32   + X64_HANDLER_CUSTOM_X, # rel8 | rel16 | rel32 | r16 | r64 | m16 | m64
  'push':       X64_PUSH_R64    + X64_HANDLER_CUSTOM_X, # r16  | m16 | r64 | m64 | imm8 | imm16
  'pop':        X64_POP_R64     + X64_HANDLER_CUSTOM_X, # r16  | m16 | r64 | m64
  'bswap':      X64_BSWAP       + X64_HANDLER_CUSTOM_X, # r32  | r64
  'cmpxchg8b':  X64_CMPXCHG8B   + X64_HANDLER_CUSTOM_X, # m64
  'cmpxchg16b': X64_CMPXCHG16B  + X64_HANDLER_CUSTOM_X, # m128
  'inc':        X64_INC_R32     + X64_HANDLER_CUSTOM_X, # r | m
  'dec':        X64_DEC_R32     + X64_HANDLER_CUSTOM_X, # r | m
  'int':        X64_INT         + X64_HANDLER_CUSTOM_X, # imm8

  'retf':       X64_RETF        + X64_HANDLER_CUSTOM, # - | imm16
  'ret':        X64_RET         + X64_HANDLER_CUSTOM, # - | imm16
  'nop':        X64_NOP         + X64_HANDLER_CUSTOM  # - | rd | md
}

# TODO: Move comment inside map after parser fix up.
  # opcode  - | m16 | m32 | m64 | m80 | mcustom | sti | sti,st | st,sti
X64_OPCODES_MAP_FPU_M = {
  'f2xm1':    [X64_F2XM1   , 0, 0, 0, 0, 0, 0, 0, 0],
  'fabs':     [X64_FABS    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fchs':     [X64_FCHS    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fcompp':   [X64_FCOMPP  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fdecstp':  [X64_FDECSTP , 0, 0, 0, 0, 0, 0, 0, 0],
  'fincstp':  [X64_FINCSTP , 0, 0, 0, 0, 0, 0, 0, 0],
  'fld1':     [X64_FLD1    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fldl2e':   [X64_FLDL2E  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fldl2t':   [X64_FLDL2T  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fldlg2':   [X64_FLDLG2  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fldln2':   [X64_FLDLN2  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fldpi':    [X64_FLDPI   , 0, 0, 0, 0, 0, 0, 0, 0],
  'fldz':     [X64_FLDZ    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fnclex':   [X64_FNCLEX  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fninit':   [X64_FNINIT  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fclex':    [X64_FCLEX   , 0, 0, 0, 0, 0, 0, 0, 0],
  'finit':    [X64_FINIT   , 0, 0, 0, 0, 0, 0, 0, 0],
  'fnop':     [X64_FNOP    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fpatan':   [X64_FPATAN  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fprem':    [X64_FPREM   , 0, 0, 0, 0, 0, 0, 0, 0],
  'fptan':    [X64_FPTAN   , 0, 0, 0, 0, 0, 0, 0, 0],
  'frndint':  [X64_FRNDINT , 0, 0, 0, 0, 0, 0, 0, 0],
  'fscale':   [X64_FSCALE  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fsqrt':    [X64_FSQRT   , 0, 0, 0, 0, 0, 0, 0, 0],
  'ftst':     [X64_FTST    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fwait':    [X64_FWAIT   , 0, 0, 0, 0, 0, 0, 0, 0],
  'fxam':     [X64_FXAM    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fxtract':  [X64_FXTRACT , 0, 0, 0, 0, 0, 0, 0, 0],
  'fyl2x':    [X64_FYL2X   , 0, 0, 0, 0, 0, 0, 0, 0],
  'fyl2xp1':  [X64_FYL2XP1 , 0, 0, 0, 0, 0, 0, 0, 0],
  'fsin':     [X64_FSIN    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fcos':     [X64_FCOS    , 0, 0, 0, 0, 0, 0, 0, 0],
  'fsincos':  [X64_FSINCOS , 0, 0, 0, 0, 0, 0, 0, 0],
  'fprem1':   [X64_FPREM1  , 0, 0, 0, 0, 0, 0, 0, 0],
  'fucompp':  [X64_FUCOMPP , 0, 0, 0, 0, 0, 0, 0, 0],

  'fild':     [0 , X64_FILD_M16   , X64_FILD_M32   , X64_FILD_M64   , 0         , 0, 0, 0, 0],
  'fisttp':   [0 , X64_FISTTP_M16 , X64_FISTTP_M32 , X64_FISTTP_M64 , 0         , 0, 0, 0, 0],
  'fist':     [0 , X64_FIST_M16   , X64_FIST_M32   , 0              , 0         , 0, 0, 0, 0],
  'fistp':    [0 , X64_FISTP_M16  , X64_FISTP_M32  , X64_FISTP_M64  , 0         , 0, 0, 0, 0],
  'fbld':     [0 , 0              , 0              , 0              , X64_FBLD  , 0, 0, 0, 0],
  'fbstp':    [0 , 0              , 0              , 0              , X64_FBSTP , 0, 0, 0, 0],

  'fiadd':    [0 , X64_FIADD_M16  , X64_FIADD_M32  , 0 , 0 , 0 , 0, 0, 0],
  'fimul':    [0 , X64_FIMUL_M16  , X64_FIMUL_M32  , 0 , 0 , 0 , 0, 0, 0],
  'ficom':    [0 , X64_FICOM_M16  , X64_FICOM_M32  , 0 , 0 , 0 , 0, 0, 0],
  'ficomp':   [0 , X64_FICOMP_M16 , X64_FICOMP_M32 , 0 , 0 , 0 , 0, 0, 0],
  'fisub':    [0 , X64_FISUB_M16  , X64_FISUB_M32  , 0 , 0 , 0 , 0, 0, 0],
  'fisubr':   [0 , X64_FISUBR_M16 , X64_FISUBR_M32 , 0 , 0 , 0 , 0, 0, 0],
  'fidiv':    [0 , X64_FIDIV_M16  , X64_FIDIV_M32  , 0 , 0 , 0 , 0, 0, 0],
  'fidivr':   [0 , X64_FIDIVR_M16 , X64_FIDIVR_M32 , 0 , 0 , 0 , 0, 0, 0],

  'fld':      [0             , 0, X64_FLD_M32   , X64_FLD_M64   , X64_FLD_M80  , 0 , X64_FLD_STI   , 0, 0],
  'fst':      [0             , 0, X64_FST_M32   , X64_FST_M64   , 0            , 0 , X64_FST_STI   , 0, 0],
  'fstp':     [0             , 0, X64_FSTP_M32  , X64_FSTP_M64  , X64_FSTP_M80 , 0 , X64_FSTP_STI  , 0, 0],
  'fcom':     [X64_FCOM_ST1  , 0, X64_FCOM_M32  , X64_FCOM_M64  , 0            , 0 , X64_FCOM_STI  , 0, 0],
  'fcomp':    [X64_FCOMP_ST1 , 0, X64_FCOMP_M32 , X64_FCOMP_M64 , 0            , 0 , X64_FCOMP_STI , 0, 0],

  'fucom':    [X64_FUCOM_ST1  , 0 , 0 , 0 , 0 , 0 , X64_FUCOM_STI  , 0, 0],
  'fucomp':   [X64_FUCOMP_ST1 , 0 , 0 , 0 , 0 , 0 , X64_FUCOMP_STI , 0, 0],
  'fxch':     [X64_FXCH_ST1   , 0 , 0 , 0 , 0 , 0 , X64_FXCH_STI   , 0, 0],
  'ffree':    [0              , 0 , 0 , 0 , 0 , 0 , X64_FFREE_STI  , 0, 0],

  'faddp':    [X64_FADDP_ST1_ST0  , 0 , 0 , 0 , 0 , 0 , 0 , X64_FADDP_STI_ST0  , 0],
  'fmulp':    [X64_FMULP_ST1_ST0  , 0 , 0 , 0 , 0 , 0 , 0 , X64_FMULP_STI_ST0  , 0],
  'fsubrp':   [X64_FSUBRP_ST1_ST0 , 0 , 0 , 0 , 0 , 0 , 0 , X64_FSUBRP_STI_ST0 , 0],
  'fsubp':    [X64_FSUBP_ST1_ST0  , 0 , 0 , 0 , 0 , 0 , 0 , X64_FSUBP_STI_ST0  , 0],
  'fdivrp':   [X64_FDIVRP_ST1_ST0 , 0 , 0 , 0 , 0 , 0 , 0 , X64_FDIVRP_STI_ST0 , 0],
  'fdivp':    [X64_FDIVP_ST1_ST0  , 0 , 0 , 0 , 0 , 0 , 0 , X64_FDIVP_STI_ST0  , 0],

  'fadd':     [0, 0, X64_FADD_M32  , X64_FADD_M64  , 0, 0, 0, X64_FADD_STI_ST0 , X64_FADD_ST0_STI],
  'fmul':     [0, 0, X64_FMUL_M32  , X64_FMUL_M64  , 0, 0, 0, X64_FMUL_STI_ST0 , X64_FMUL_ST0_STI],
  'fsub':     [0, 0, X64_FSUB_M32  , X64_FSUB_M64  , 0, 0, 0, X64_FSUB_STI_ST0 , X64_FSUB_ST0_STI],
  'fsubr':    [0, 0, X64_FSUBR_M32 , X64_FSUBR_M64 , 0, 0, 0, X64_FSUBR_STI_ST0, X64_FSUBR_ST0_STI],
  'fdiv':     [0, 0, X64_FDIV_M32  , X64_FDIV_M64  , 0, 0, 0, X64_FDIV_STI_ST0 , X64_FDIV_ST0_STI],
  'fdivr':    [0, 0, X64_FDIVR_M32 , X64_FDIVR_M64 , 0, 0, 0, X64_FDIVR_STI_ST0, X64_FDIVR_ST0_STI],

  'fnstsw':   [0, X64_FNSTSW_M16, 0, 0, 0, 0, 0, 0, 0, X64_FNSTSW_AX],
  'fstsw':    [0, X64_FSTSW_M16 , 0, 0, 0, 0, 0, 0, 0, X64_FSTSW_AX],

  'fcmovb':   [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVB],
  'fcmove':   [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVE],
  'fcmovbe':  [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVBE ],
  'fcmovu':   [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVU],
  'fcmovnb':  [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVNB],
  'fcmovne':  [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVNE],
  'fcmovnbe': [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVNBE],
  'fcmovnu':  [0, 0, 0, 0, 0, 0, 0, 0, X64_FCMOVNU],
  'fcomi':    [0, 0, 0, 0, 0, 0, 0, 0, X64_FCOMI],
  'fcomip':   [0, 0, 0, 0, 0, 0, 0, 0, X64_FCOMIP],
  'fucomi':   [0, 0, 0, 0, 0, 0, 0, 0, X64_FUCOMI],
  'fucomip':  [0, 0, 0, 0, 0, 0, 0, 0, X64_FUCOMIP],

  'fldcw':    [0, X64_FLDCW  , 0, 0, 0, 0, 0, 0, 0], # m16
  'fnstcw':   [0, X64_FNSTCW , 0, 0, 0, 0, 0, 0, 0], # m16
  'fstcw':    [0, X64_FSTCW  , 0, 0, 0, 0, 0, 0, 0], # m16

  'fldenv':   [0, 0, 0, 0, 0, X64_FLDENV   , 0, 0, 0], # m224
  'fldenvd':  [0, 0, 0, 0, 0, X64_FLDENV   , 0, 0, 0], # m224
  'fnstenv':  [0, 0, 0, 0, 0, X64_FNSTENV  , 0, 0, 0], # m224
  'frstor':   [0, 0, 0, 0, 0, X64_FRSTOR   , 0, 0, 0], # m864
  'frstord':  [0, 0, 0, 0, 0, X64_FRSTOR   , 0, 0, 0], # m864
  'fnsave':   [0, 0, 0, 0, 0, X64_FNSAVE   , 0, 0, 0], # m864

  'fldenvw':  [0, 0, 0, 0, 0, X64_FLDENVW  , 0, 0, 0], # m112
  'fnstenvw': [0, 0, 0, 0, 0, X64_FNSTENVW , 0, 0, 0], # m112
  'frstorw':  [0, 0, 0, 0, 0, X64_FRSTORW  , 0, 0, 0], # m752
  'fnsavew':  [0, 0, 0, 0, 0, X64_FNSAVEW  , 0, 0, 0], # m752
  'fnstenvw': [0, 0, 0, 0, 0, X64_FNSTENVW , 0, 0, 0], # m112
  'frstorw':  [0, 0, 0, 0, 0, X64_FRSTORW  , 0, 0, 0], # m752
  'fnsavew':  [0, 0, 0, 0, 0, X64_FNSAVEW  , 0, 0, 0], # m752

  'fstenv':   [0, 0, 0, 0, 0, X64_FSTENV   , 0, 0, 0], # m224
  'fstenvd':  [0, 0, 0, 0, 0, X64_FSTENV   , 0, 0, 0], # m224
  'fsave':    [0, 0, 0, 0, 0, X64_FSAVE    , 0, 0, 0], # m864
  'fsaved':   [0, 0, 0, 0, 0, X64_FSAVE    , 0, 0, 0], # m864

  'fstenvw':  [0, 0, 0, 0, 0, X64_FSTENVW  , 0, 0, 0], # m112
  'fsavew':   [0, 0, 0, 0, 0, X64_FSAVEW   , 0, 0, 0], # m752
  'fxsave':   [0, 0, 0, 0, 0, X64_FXSAVE   , 0, 0, 0], # m4096
  'fxrstor':  [0, 0, 0, 0, 0, X64_FXRSTOR  , 0, 0, 0]  # m4096
}


class X64Translator extends PipeAbstract
  method emitCore_x_y(opcode, item)
    emiter   = this.outputObject
    reg      = item.reg
    regBase  = item.base
    regIndex = item.index
    disp     = item.disp
    scale    = item.scale

    if item.imm is defined
      if reg isnt -1
        # opcode r, imm
        emiter.emitCore_r_imm(opcode, reg, item.imm)
      else
        # opcode m, imm
        emiter.emitCore_m_imm(
          opcode, regBase, scale, regIndex, disp, item.imm, item.dataSize)
      endif

    elif reg isnt -1
      if item.rm isnt -1
        # opcode r, r
        regSrc = item.rm
        emiter.emitCore_r_r(opcode, reg, regSrc)

      elif item.scale is defined
        # opcode r, m
        # opcode m, r
        # opcode m, imm
        if item.imm is defined
          emiter.emitCore_m_imm(opcode, regBase, scale, regIndex, disp, item.imm)

        elif item.isWriteToMemory is true
          emiter.emitCore_m_r(opcode, regBase, scale, regIndex, disp, reg)

        else
          emiter.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)
        endif
      endif
    endif
  endmethod

  method emitCoreALU2(opcode, item)
    # TODO: Review it.
    # Why we need to swap regs here?
    reg = item.reg
    rm  = item.rm

    if (reg isnt -1) and (item.rm isnt -1)
      item.reg = item.rm
      item.rm  = reg
    endif

    this._validateOperandSizes(reg, rm, item.dataSize, item.imm)

    # Recognized common two-operands opcode.
    if item.imm is undefined
      if (X64_IsReg8(item.reg) is true) or (item.dataSize is 1)
        # 8-bit operands. Do nothing.

      elif opcode < 256
        # Set size bit in primary opcode to enable operands
        # greater than 8-bit.
        # This is old encoding pattern from original 8086 processor.
        opcode = opcode + 1

      else
        # 2-byte opcode. Primary opcode is in the higher byte.
        opcode = bitor(opcode, 256)
      endif
    endif

    # Generic two operands handler.
    this.emitCore_x_y(opcode, item)
  endmethod

  method _error(msg)
    die('error: ' + msg)

  endmethod

  method _validateNumberOfOperands(cnt, expectedCnt)
    if cnt < expectedCnt
      this._error('not enough operands')
    elif cnt > expectedCnt
      this._error('too many operands')
    endif
  endmethod

  method _validateOperandSizes(reg, rm, dataSize, imm)
    global X64_DATA_SIZE_ID
    regSizeId  = reg // 16
    rmSizeId   = rm  // 16
    dataSizeId = X64_DATA_SIZE_ID[dataSize]

    # TODO: Optimize it.
    if imm is undefined
      # r,r
      # r,m
      # m,r
      if (((rm isnt -1)      and (regSizeId isnt rmSizeId)) or # r,r
         ((dataSize isnt -1) and (regSizeId isnt dataSizeId))) # r,m or m,r
        this._error('operand sizes do not match')
      endif
    else
      this._validateImmRange(reg, rm, dataSize, imm)
    endif
  endmethod

  method _validateImmRange(reg, rm, dataSize, imm)
    global X64_DATA_SIZE_ID

    # TODO: Optimize it.
    if imm is defined
      regSizeId  = reg // 16
      rmSizeId   = rm  // 16
      dataSizeId = X64_DATA_SIZE_ID[dataSize]

      if reg isnt -1
        # r, imm
        if X64_IsReg8(reg) is true
          this._failIfOutOfRange(imm, -127, 255)
        elif X64_IsReg16(reg) is true
          this._failIfOutOfRange(imm, -32767, 65535)
        endif

      elif dataSize isnt -1
        # m, imm
        if dataSize is 1
          this._failIfOutOfRange(imm, -127, 255)
        elif dataSize is 2
          this._failIfOutOfRange(imm, -32767, 65535)
        endif
      endif
    endif
  endmethod

  method _failIf8BitOperandIsUsed(item)
    if ((item.dataSize is 1) or
        ((item.reg isnt -1) and (item.reg // 16 is 0)) or
        ((item.rm isnt -1) and (item.rm // 16 is 0)))
      this._error("8-bit operands not allowed for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfNon8BitOperandIsUsed(item)
    if (((item.scale is defined) and (item.dataSize > 1)) or
        ((item.reg isnt -1) and (item.reg // 16 > 0)) or
        ((item.rm isnt -1) and (item.rm // 16 > 0)))
      this._error("only 8-bit operands are allowed for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfNon16BitOperandIsUsed(item)
    if (((item.scale is defined) and (item.dataSize isnt 2)) or
        ((item.reg isnt -1) and (item.reg // 16 > 1)) or
        ((item.rm isnt -1) and (item.rm // 16 > 1)))
      this._error("only 16-bit operands are allowed for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfMemoryWrite(item)
    if item.isWriteToMemory is true
      this._error("memory address cannot be destination operand for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfMemoryRead(item)
    if item.isWriteToMemory is false
      this._error("memory address cannot be used as the second operand for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfImmIsUsed(item)
    if item.imm is defined
      this._error("immediate operand not allowed for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfMemoryReadOrWrite(item)
    if item.scale is defined
      this._error("memory operands not allowed for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfRegsAreUsed(item)
    if (item.reg isnt -1) or (item.rm isnt -1)
      this._error("register operands not allowed for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfImmIsMissing(item)
    if item.imm is undefined
      this._error("immediate operand expected for: '" + item.mnemonic + "'")
    endif
  endmethod

  method _failIfOutOfRange(x, valueMin, valueMax)
    if (x < valueMin) or (x > valueMax)
      this._error('value out of range')
    endif
  endmethod

  method _errorBadSyntax(item)
    this._error("operand does not match the statement for: '" + item.mnemonic + "'")
  endmethod

  method processOneItem(item)
    global X64_OPCODES_MAP
    global X64_OPCODES_MAP_FPU_M
    global X64_DATA_SIZE_ID

    global X64_CMPXCHG_RM8_R8, X64_CMPXCHG_RM32_R32, X64_CL, X64_DX
    global X64_XADD_RM8_R8, X64_XADD_RM32_R32, X64_ST0, X64_ST1, X64_AX

    global X64_HANDLER_CORE_ALU1, X64_HANDLER_CORE_ALU2
    global X64_HANDLER_CMOVCC, X64_HANDLER_JCC, X64_HANDLER_JUMPS_REL8
    global X64_HANDLER_JUMPS_REL8_2BYTES, X64_HANDLER_286
    global X64_HANDLER_0F_00_GROUP, X64_HANDLER_0F_01_GROUP
    global X64_HANDLER_SHIFT_GROUP, X64_HANDLER_SETCC, X64_HANDLER_DO_NOTHING
    global X64_HANDLER_INVALID_IN_64, X64_HANDLER_OPCODE_ONLY_0F_XX_YY
    global X64_HANDLER_CUSTOM, X64_HANDLER_OPCODE_ONLY_BYTE
    global X64_HANDLER_OPCODE_ONLY_WORD, X64_HANDLER_MOV_EXTEND
    global X64_HANDLER_OPCODE_ONLY_3BYTES
    global X64_HANDLER_FPU_MATH_FLOAT
    global X64_HANDLER_FPU_MATH_FLOAT_POP
    global X64_HANDLER_CUSTOM_X, X64_HANDLER_CUSTOM_X_Y
    global X64_HANDLER_CORE_RMD_RD, X64_HANDLER_CORE_RM_R
    global X64_HANDLER_FPU_ST0_STI

    global X64_LEA, X64_MOV, X64_TEST, X64_XCHG, X64_CALL_REL32, X64_NOP
    global X64_IN, X64_OUT, X64_JMP_REL32, X64_PUSH_R64, X64_POP_R64
    global X64_RET, X64_RETF, X64_BSWAP, X64_CMPXCHG8B, X64_CMPXCHG16B
    global X64_HANDLER_FPU_STI
    global X64_INC_R32, X64_DEC_R32, X64_ENTER, X64_LEAVE, X64_INT
    global X64_FXSAVE, X64_FXRSTOR, X64_FNSTSW_M16, X64_FSTSW_M16
    global X64_LSL, X64_MOVSXD

    global X64_SYNTAX_ZERO_OPERANDS, X64_SYNTAX_ONE_OPERAND_READ_ONLY
    global X64_SYNTAX_TWO_OPERANDS, X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE
    global X64_SYNTAX_ONE_OPERAND_READWRITE

    encoder = this.outputObject

    if item.type is 'instruction'
      # Parse one code line.
      # Fetch instruction info.
      mnemonic         = item.mnemonic
      reg              = item.reg
      rm               = item.rm
      regBase          = item.base
      regIndex         = item.index
      disp             = item.disp
      scale            = item.scale
      imm              = item.imm
      dataSize         = item.dataSize
      numberOfOperands = item.numberOfOperands

      # Search for mnemonic.
      opcodeInfo = X64_OPCODES_MAP[mnemonic]

      if opcodeInfo is defined
        # Decode handler and opcode.
        opcode    = bitand(opcodeInfo, 0x00ffffff)
        handlerId = bitand(opcodeInfo, 0xff000000)
        syntaxId  = bitand(opcodeInfo, 0xf0000000)

        # Generic syntax checking for most common rules.
        if syntaxId is X64_SYNTAX_ZERO_OPERANDS
          this._validateNumberOfOperands(numberOfOperands, 0)

        elif syntaxId is X64_SYNTAX_ONE_OPERAND_READ_ONLY
          this._validateNumberOfOperands(numberOfOperands, 1)

        elif syntaxId is X64_SYNTAX_ONE_OPERAND_READWRITE
          this._validateNumberOfOperands(numberOfOperands, 1)
          this._failIfImmIsUsed(item)

        elif syntaxId is X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE
          this._validateNumberOfOperands(numberOfOperands, 2)
          this._validateOperandSizes(reg, rm, dataSize, imm)
          this._validateImmRange(reg, rm, dataSize, imm)

        elif syntaxId is X64_SYNTAX_TWO_OPERANDS
          this._validateNumberOfOperands(numberOfOperands, 2)
        endif

        # Only mov can handle 64-bit immediate.
        if (imm is defined) and (opcode isnt X64_MOV)
          this._failIfOutOfRange(imm, -2147483647, 4294967295)
        endif

        # Handle generic prefixes, which should be emited before opcode.
        # TODO

        # Dispatch opcode handler.
        if handlerId is X64_HANDLER_OPCODE_ONLY_BYTE
          # Single byte opcode without operands: xx
          # Just emit opcode as is.
          encoder.emitByte(opcode)

        elif handlerId is X64_HANDLER_OPCODE_ONLY_WORD
          # Two bytes opcode without operands: xx yy
          # Just emit opcode as is.
          encoder.emitWord(opcode)

        elif handlerId is X64_HANDLER_OPCODE_ONLY_3BYTES
          # Three bytes opcode without operands: xx yy zz
          # Just emit opcode as is.
          print hex(opcode)
          encoder.emitByte(bitand(opcode, 0xff))
          encoder.emitWord(opcode // 256)

        elif handlerId is X64_HANDLER_OPCODE_ONLY_0F_XX_YY
          # Three bytes opcode without operands: 0f xx yy
          # Just emit opcode as is.
          encoder.emitByte(0x0f)
          encoder.emitWord(opcode)

        elif handlerId is X64_HANDLER_CORE_ALU1
          if reg is -1
            # not/neg/mul/div/imul/idiv m
            encoder.emitCore_unaryGroup_m(opcode, regBase, scale, regIndex, disp, dataSize)
          else
            # not/neg/mul/div/imul/idiv r
            encoder.emitCore_unaryGroup_r(opcode, reg)
          endif

        elif handlerId is X64_HANDLER_CORE_ALU2
          this.emitCoreALU2(opcode, item)

        elif handlerId is X64_HANDLER_CMOVCC
          this._failIfMemoryWrite(item)
          this._failIf8BitOperandIsUsed(item)
          this._failIfImmIsUsed(item)
          this.emitCore_x_y(opcode, item)

        elif handlerId is X64_HANDLER_JCC
          # jcc rel8/32
          this._failIfImmIsMissing(item)
          encoder.emitCore_jcc_rel(opcode, imm - item.offset)

        elif handlerId is X64_HANDLER_JUMPS_REL8
          # One byte jump with rel8 always.
          # loopz rel8 like.
          this._failIfImmIsMissing(item)
          rel8 = imm - item.offset - 2
          # TODO: Check range.
          # this._failIfOutOfRange(rel8, -127, 128)
          encoder.emitCore_jmp_rel8(opcode, rel8)

        elif handlerId is X64_HANDLER_JUMPS_REL8_2BYTES
          # One byte jump with rel8 always and 0x67 prefix.
          # loopz rel8 like.
          # TODO: Clean up this mess.
          this._failIfImmIsMissing(item)
          rel8 = imm - item.offset - 3
          # TODO: Check range.
          # this._failIfOutOfRange(rel8, -127, 128)
          encoder.emitByte(0x67)
          encoder.emitCore_jmp_rel8(opcode, rel8)

        elif handlerId is X64_HANDLER_SHIFT_GROUP
          regCL = -1

          if scale is defined
            this._failIfMemoryRead(item)
            if imm is defined
              # m, imm8
              this._failIfOutOfRange(imm, -127, 255)
              encoder.emitCore_shiftGroup_m_imm8(opcode, regBase, scale, regIndex, disp, imm, dataSize)
            else
              # m, cl
              encoder.emitCore_shiftGroup_m_cl(opcode, regBase, scale, regIndex, disp, dataSize)
              regCL = reg
            endif

          elif imm is defined
            # r, imm8
            this._failIfOutOfRange(imm, -127, 255)
            encoder.emitCore_shiftGroup_r_imm8(opcode, reg, imm)
          else
            # r, cl
            encoder.emitCore_shiftGroup_r_cl(opcode, reg)
            regCL = rm
          endif

          if (regCL isnt -1) and (regCL isnt X64_CL)
            this._error("only imm8 or the cl register can be used as the second operand for: '" + mnemonic + "'")
          endif

        elif handlerId is X64_HANDLER_SETCC
          this._failIfNon8BitOperandIsUsed(item)
          if scale is defined
            # setcc m8
            encoder.emitCore_m(opcode, regBase, scale, regIndex, disp)
          else
            # setcc r8
            encoder.emitCore_r(opcode, reg)
          endif

        elif handlerId is X64_HANDLER_MOV_EXTEND
          this._failIfImmIsUsed(item)
          this._failIfMemoryWrite(item)
          if scale is defined
            # movsx r16/32/64, m8/16
            # movzx r16/32/64, m8/16
            if (dataSize > 2) or (reg // 16 <= dataSize - 1)
              # Destination must be wider than source.
              this._errorBadSyntax(item)
            endif

            if dataSize is 2
              opcode = bitor(opcode, 256)
            endif

            encoder.emitCore_movExtend_r_m(opcode, reg, regBase, scale, regIndex, disp)

          else
            # movsx r16/32/64, r8/16
            # movzx r16/32/64, r8/16
            if (rm >= 32) or ((reg // 16) <= (rm // 16))
              # Destination must be wider than source.
              this._errorBadSyntax(item)
            endif

            encoder.emitCore_movExtend_r_r(opcode, reg, rm)
          endif

        elif handlerId is X64_HANDLER_CORE_RMD_RD
          this._failIf8BitOperandIsUsed(item)
          this._failIfMemoryRead(item)
          this._failIfImmIsUsed(item)
          this.emitCoreALU2(opcode, item)

        elif handlerId is X64_HANDLER_CORE_RM_R
          this._failIfMemoryRead(item)
          this._failIfImmIsUsed(item)
          this.emitCoreALU2(opcode, item)

        elif handlerId is X64_HANDLER_DO_NOTHING
          # Do nothing.

        elif handlerId is X64_HANDLER_CUSTOM_X_Y
          # Custom handler for two operands opcode
          # opcode x,y
          if opcode is X64_MOV
            if imm is defined
              this._validateImmRange(reg, rm, dataSize, imm)
              if reg isnt -1
                # mov r, imm
                encoder.mov_r_imm(reg, imm)
              else
                # mov m, imm
                encoder.mov_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
              endif
            else
              this.emitCoreALU2(opcode, item)
            endif

          elif opcode is X64_LEA
            this._failIfMemoryWrite(item)
            this._failIfImmIsUsed(item)

            if X64_IsReg8(reg) is true
              this._errorBadSyntax(item)
            endif

            encoder.lea_r_m(reg, regBase, scale, regIndex, disp)

          elif opcode is X64_TEST
            if imm is defined
              this._validateImmRange(reg, rm, dataSize, imm)
              if reg isnt -1
                # test r, imm
                encoder.test_r_imm(reg, imm)
              else
                # test m, imm
                encoder.test_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
              endif
            else
              # Opcodes have fixed diretion flag, but other assemblers accept both and
              # swap operands silently if needed.
              # Only test r/m, r/imm exists.
              item.isWriteToMemory = true
              this.emitCoreALU2(opcode, item)
            endif

          elif opcode is X64_XCHG
            this._validateOperandSizes(reg, rm, dataSize, imm)
            this._failIfImmIsUsed(item)

            if (reg isnt -1) and (rm isnt -1)
              # xchg r, r
              encoder.xchg_r_r(reg, rm)
            else
              # Opcodes have fixed diretion flag, but other assemblers accept both and
              # swap operands silently if needed.
              # Only xchg r, r/m exists.
              item.isWriteToMemory = false
              this.emitCoreALU2(opcode, item)
            endif

          elif opcode is X64_OUT
            this._failIfMemoryReadOrWrite(item)
            if imm is defined
              this._failIfOutOfRange(imm, 0, 255)
              encoder.out_imm_r(imm, reg)
            elif reg is X64_DX
              encoder.out_dx_r(rm)
            else
              this._error("port must be imm8 or dx register for: 'out'")
            endif

          elif opcode is X64_IN
            this._failIfMemoryReadOrWrite(item)
            if imm is defined
              this._failIfOutOfRange(imm, 0, 255)
              encoder.in_r_imm(reg, imm)
            elif rm is X64_DX
              encoder.in_r_dx(reg)
            else
              this._error("port must be imm8 or dx register for: 'in'")
            endif

          elif opcode is X64_LSL
            this._failIfMemoryWrite(item)
            this._failIf8BitOperandIsUsed(item)
            this._failIfImmIsUsed(item)

            if (scale is defined) and (dataSize isnt 2)
              this._errorBadSyntax(item)
            endif
            this.emitCore_x_y(opcode, item)

          elif opcode is X64_MOVSXD
            # movsxd r64, r/m32
            this._failIfMemoryWrite(item)
            this._failIfImmIsUsed(item)

            if ((X64_IsReg64(reg) is false) or
                ((rm isnt -1) and (X64_IsReg32(rm) is false)) or
                ((dataSize isnt -1) and (dataSize isnt 4)))
              this._errorBadSyntax(item)
            endif

            this.emitCore_x_y(opcode, item)

          elif opcode is X64_ENTER
            # enter imm16, imm8
            if (imm is undefined) or (item.imm2 is undefined)
              this._error("two immediate operands are expected for: 'enter'")
            endif
            this._failIfOutOfRange(imm,       0, 65535)
            this._failIfOutOfRange(item.imm2, 0, 255)
            encoder.enter_imm16_imm8(imm, item.imm2)
          endif

        elif handlerId is X64_HANDLER_CUSTOM_X
          # Custom handler for one operand opcode
          # opcode x
          if opcode is X64_PUSH_R64
            if reg isnt -1
              # push r
              encoder.push_r(reg)

            elif imm is defined
              if (imm >= -127) and (imm <= 128)
                # push imm8
                encoder.push_imm8(imm)
              else
                # push imm32
                this._failIfOutOfRange(imm, -32767, 65535)
                encoder.push_imm32(imm)
               endif
            else
              # push m
              encoder.push_m(regBase, scale, regIndex, disp, dataSize)
            endif

          elif opcode is X64_POP_R64
            this._failIfImmIsUsed(item)
            if reg isnt -1
              encoder.pop_r(reg)
            else
              encoder.pop_m(regBase, scale, regIndex, disp, dataSize)
            endif

          elif opcode is X64_CALL_REL32
            if reg isnt -1
              # call r
              if (X64_IsReg8(reg) is true) or (X64_IsReg32(reg) is true)
                this._error("8/32-bit addresses not allowed for: '" + item.mnemonic + "'")
              endif
              encoder.call_r(reg)

            elif scale is defined
              # call m
              if (dataSize is 1) or (dataSize is 4)
                this._error("8/32-bit addresses not allowed for: '" + item.mnemonic + "'")
              endif

              encoder.call_m(regBase, scale, regIndex, disp, dataSize)

            else
              # call rel32
              encoder.call_rel(imm - item.offset)
            endif

          elif opcode is X64_JMP_REL32
            if reg isnt -1
              # jmp r
              if (X64_IsReg8(reg) is true) or (X64_IsReg32(reg) is true)
                this._error("8/32-bit addresses not allowed for: '" + item.mnemonic + "'")
              endif
              encoder.jmp_r(reg)
            elif scale is defined
              # jmp m
              if (dataSize is 1) or (dataSize is 4)
                this._error("8/32-bit addresses not allowed for: '" + item.mnemonic + "'")
              endif
              encoder.jmp_m(regBase, scale, regIndex, disp, dataSize)
            else
              # jmp rel8/32
              encoder.jmp_rel(imm - item.offset)
            endif

          elif opcode is X64_BSWAP
            this._failIfMemoryReadOrWrite(item)
            this._failIfImmIsUsed(item)
            if reg < 32
              this._errorBadSyntax(item)
            endif

            encoder.bswap_r(reg)

          elif opcode is X64_CMPXCHG8B
            this._failIfImmIsUsed(item)
            this._failIfRegsAreUsed(item)

            # TODO: Don't compare strings.
            if mnemonic is 'cmpxchg8b'
              encoder.cmpxchg8b_m(regBase, scale, regIndex, disp)
            else
              encoder.cmpxchg16b_m(regBase, scale, regIndex, disp)
            endif

          elif opcode is X64_INC_R32
            this._failIfImmIsUsed(item)
            if reg isnt -1
              # inc r
              encoder.inc_r(reg)
            else
              # inc m
              encoder.inc_m(regBase, scale, regIndex, disp, dataSize)
            endif

          elif opcode is X64_DEC_R32
            this._failIfImmIsUsed(item)
            if reg isnt -1
              # dec r
              encoder.dec_r(reg)
            else
              # dec m
              encoder.dec_m(regBase, scale, regIndex, disp, dataSize)
            endif

          elif opcode is X64_INT
            # int imm8
            this._failIfImmIsMissing(item)
            this._failIfOutOfRange(imm, 0, 255)
            encoder.int_imm(imm)

          elif opcode is X64_FXSAVE
            # TODO: Validate operands.
            encoder.fxsave_m(regBase, scale, regIndex, disp)

          elif opcode is X64_FXRSTOR
            # TODO: Validate operands.
            encoder.fxrstor_m(regBase, scale, regIndex, disp)

          elif opcode is X64_FNSTSW_M16
            # TODO: Validate operands.
            if scale is defined
              encoder.fnstsw_m16(regBase, scale, regIndex, disp)
            else
              encoder.fnstsw_ax()
            endif

          elif opcode is X64_FSTSW_M16
            # TODO: Validate operands.
            if scale is defined
              encoder.fstsw_m16(regBase, scale, regIndex, disp)
            else
              encoder.fstsw_ax()
            endif
          endif

        elif handlerId is X64_HANDLER_CUSTOM
          # Custom handler for opcodes with variable numberof operands.
          # Dispatch opcode.
          if opcode is X64_RET
            if numberOfOperands is 0
              encoder.ret()
            else
              this._validateNumberOfOperands(numberOfOperands, 1)
              this._failIfImmIsMissing(item)
              this._failIfOutOfRange(imm, 0, 65535)
              encoder.ret_imm(imm)
            endif

          elif opcode is X64_RETF
            if numberOfOperands is 0
              encoder.retf()
            else
              this._validateNumberOfOperands(numberOfOperands, 1)
              this._failIfImmIsMissing(item)
              this._failIfOutOfRange(imm, 0, 65535)
              encoder.retf_imm(imm)
            endif

          elif opcode is X64_NOP
            if numberOfOperands is 0
              # One byte nop.
              this._validateNumberOfOperands(numberOfOperands, 0)
              encoder.nop()

            else
              # Muli-byte nop.
              this._validateNumberOfOperands(numberOfOperands, 1)
              this._failIfImmIsUsed(item)
              this._failIf8BitOperandIsUsed(item)

              if scale is defined
                # nop m
                encoder.nop_m(regBase, scale, regIndex, disp, dataSize)
              elif reg isnt -1
                # nop r
                encoder.nop_r(reg)
              endif
            endif
          endif

        elif handlerId is X64_HANDLER_FPU_MATH_FLOAT
          # TODO: Validate operands.
          if scale is defined
            # st,m
            if dataSize is 4
              encoder.emitFPU_m32real(opcode, regBase, scale, regIndex, disp)
            else
              encoder.emitFPU_m64real(opcode, regBase, scale, regIndex, disp)
            endif

          elif reg is X64_ST0
            # st,sti
            encoder.emitCore_group_r(0xd8, opcode, bitand(rm, 0x7))

          else
            # sti,st
            # TODO: Clean up this mess.
            if (mnemonic is 'fdiv')
              # fdiv sti,st0
              opcode = 7

            elif (mnemonic is 'fdivr')
              # fdivr sti,st0
              opcode = 6

            elif (mnemonic is 'fsub')
              # fdivr sti,st0
              opcode = 5

            elif (mnemonic is 'fsubr')
              # fdivr sti,st0
              opcode = 4
            endif

            encoder.emitCore_group_r(0xdc, opcode, bitand(reg, 0x7))
          endif

        elif handlerId is X64_HANDLER_FPU_MATH_FLOAT_POP
          # TODO: Validate operands.
          if numberOfOperands is 0
            # No operands.
            # Should be defaulted to st1,st
            reg = X64_ST1
          endif

          encoder.emitCore_group_r(0xde, opcode, bitand(reg, 0x7))

        elif handlerId is X64_HANDLER_FPU_STI
          if numberOfOperands is 0
            reg = X64_ST1
          endif
          encoder.emitFPU_sti(opcode, reg)

        elif handlerId is X64_HANDLER_FPU_ST0_STI
          # TODO: Validate operands.
          encoder.emitFPU_sti(opcode, rm)

        elif handlerId is X64_HANDLER_286
          this._failIfMemoryWrite(item)
          this._failIf8BitOperandIsUsed(item)
          this._failIfImmIsUsed(item)

          if scale is defined
            # r,m
            encoder.emitCore286_r_m(opcode, reg, regBase, scale, regIndex, disp)
          else
            # r,r
            encoder.emitCore286_r_r(opcode, reg, rm)
          endif

        elif handlerId is X64_HANDLER_0F_00_GROUP
          this._failIf8BitOperandIsUsed(item)
          # 0f 00 /x
          if scale is defined
            # m
            encoder.emitCore_group0f_00_m(opcode, regBase, scale, regIndex, disp)
          else
            # r
            encoder.emitCore_group0f_00_r(opcode, reg)
          endif

        elif handlerId is X64_HANDLER_0F_01_GROUP
          # 0f 01 /x
          if scale is defined
            # m
            encoder.emitCore_group0f_01_m(opcode, regBase, scale, regIndex, disp)
          else
            # r
            encoder.emitCore_group0f_01_r(opcode, reg)
          endif

        elif handlerId is X64_HANDLER_INVALID_IN_64
          # Instruction is correct, but not allowed in native 64-bit mode.
          this._error("invalid in 64-bit mode: '" + mnemonic + "'")

        else
          # Error - unexpected handler id.
          # Should never happen on production.
          this._error('unknown opcode handler: ' + str(handlerId))
        endif

      else
        # TODO: Clean up this mess.
        opcodeInfoFPU = X64_OPCODES_MAP_FPU_M[mnemonic]

        if opcodeInfoFPU is defined
          # FPU opcode with single operand.
          if numberOfOperands is 0
            # opcode without operands
            opcode = opcodeInfoFPU[0]
            if opcode is 0
              this._error('not enough operands')
            endif

            if opcode > 0xffff
              # 3 bytes opcode.
              encoder.emitByte(bitand(opcode, 0xff))
              encoder.emitWord(opcode // 256)
            else
              # 2 bytes opcode.
              encoder.emitWord(opcode)
            endif

          elif numberOfOperands is 1
            # Opcode with one operand
            if reg isnt -1
              # opcode sti
              if reg is X64_AX
                opcode = opcodeInfoFPU[9]
              else
                opcode = opcodeInfoFPU[6]
              endif

              if opcode > 0xffff
                # 1 byte prefix.
                encoder.emitByte(bitand(opcode, 0xff))
                opcode = opcode // 256
              endif

              encoder.emitFPU_sti(opcode, reg)

            elif scale is defined
              # opcode m
              if dataSize is 0
                # There is no 8-bit operand allowed for FPU opcodes.
                this._error("8-bit operand not allowed for: '" + mnemonic + "'")

              else
                # Get opcode for current memory size.
                if dataSize is -1
                  # Memory operand without word/dword/qword/tword prefix.
                  opcode = opcodeInfoFPU[5]
                  if opcode is 0
                    this._error("ambiguous operand size for: '" + mnemonic + "'")
                  endif

                else
                  # Memory operand with word/dword/qword/tword prefix.
                  dataSizeId = X64_DATA_SIZE_ID[dataSize]
                  opcode     = opcodeInfoFPU[dataSizeId]
                  if opcode is 0
                    # Syntax error - there is no opcode with for memory size.
                    this._error("invalid operand size for: '" + mnemonic + "'")
                  endif
                endif

                # Emit hardcoded prefixes if needed.
                if opcode > 0xffffff
                  # 2 byte prefixes.
                  encoder.emitWord(bitand(opcode, 0xffff))
                  opcode = opcode // 65536

                elif opcode > 0xffff
                  # 1 byte prefix.
                  encoder.emitByte(bitand(opcode, 0xff))
                  opcode = opcode // 256
                endif

                # Memory size matched.
                # Emit opcode.
                primaryOpcode = bitand(opcode, 0xff)
                operationId   = opcode // 256
                encoder.emitCore_group_m(primaryOpcode, operationId, regBase, scale, regIndex, disp)
              endif
            endif

          elif numberOfOperands is 2
            # Opcode with two operands
            if dataSize is 4
              # st0,m32
              opcode        = opcodeInfoFPU[9]
              primaryOpcode = bitand(opcode, 0xff)
              operationId   = opcode // 256
              encoder.emitCore_group_m(opcode, operationId, regBase, scale, regIndex, disp)

            elif dataSize is 8
              # st0,m64
              opcode        = opcodeInfoFPU[10]
              primaryOpcode = bitand(opcode, 0xff)
              operationId   = opcode // 256
              encoder.emitCore_group_m(opcode, operationId, regBase, scale, regIndex, disp)

            elif (reg is X64_ST0) and (rm is X64_ST0)
              # st0,st0
              opcode = opcodeInfoFPU[8]
              if opcode is 0
                opcode = opcodeInfoFPU[7]
              endif
              encoder.emitFPU_sti(opcode, reg)

            elif rm is X64_ST0
              # sti,st0
              opcode = opcodeInfoFPU[7]
              encoder.emitFPU_sti(opcode, reg)

            elif reg is X64_ST0
              # st0,sti
              opcode = opcodeInfoFPU[8]
              encoder.emitFPU_sti(opcode, rm)
            endif
          endif

        else
          this._error("unrecognized instruction: '" + mnemonic + "'")
        endif
      endif

    elif item.type is 'label'
      # Collect label positions.
      this.labelsMap[item.name] = encoder.getCurrentPosition()

    elif item.type is 'data'
      if item.dataSize is 1
        encoder.emitByte(item.imm)
      elif item.dataSize is 2
        encoder.emitWord(item.imm)
      elif item.dataSize is 4
        encoder.emitDword(item.imm)
      elif item.dataSize is 8
        encoder.emitQword(item.imm)
      endif
    endif
  endmethod

  method getCurrentPosition() -> rv
    # TODO: Clean up this mess.
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass
