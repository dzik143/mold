################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Compiler/Utils/PipeAbstract.mold'

# Opcodes, that exists, but are invalid in 64-bit mode.
X64_POOL_OF_MNEMONICS_INVALID64 = [
  'das'   , 'aas'  , 'bound'  , 'sahf'  , 'lahf',
  'les'   , 'lds'  , 'aam'    , 'aad'   , 'arpl',
  'pusha' , 'popa' , 'pushad' , 'popad' , 'pushfd' , 'popfd'
]

# Opcodes, that does not require any operands.
# We can emit them as is.
X64_OPCODES_MAP0 = {
  'cbw':  X64_CWDE * 256 + X64_PREFIX_OPERAND_SIZE,
  'cwde': X64_CWDE,
  'cdqe': X64_CWDE * 256 + X64_PREFIX_REX_W,

  'cwd': X64_CDQ * 256 + X64_PREFIX_OPERAND_SIZE,
  'cdq': X64_CDQ,
  'cqo': X64_CDQ * 256 + X64_PREFIX_REX_W,

  'clc': X64_CLC,
  'cld': X64_CLD,
  'cli': X64_CLI,
  'stc': X64_STC,
  'std': X64_STD,
  'sti': X64_STI,
  'cmc': X64_CMC,

  'cmpsb': X64_CMPSB,
  'cmpsw': X64_CMPSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'cmpsd': X64_CMPSD,
  'cmpsq': X64_CMPSD * 256 + X64_PREFIX_REX_W,

  'movsb': X64_MOVSB,
  'movsw': X64_MOVSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'movsd': X64_MOVSD,
  'movsq': X64_MOVSD * 256 + X64_PREFIX_REX_W,

  'lodsb': X64_LODSB,
  'lodsw': X64_LODSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'lodsd': X64_LODSD,
  'lodsq': X64_LODSD * 256 + X64_PREFIX_REX_W,

  'stosb': X64_STOSB,
  'stosw': X64_STOSD * 256 + X64_PREFIX_OPERAND_SIZE,
  'stosd': X64_STOSD,
  'stosq': X64_STOSD * 256 + X64_PREFIX_REX_W,

  'scasb': X64_SCASB,
  'scasw': X64_SCASD * 256 + X64_PREFIX_OPERAND_SIZE,
  'scasd': X64_SCASD,
  'scasq': X64_SCASD * 256 + X64_PREFIX_REX_W,

  'rep':   X64_PREFIX_REPE,
  'repe':  X64_PREFIX_REPE,
  'repz':  X64_PREFIX_REPE,
  'repne': X64_PREFIX_REPNE,
  'repnz': X64_PREFIX_REPNE,

  'hlt':  X64_HLT,
  'lock': X64_PREFIX_LOCK,
  'nop':  X64_NOP,
  'xlatb': X64_XLAT,

  'into': X64_INTO,
  'int1': X64_INT1,
  'int3': X64_INT3,
  'iret': X64_IRET,

  'pushf':  X64_PUSHF,
  'pushfw': X64_PUSHF * 256 + X64_PREFIX_OPERAND_SIZE,
  'pushfq': X64_PUSHF,

  'popf':   X64_POPF,
  'popfw':  X64_POPF  * 256 + X64_PREFIX_OPERAND_SIZE,
  'popfq':  X64_POPF,

  'leave': X64_LEAVE
}

X64_OPCODES_MAP_CORE_ALU2 = {
  'adc':  X64_ADC,
  'add':  X64_ADD,
  'and':  X64_AND,
  'cmp':  X64_CMP,
  'sbb':  X64_SBB,
  'sub':  X64_SUB,
  'or':   X64_OR,
  'xor':  X64_XOR,
  'mov':  X64_MOV_RM8_R8,
  'test': X64_TEST_RM8_R8,
  'xchg': X64_XCHG_RM8_R8
}

X64_OPCODES_MAP_UNARY_GROUP = {
  'not': 2,
  'neg': 3,
  'mul': 4,
  'imul': 5,
  'div': 6,
  'idiv': 7
}

X64_OPCODES_JUMPS = {
  'call': X64_CALL_REL32,
  'jo':   X64_JO,
  'jno':  X64_JNO,
  'jb':   X64_JB,
  'jae':  X64_JAE,
  'jz':   X64_JZ,
  'je':   X64_JZ,
  'jnz':  X64_JNZ,
  'jne':  X64_JNZ,
  'jbe':  X64_JBE,
  'ja':   X64_JA,
  'js':   X64_JS,
  'jns':  X64_JNS,
  'jp':   X64_JP,
  'jnp':  X64_JNP,
  'jl':   X64_JL,
  'jge':  X64_JGE,
  'jle':  X64_JLE,
  'jg':   X64_JG,
  'jmp':  X64_JMP_REL32
}

X64_OPCODES_1BYTE_JUMPS_REL8 = {
  'loop':   X64_LOOP_REL8,
  'loopz':  X64_LOOPZ_REL8,
  'loopnz': X64_LOOPNZ_REL8,
  'loope':  X64_LOOPZ_REL8,
  'loopne': X64_LOOPNZ_REL8,
  'jrcxz':  X64_JRCXZ_REL8
}

class X64Translator extends PipeAbstract
  method emitCore_x_y(opcode, item)
    emiter   = this.outputObject
    reg      = item.reg
    regBase  = item.base
    regIndex = item.index
    disp     = item.disp
    scale    = item.scale

    if item.imm is defined
      if reg isnt -1
        # opcode r, imm
        emiter.emitCore_r_imm(opcode, reg, item.imm)
      else
        # opcode m, imm
        emiter.emitCore_m_imm(opcode, regBase, scale, regIndex, disp, item.imm, item.dataSize)
      endif

    elif reg isnt -1
      if item.rm isnt -1
        # opcode r, r
        regSrc = item.rm
        emiter.emitCore_r_r(opcode, reg, regSrc)

      elif item.scale is defined
        # opcode r, m
        # opcode m, r
        # opcode m, imm
        if item.imm is defined
          emiter.emitCore_m_imm(opcode, regBase, scale, regIndex, disp, item.imm)

        elif item.isWriteToMemory is true
          emiter.emitCore_m_r(opcode, regBase, scale, regIndex, disp, reg)

        else
          emiter.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)
        endif
      endif
    endif
  endmethod

  method calculateInstructionSize(item)

  endmethod

  method processOneItem(item)
    global X64_OPCODES_MAP0
    global X64_OPCODES_MAP_CORE_ALU2
    global X64_OPCODES_MAP_UNARY_GROUP
    global X64_TEST_RM8_R8
    global X64_OPCODES_JUMPS
    global X64_OPCODES_1BYTE_JUMPS_REL8

    #print item

    encoder = this.outputObject

    if item.type is 'label'
      # Collect label positions.
      this.labelsMap[item.name] = encoder.getCurrentPosition()

    elif item.type is 'instruction'
      # Parse one code line.
      mnemonic = item.mnemonic
      opcode   = X64_OPCODES_MAP0[mnemonic]

      reg      = item.reg
      rm       = item.rm
      regBase  = item.base
      regIndex = item.index
      disp     = item.disp
      scale    = item.scale
      imm      = item.imm

      #print item #'[', mnemonic, item.reg, item.rm, item.imm, ']'

      if opcode is defined
        # Recognized no-operands opcode.
        # Just emit opcode as is.
        if opcode < 256
          encoder.emitByte(opcode)
        else
          encoder.emitWord(opcode)
        endif

      elif (imm is defined) and (mnemonic is 'mov')
        if reg isnt -1
          # mov r, imm
          encoder.mov_r_imm(reg, imm)
        else
          # mov m, imm
          encoder.mov_m_imm(regBase, scale, regIndex, disp, imm, item.dataSize)
        endif

      elif mnemonic is 'lea'
        encoder.lea_r_m(reg, regBase, scale, regIndex, disp)

      elif (imm is defined) and (mnemonic is 'test')
        if reg isnt -1
          # test r, imm
          encoder.test_r_imm(reg, imm)
        else
          # test m, imm
          encoder.test_m_imm(regBase, scale, regIndex, disp, imm, item.dataSize)
        endif

      elif mnemonic is 'push'
        if reg isnt -1
          encoder.push_r(reg)
        elif imm is defined
          # TODO: Handle 8-bit push.
          encoder.push_imm32(imm)
        else
          # TODO
          #encoder.push_m(regBase, scale, regIndex, disp)
          die('not implemented: push m')
        endif

      elif mnemonic is 'pop'
        if reg isnt -1
          encoder.pop_r(reg)
        else
          die('not implemented: pop m')
          #encoder.pop_m(regBase, scale, regIndex, disp)
        endif

      elif (mnemonic is 'xchg') and (reg isnt -1) and (rm isnt -1)
        # xchg r, r
        encoder.xchg_r_r(reg, rm)

      elif mnemonic is 'call'
        encoder.call_rel(imm - item.offset)

      elif mnemonic is 'jmp'
        encoder.jmp_rel(imm - item.offset)

      elif mnemonic is 'jecxz'
        encoder.jecxz_rel(imm - item.offset)

      elif mnemonic is 'ret'
        if imm is defined
          encoder.ret_imm(imm)
        else
          encoder.ret()
        endif

      elif mnemonic is 'leave'
        # Handle two immediates at one opcode.
        die('not implemented: leave imm16, imm8')

      else
        opcode = X64_OPCODES_MAP_CORE_ALU2[mnemonic]

        if opcode is defined
          # Recognized common two-operands opcode.

          # Special case for test and xchg.
          # These opcodes have fixed diretion flag, but other assemblers accept both and
          # swap operands silently if needed.
          if mnemonic is 'test'
            # Only test r/m, r/imm exists.
            item.isWriteToMemory = true

          elif mnemonic is 'xchg'
            # Only xchg r, r/m exists.
            item.isWriteToMemory = false
          endif

          # Generic two operands handler.
          this.emitCore_x_y(opcode, item)

        else
          operationId = X64_OPCODES_MAP_UNARY_GROUP[mnemonic]

          if operationId is defined
            if reg is -1
              # not/neg/mul/div/imul/idiv m
              encoder.emitCore_unaryGroup_m(
                operationId, regBase, scale, regIndex, disp, item.dataSize)
            else
              # not/neg/mul/div/imul/idiv r
              encoder.emitCore_unaryGroup_r(operationId, reg)
            endif
          else
            opcode = X64_OPCODES_JUMPS[mnemonic]

            if opcode is defined
              # jxx rel8/32
              encoder.emitCore_jxx_rel(opcode, imm - item.offset)

            else
              opcode = X64_OPCODES_1BYTE_JUMPS_REL8[mnemonic]

              if opcode is defined
                # One byte jump with rel8 always.
                # loopz rel8 like.
                encoder.emitCore_jmp_rel8(opcode, imm - item.offset - 2)
              endif
            endif
          endif
        endif
      endif

    elif item.type is 'data'
      if item.dataSize is 1
        encoder.emitByte(item.value)
      elif item.dataSize is 2
        encoder.emitWord(item.value)
      elif item.dataSize is 4
        encoder.emitDword(item.value)
      elif item.dataSize is 8
        encoder.emitQword(item.value)
      endif
    endif
  endmethod

  method getCurrentPosition() -> rv
    # TODO: Clean up this mess.
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass
