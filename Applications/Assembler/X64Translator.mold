################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'X64.mold'
import '../../Compiler/Utils/PipeAbstract.mold'

# Encoding handlers: no operands (opcode only).
X64_HANDLER_OPCODE_ONLY_BYTE     = 0x00000000
X64_HANDLER_OPCODE_ONLY_WORD     = 0x01000000
X64_HANDLER_OPCODE_ONLY_3BYTES   = 0x02000000
X64_HANDLER_OPCODE_ONLY_0F_XX_YY = 0x03000000

# Encoding handlers: one operands (read only).
X64_HANDLER_JCC                  = 0x10000000
X64_HANDLER_JUMPS_REL8           = 0x11000000
X64_HANDLER_JUMPS_REL8_2BYTES    = 0x12000000
X64_HANDLER_CUSTOM_X             = 0x13000000

# Encoding handlers: two operands with equal size.
X64_HANDLER_CORE_ALU2            = 0x20000000
X64_HANDLER_CMOVCC               = 0x21000000
X64_HANDLER_CORE_RMD_RD          = 0x22000000
X64_HANDLER_CORE_RM_R            = 0x23000000

# Encoding handler: two operands (generic).
X64_HANDLER_SHIFT_GROUP          = 0x30000000
X64_HANDLER_MOV_EXTEND           = 0x31000000
X64_HANDLER_286                  = 0x32000000
X64_HANDLER_CUSTOM_X_Y           = 0x33000000
X64_HANDLER_MMX                  = 0x34000000
X64_HANDLER_MMX_SHIFT            = 0x35000000

# Encoding handlers: one operands (read/write).
X64_HANDLER_CORE_ALU1            = 0x40000000
X64_HANDLER_0F_00_GROUP          = 0x41000000
X64_HANDLER_0F_01_GROUP          = 0x42000000
X64_HANDLER_SETCC                = 0x43000000

# Other.
X64_HANDLER_CUSTOM               = 0xfd000000
X64_HANDLER_DO_NOTHING           = 0xfe000000
X64_HANDLER_INVALID_IN_64        = 0xff000000

                 #  0 1 2 3 4 5 6 7 8 9 10 bytes
X64_DATA_SIZE_ID = [0,0,1,1,2,2,2,2,3,3,4]

# Common operands combinations for generic syntax checking.
X64_SYNTAX_ZERO_OPERANDS           = 0x00000000
X64_SYNTAX_ONE_OPERAND_READ_ONLY   = 0x10000000
X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE = 0x20000000
X64_SYNTAX_TWO_OPERANDS            = 0x30000000
X64_SYNTAX_ONE_OPERAND_READWRITE   = 0x40000000

# Opcodes, that does not require any operands.
# We can emit them as is.
X64_OPCODES_MAP = {
  'use64':      X64_HANDLER_DO_NOTHING,

  'aaa':        X64_HANDLER_INVALID_IN_64,
  'aad':        X64_HANDLER_INVALID_IN_64,
  'aam':        X64_HANDLER_INVALID_IN_64,
  'lahf':       X64_HANDLER_INVALID_IN_64,
  'aas':        X64_HANDLER_INVALID_IN_64,
  'das':        X64_HANDLER_INVALID_IN_64,
  'sahf':       X64_HANDLER_INVALID_IN_64,
  'lds':        X64_HANDLER_INVALID_IN_64,
  'les':        X64_HANDLER_INVALID_IN_64,
  'daa':        X64_HANDLER_INVALID_IN_64,
  'into':       X64_HANDLER_INVALID_IN_64,
  'bound':      X64_HANDLER_INVALID_IN_64,
  'popa':       X64_HANDLER_INVALID_IN_64,
  'pusha':      X64_HANDLER_INVALID_IN_64,
  'arpl':       X64_HANDLER_INVALID_IN_64,
  'loadall':    X64_HANDLER_INVALID_IN_64,
  'pushad':     X64_HANDLER_INVALID_IN_64,
  'popad':      X64_HANDLER_INVALID_IN_64,
  'pushfd':     X64_HANDLER_INVALID_IN_64,
  'popfd':      X64_HANDLER_INVALID_IN_64,
  'loadalld':   X64_HANDLER_INVALID_IN_64,
  'ibts':       X64_HANDLER_INVALID_IN_64,
  'xbts':       X64_HANDLER_INVALID_IN_64,

  'cwde':       X64_CWDE,  # - (no operands)
  'cdq':        X64_CDQ,   # - (no operands)

  'clc':        X64_CLC,   # - (no operands)
  'cld':        X64_CLD,   # - (no operands)
  'cli':        X64_CLI,   # - (no operands)
  'stc':        X64_STC,   # - (no operands)
  'std':        X64_STD,   # - (no operands)
  'sti':        X64_STI,   # - (no operands)
  'cmc':        X64_CMC,   # - (no operands)

  'cmpsb':      X64_CMPSB, # - (no operands)
  'cmpsd':      X64_CMPSD, # - (no operands)
  'movsb':      X64_MOVSB, # - (no operands)
  'movsd':      X64_MOVSD, # - (no operands)
  'lodsb':      X64_LODSB, # - (no operands)
  'lodsd':      X64_LODSD, # - (no operands)
  'stosb':      X64_STOSB, # - (no operands)
  'stosd':      X64_STOSD, # - (no operands)
  'scasb':      X64_SCASB, # - (no operands)
  'scasd':      X64_SCASD, # - (no operands)
  'insb' :      X64_INSB,  # - (no operands)
  'insd' :      X64_INSD,  # - (no operands)
  'outsb':      X64_OUTSB, # - (no operands)
  'outsd':      X64_OUTSD, # - (no operands)

  'rep':        X64_PREFIX_REPE, # - (no operands)
  'repe':       X64_PREFIX_REPE, # - (no operands)
  'repz':       X64_PREFIX_REPE, # - (no operands)
  'repne':      X64_PREFIX_REPNE,# - (no operands)
  'repnz':      X64_PREFIX_REPNE,# - (no operands)

  'hlt':        X64_HLT,         # - (no operands)
  'lock':       X64_PREFIX_LOCK, # - (no operands)
  'xlatb':      X64_XLATB,       # - (no operands)

  'int1':       X64_INT1,  # - (no operands)
  'int3':       X64_INT3,  # - (no operands)
  'iretd':      X64_IRET,  # - (no operands)

  'iretw':      X64_IRETW + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iret':       X64_IRETQ + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iretq':      X64_IRETQ + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)

  'pushf':      X64_PUSHF, # - (no operands)
  'pushfq':     X64_PUSHF, # - (no operands)
  'popf':       X64_POPF,  # - (no operands)
  'popfq':      X64_POPF,  # - (no operands)

  'leave':      X64_LEAVE, # - (no operands)
  'wait':       X64_WAIT,  # - (no operands)

  'cmpsw':      X64_CMPSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cmpsq':      X64_CMPSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'movsw':      X64_MOVSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'movsq':      X64_MOVSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'lodsw':      X64_LODSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'lodsq':      X64_LODSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'stosw':      X64_STOSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'stosq':      X64_STOSQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'scasw':      X64_SCASW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'scasq':      X64_SCASQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'insw' :      X64_INSW     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'outsw':      X64_OUTSW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cbw':        X64_CBW      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cdqe':       X64_CDQE     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cwd':        X64_CWD      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cqo':        X64_CQO      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'iretq':      X64_IRETQ    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'pushfw':     X64_PUSHFW   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'popfw':      X64_POPFW    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'clts':       X64_CLTS     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'cpuid':      X64_CPUID    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'wrmsr':      X64_WRMSR    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdtsc':      X64_RDTSC    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdmsr':      X64_RDMSR    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rdpmc':      X64_RDPMC    + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'rsm':        X64_RSM      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'invd':       X64_INVD     + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'wbinvd':     X64_WBINVD   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'syscall':    X64_SYSCALL  + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysret':     X64_SYSRET   + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysenter':   X64_SYSENTER + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'sysexit':    X64_SYSEXIT  + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)
  'ud2':        X64_UD2      + X64_HANDLER_OPCODE_ONLY_WORD, # - (no operands)

  'rdtscp':     X64_RDTSCP + X64_HANDLER_OPCODE_ONLY_0F_XX_YY, # - (no operands)
  'swapgs':     X64_SWAPGS + X64_HANDLER_OPCODE_ONLY_0F_XX_YY, # - (no operands)

  'adc':        X64_ADC            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'add':        X64_ADD            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'and':        X64_AND            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'cmp':        X64_CMP            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'sbb':        X64_SBB            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'sub':        X64_SUB            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'or':         X64_OR             + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm
  'xor':        X64_XOR            + X64_HANDLER_CORE_ALU2, # r,r | r,m | m,r | r,imm | m,imm

  'bt':         X64_BT_RM_R        + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd
  'btc':        X64_BTC_RM_R       + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd
  'btr':        X64_BTR_RM_R       + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd
  'bts':        X64_BTS_RM_R       + X64_HANDLER_CORE_RMD_RD, # rd,rd | md,rd

  'xadd':       X64_XADD_RM8_R8    + X64_HANDLER_CORE_RM_R, # r,r | m,r
  'cmpxchg':    X64_CMPXCHG_RM8_R8 + X64_HANDLER_CORE_RM_R, # r,r | m,r

  'cmovo':      X64_CMOVO   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovno':     X64_CMOVNO  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovb':      X64_CMOVB   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnae':    X64_CMOVB   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovc':      X64_CMOVB   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnb':     X64_CMOVAE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovae':     X64_CMOVAE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnc':     X64_CMOVAE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovz':      X64_CMOVE   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmove':      X64_CMOVE   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnz':     X64_CMOVNE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovne':     X64_CMOVNE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovbe':     X64_CMOVBE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovna':     X64_CMOVBE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnbe':    X64_CMOVA   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmova':      X64_CMOVA   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovs':      X64_CMOVS   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovns':     X64_CMOVNS  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovp':      X64_CMOVP   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovpe':     X64_CMOVP   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnp':     X64_CMOVNP  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovpo':     X64_CMOVNP  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovl':      X64_CMOVL   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnge':    X64_CMOVL   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovge':     X64_CMOVGE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnl':     X64_CMOVGE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovle':     X64_CMOVLE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovng':     X64_CMOVLE  + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovnle':    X64_CMOVG   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'cmovg':      X64_CMOVG   + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'bsf':        X64_BSF     + X64_HANDLER_CMOVCC, # rd,rd | rd,md
  'bsr':        X64_BSR     + X64_HANDLER_CMOVCC, # rd,rd | rd,md

  'not':        2 + X64_HANDLER_CORE_ALU1, # r | m
  'neg':        3 + X64_HANDLER_CORE_ALU1, # r | m
  'mul':        4 + X64_HANDLER_CORE_ALU1, # r | m
  'imul':       5 + X64_HANDLER_CORE_ALU1, # r | m | rd,md | rd,md,imm
  'div':        6 + X64_HANDLER_CORE_ALU1, # r | m
  'idiv':       7 + X64_HANDLER_CORE_ALU1, # r | m

  'lar':        X64_LAR + X64_HANDLER_286, # rd,r16    | rd,m16
  'lss':        X64_LSS + X64_HANDLER_286, # rd,md-far
  'lfs':        X64_LFS + X64_HANDLER_286, # rd,md-far
  'lgs':        X64_LGS + X64_HANDLER_286, # rd,md-far

  'sldt':       0 + X64_HANDLER_0F_00_GROUP, # r16 | r64 | m16
  'str':        1 + X64_HANDLER_0F_00_GROUP, # rd  | m16
  'lldt':       2 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'ltr':        3 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'verr':       4 + X64_HANDLER_0F_00_GROUP, # r16 | m16
  'verw':       5 + X64_HANDLER_0F_00_GROUP, # r16 | m16

  'sgdt':       0 + X64_HANDLER_0F_01_GROUP, # m80
  'sidt':       1 + X64_HANDLER_0F_01_GROUP, # m80
  'lgdt':       2 + X64_HANDLER_0F_01_GROUP, # m48
  'lidt':       3 + X64_HANDLER_0F_01_GROUP, # m48
  'smsw':       4 + X64_HANDLER_0F_01_GROUP, # rd | m16
  'lmsw':       6 + X64_HANDLER_0F_01_GROUP, # rd | m16
  'invlpg':     7 + X64_HANDLER_0F_01_GROUP, # m

  'jo':         X64_JO  + X64_HANDLER_JCC, # rel8 | rel32
  'jno':        X64_JNO + X64_HANDLER_JCC, # rel8 | rel32
  'jb':         X64_JB  + X64_HANDLER_JCC, # rel8 | rel32
  'jae':        X64_JAE + X64_HANDLER_JCC, # rel8 | rel32
  'jz':         X64_JZ  + X64_HANDLER_JCC, # rel8 | rel32
  'je':         X64_JZ  + X64_HANDLER_JCC, # rel8 | rel32
  'jnz':        X64_JNZ + X64_HANDLER_JCC, # rel8 | rel32
  'jne':        X64_JNZ + X64_HANDLER_JCC, # rel8 | rel32
  'jbe':        X64_JBE + X64_HANDLER_JCC, # rel8 | rel32
  'ja':         X64_JA  + X64_HANDLER_JCC, # rel8 | rel32
  'js':         X64_JS  + X64_HANDLER_JCC, # rel8 | rel32
  'jns':        X64_JNS + X64_HANDLER_JCC, # rel8 | rel32
  'jp':         X64_JP  + X64_HANDLER_JCC, # rel8 | rel32
  'jnp':        X64_JNP + X64_HANDLER_JCC, # rel8 | rel32
  'jl':         X64_JL  + X64_HANDLER_JCC, # rel8 | rel32
  'jge':        X64_JGE + X64_HANDLER_JCC, # rel8 | rel32
  'jle':        X64_JLE + X64_HANDLER_JCC, # rel8 | rel32
  'jg':         X64_JG  + X64_HANDLER_JCC, # rel8 | rel32

  'loop':       X64_LOOP_REL8   + X64_HANDLER_JUMPS_REL8, # rel8
  'loopz':      X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8
  'loopnz':     X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8, # rel8
  'loope':      X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8
  'loopne':     X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8, # rel8
  'jrcxz':      X64_JRCXZ_REL8  + X64_HANDLER_JUMPS_REL8, # rel8

  'loopd':      X64_LOOP_REL8   + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopzd':     X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopnzd':    X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'looped':     X64_LOOPZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'loopned':    X64_LOOPNZ_REL8 + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8
  'jecxz':      X64_JRCXZ_REL8  + X64_HANDLER_JUMPS_REL8_2BYTES, # rel8

  'rol':        0 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'ror':        1 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'rcl':        2 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'rcr':        3 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'shl':        4 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'sal':        4 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'shr':        5 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8
  'sar':        7 + X64_HANDLER_SHIFT_GROUP, # r,cl | r,imm8 | m,cl | m,imm8

  'movsx':      X64_MOVSX_R_RM8 + X64_HANDLER_MOV_EXTEND, # rd,r8 | rd,m8 | r32,r16 | r32,m16 | r64,r16 | r64,m16
  'movzx':      X64_MOVZX_R_RM8 + X64_HANDLER_MOV_EXTEND, # rd,r8 | rd,m8 | r32,r16 | r32,m16 | r64,r16 | r64,m16

  'seto':       X64_SETO  + X64_HANDLER_SETCC, # r8 | m8
  'setno':      X64_SETNO + X64_HANDLER_SETCC, # r8 | m8
  'setb':       X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setnae':     X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setc':       X64_SETB  + X64_HANDLER_SETCC, # r8 | m8
  'setnb':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setae':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setnc':      X64_SETAE + X64_HANDLER_SETCC, # r8 | m8
  'setz':       X64_SETE  + X64_HANDLER_SETCC, # r8 | m8
  'sete':       X64_SETE  + X64_HANDLER_SETCC, # r8 | m8
  'setnz':      X64_SETNE + X64_HANDLER_SETCC, # r8 | m8
  'setne':      X64_SETNE + X64_HANDLER_SETCC, # r8 | m8
  'setbe':      X64_SETBE + X64_HANDLER_SETCC, # r8 | m8
  'setna':      X64_SETBE + X64_HANDLER_SETCC, # r8 | m8
  'setnbe':     X64_SETA  + X64_HANDLER_SETCC, # r8 | m8
  'seta':       X64_SETA  + X64_HANDLER_SETCC, # r8 | m8
  'sets':       X64_SETS  + X64_HANDLER_SETCC, # r8 | m8
  'setns':      X64_SETNS + X64_HANDLER_SETCC, # r8 | m8
  'setp':       X64_SETP  + X64_HANDLER_SETCC, # r8 | m8
  'setpe':      X64_SETP  + X64_HANDLER_SETCC, # r8 | m8
  'setnp':      X64_SETNP + X64_HANDLER_SETCC, # r8 | m8
  'setpo':      X64_SETNP + X64_HANDLER_SETCC, # r8 | m8
  'setl':       X64_SETL  + X64_HANDLER_SETCC, # r8 | m8
  'setnge':     X64_SETL  + X64_HANDLER_SETCC, # r8 | m8
  'setge':      X64_SETGE + X64_HANDLER_SETCC, # r8 | m8
  'setnl':      X64_SETGE + X64_HANDLER_SETCC, # r8 | m8
  'setle':      X64_SETLE + X64_HANDLER_SETCC, # r8 | m8
  'setng':      X64_SETLE + X64_HANDLER_SETCC, # r8 | m8
  'setnle':     X64_SETG  + X64_HANDLER_SETCC, # r8 | m8
  'setg':       X64_SETG  + X64_HANDLER_SETCC, # r8 | m8

  'mov':        X64_MOV         + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r | r,imm | m,imm | r64,imm64
  'test':       X64_TEST        + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r | r,imm | m,imm
  'xchg':       X64_XCHG        + X64_HANDLER_CUSTOM_X_Y, # r,r | r,m | m,r
  'out':        X64_OUT_IMM8_AL + X64_HANDLER_CUSTOM_X_Y, # imm8,al | imm8,ax | imm8,eax | dx,al | dx,ax | dx,eax
  'in':         X64_IN_AL_IMM8  + X64_HANDLER_CUSTOM_X_Y, # al,imm8 | ax,imm8 | eax,imm8 | al,dx | ax,dx | eax,dx
  'lsl':        X64_LSL         + X64_HANDLER_CUSTOM_X_Y, # rd,r16  | rd,m16
  'movsxd':     X64_MOVSXD      + X64_HANDLER_CUSTOM_X_Y, # r64,r32 | r64,m32
  'lea':        X64_LEA         + X64_HANDLER_CUSTOM_X_Y, # rd,m
  'enter':      X64_ENTER       + X64_HANDLER_CUSTOM_X_Y, # imm16, imm8

  'call':       X64_CALL_REL32  + X64_HANDLER_CUSTOM_X,   #        rel16 | rel32 | r16 | r64 | m16 | m64
  'jmp':        X64_JMP_REL32   + X64_HANDLER_CUSTOM_X,   # rel8 | rel16 | rel32 | r16 | r64 | m16 | m64
  'push':       X64_PUSH_R64    + X64_HANDLER_CUSTOM_X,   # r16  | m16 | r64 | m64 | imm8 | imm16
  'pop':        X64_POP_R64     + X64_HANDLER_CUSTOM_X,   # r16  | m16 | r64 | m64
  'bswap':      X64_BSWAP       + X64_HANDLER_CUSTOM_X,   # r32  | r64
  'cmpxchg8b':  X64_CMPXCHG8B   + X64_HANDLER_CUSTOM_X,   # m64
  'cmpxchg16b': X64_CMPXCHG16B  + X64_HANDLER_CUSTOM_X,   # m128
  'inc':        X64_INC_R32     + X64_HANDLER_CUSTOM_X,   # r | m
  'dec':        X64_DEC_R32     + X64_HANDLER_CUSTOM_X,   # r | m
  'int':        X64_INT         + X64_HANDLER_CUSTOM_X,   # imm8

  'retf':       X64_RETF        + X64_HANDLER_CUSTOM,     # - | imm16
  'ret':        X64_RET         + X64_HANDLER_CUSTOM,     # - | imm16
  'nop':        X64_NOP         + X64_HANDLER_CUSTOM,     # - | rd | md

  'packssdw':   X64_PACKSSDW   + X64_HANDLER_MMX, # mm,mm | mm,m64
  'packsswb':   X64_PACKSSWB   + X64_HANDLER_MMX, # mm,mm | mm,m64
  'packuswb':   X64_PACKUSWB   + X64_HANDLER_MMX, # mm,mm | mm,m64

  'paddb':      X64_PADDB      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddw':      X64_PADDW      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddd':      X64_PADDD      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddq':      X64_PADDQ      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddsb':     X64_PADDSB     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddsw':     X64_PADDSW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddusb':    X64_PADDUSB    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'paddusw':    X64_PADDUSW    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmaddwd':    X64_PMADDWD    + X64_HANDLER_MMX, # mm,mm | mm,m64

  'pand':       X64_PAND       + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pandn':      X64_PANDN      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'por':        X64_POR        + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pxor':       X64_PXOR       + X64_HANDLER_MMX, # mm,mm | mm,m64

  'pcmpeqb':    X64_PCMPEQB    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pcmpeqw':    X64_PCMPEQW    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pcmpeqd':    X64_PCMPEQD    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pcmpgtb':    X64_PCMPGTB    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pcmpgtw':    X64_PCMPGTW    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pcmpgtd':    X64_PCMPGTD    + X64_HANDLER_MMX, # mm,mm | mm,m64

  'pmulhw':     X64_PMULHW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmullw':     X64_PMULLW     + X64_HANDLER_MMX, # mm,mm | mm,m64

  'psubb':      X64_PSUBB      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psubw':      X64_PSUBW      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psubd':      X64_PSUBD      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psubsb':     X64_PSUBSB     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psubsw':     X64_PSUBSW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psubusb':    X64_PSUBUSB    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psubusw':    X64_PSUBUSW    + X64_HANDLER_MMX, # mm,mm | mm,m64

  'punpckhbw':  X64_PUNPCKHBW  + X64_HANDLER_MMX, # mm,mm | mm,m64
  'punpckhwd':  X64_PUNPCKHWD  + X64_HANDLER_MMX, # mm,mm | mm,m64
  'punpckhdq':  X64_PUNPCKHDQ  + X64_HANDLER_MMX, # mm,mm | mm,m64

  'pminub':     X64_PMINUB     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmaxub':     X64_PMAXUB     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pavgb':      X64_PAVGB      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pavgw':      X64_PAVGW      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmulhuw':    X64_PMULHUW    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pminsw':     X64_PMINSW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmaxsw':     X64_PMAXSW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psadbw':     X64_PSADBW     + X64_HANDLER_MMX, # mm,mm | mm,m64

  'psubq':      X64_PSUBQ      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmuludq':    X64_PMULUDQ    + X64_HANDLER_MMX, # mm,mm | mm,m64

  'psignb':     X64_PSIGNB     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psignw':     X64_PSIGNW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'psignd':     X64_PSIGND     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pshufb':     X64_PSHUFB     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmulhrsw':   X64_PMULHRSW   + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pmaddubsw':  X64_PMADDUBSW  + X64_HANDLER_MMX, # mm,mm | mm,m64
  'phsubw':     X64_PHSUBW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'phsubsw':    X64_PHSUBSW    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'phsubd':     X64_PHSUBD     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'phaddsw':    X64_PHADDSW    + X64_HANDLER_MMX, # mm,mm | mm,m64
  'phaddw':     X64_PHADDW     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'phaddd':     X64_PHADDD     + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pabsb':      X64_PABSB      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pabsw':      X64_PABSW      + X64_HANDLER_MMX, # mm,mm | mm,m64
  'pabsd':      X64_PABSD      + X64_HANDLER_MMX, # mm,mm | mm,m64

  'emms':       X64_EMMS       + X64_HANDLER_OPCODE_ONLY_WORD, # -

  'punpcklbw':  X64_PUNPCKLBW  + X64_HANDLER_MMX, # mm,mm | mm,m32
  'punpcklwd':  X64_PUNPCKLWD  + X64_HANDLER_MMX, # mm,mm | mm,m32
  'punpckldq':  X64_PUNPCKLDQ  + X64_HANDLER_MMX, # mm,mm | mm,m32

  'psrlw':      65536 * 2 + X64_PSRLW + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'psraw':      65536 * 4 + X64_PSRAW + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'psllw':      65536 * 6 + X64_PSLLW + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'psrld':      65536 * 2 + X64_PSRLD + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'psrad':      65536 * 4 + X64_PSRAD + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'pslld':      65536 * 6 + X64_PSLLD + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'psrlq':      65536 * 2 + X64_PSRLQ + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8
  'psllq':      65536 * 6 + X64_PSLLQ + X64_HANDLER_MMX_SHIFT, # mm,mm | mm,m64 | mm,imm8

  'movd':       X64_MOVD_MM_RM32 + X64_HANDLER_CUSTOM_X_Y, # mm,r32 | mm,m32 | r32,mm | m32,mm
  'movq':       X64_MOVQ_MM_M64  + X64_HANDLER_CUSTOM_X_Y, # mm,mm  | mm,r64 | mm,m64 | r64,mm | m64,mm
  'palignr':    X64_PALIGNR      + X64_HANDLER_CUSTOM,     # mm,mm,imm8  | mm,m64,imm8
  'pshufw':     X64_PSHUFW       + X64_HANDLER_CUSTOM,     # mm,mm,imm8  | mm,m64,imm8
  'pextrw':     X64_PEXTRW       + X64_HANDLER_CUSTOM,     # r32,mm,imm8 | r64,mm,imm8
  'pinsrw':     X64_PINSRW       + X64_HANDLER_CUSTOM,     # mm,r32,imm8 | mm,m16,imm8
  'pmovmskb':   X64_PMOVMSKB     + X64_HANDLER_CUSTOM      # r32,mm      | r64,mm
}

X64_OPCODES_MAP_FPU = [
  {
    # No operands (opcode only).
    'f2xm1':   X64_F2XM1,
    'fabs':    X64_FABS,
    'fchs':    X64_FCHS,
    'fcompp':  X64_FCOMPP,
    'fdecstp': X64_FDECSTP,
    'fincstp': X64_FINCSTP,
    'fld1':    X64_FLD1,
    'fldl2e':  X64_FLDL2E,
    'fldl2t':  X64_FLDL2T,
    'fldlg2':  X64_FLDLG2,
    'fldln2':  X64_FLDLN2,
    'fldpi':   X64_FLDPI,
    'fldz':    X64_FLDZ,
    'fnclex':  X64_FNCLEX,
    'fninit':  X64_FNINIT,
    'fclex':   X64_FCLEX,
    'finit':   X64_FINIT,
    'fnop':    X64_FNOP,
    'fpatan':  X64_FPATAN,
    'fprem':   X64_FPREM,
    'fptan':   X64_FPTAN,
    'frndint': X64_FRNDINT,
    'fscale':  X64_FSCALE,
    'fsqrt':   X64_FSQRT,
    'ftst':    X64_FTST,
    'fwait':   X64_FWAIT,
    'fxam':    X64_FXAM,
    'fxtract': X64_FXTRACT,
    'fyl2x':   X64_FYL2X,
    'fyl2xp1': X64_FYL2XP1,
    'fsin':    X64_FSIN,
    'fcos':    X64_FCOS,
    'fsincos': X64_FSINCOS,
    'fprem1':  X64_FPREM1,
    'fucompp': X64_FUCOMPP,
    'fcom':    X64_FCOM_ST1 ,
    'fcomp':   X64_FCOMP_ST1,
    'fucom':   X64_FUCOM_ST1,
    'fucomp':  X64_FUCOMP_ST1,
    'fxch':    X64_FXCH_ST1,
    'faddp':   X64_FADDP_ST1_ST0,
    'fmulp':   X64_FMULP_ST1_ST0,
    'fsubrp':  X64_FSUBRP_ST1_ST0,
    'fsubp':   X64_FSUBP_ST1_ST0,
    'fdivrp':  X64_FDIVRP_ST1_ST0,
    'fdivp':   X64_FDIVP_ST1_ST0
  },
  {
    # One operand.
    # opcode    sti, m16            , m32            , m64 ,            m80       , mcustom
    'fild':     [0 , X64_FILD_M16   , X64_FILD_M32   , X64_FILD_M64   , 0         , 0],
    'fisttp':   [0 , X64_FISTTP_M16 , X64_FISTTP_M32 , X64_FISTTP_M64 , 0         , 0],
    'fist':     [0 , X64_FIST_M16   , X64_FIST_M32   , 0              , 0         , 0],
    'fistp':    [0 , X64_FISTP_M16  , X64_FISTP_M32  , X64_FISTP_M64  , 0         , 0],
    'fbld':     [0 , 0              , 0              , 0              , X64_FBLD  , 0],
    'fbstp':    [0 , 0              , 0              , 0              , X64_FBSTP , 0],

    'fiadd':    [0 , X64_FIADD_M16  , X64_FIADD_M32  , 0, 0, 0],
    'fimul':    [0 , X64_FIMUL_M16  , X64_FIMUL_M32  , 0, 0, 0],
    'ficom':    [0 , X64_FICOM_M16  , X64_FICOM_M32  , 0, 0, 0],
    'ficomp':   [0 , X64_FICOMP_M16 , X64_FICOMP_M32 , 0, 0, 0],
    'fisub':    [0 , X64_FISUB_M16  , X64_FISUB_M32  , 0, 0, 0],
    'fisubr':   [0 , X64_FISUBR_M16 , X64_FISUBR_M32 , 0, 0, 0],
    'fidiv':    [0 , X64_FIDIV_M16  , X64_FIDIV_M32  , 0, 0, 0],
    'fidivr':   [0 , X64_FIDIVR_M16 , X64_FIDIVR_M32 , 0, 0, 0],

    'fld':      [X64_FLD_STI   , 0  , X64_FLD_M32   , X64_FLD_M64   , X64_FLD_M80  , 0],
    'fst':      [X64_FST_STI   , 0  , X64_FST_M32   , X64_FST_M64   , 0            , 0],
    'fstp':     [X64_FSTP_STI  , 0  , X64_FSTP_M32  , X64_FSTP_M64  , X64_FSTP_M80 , 0],
    'fcom':     [X64_FCOM_STI  , 0  , X64_FCOM_M32  , X64_FCOM_M64  , 0            , 0],
    'fcomp':    [X64_FCOMP_STI , 0  , X64_FCOMP_M32 , X64_FCOMP_M64 , 0            , 0],

    'fucom':    [X64_FUCOM_STI  , 0 , 0 , 0 , 0, 0],
    'fucomp':   [X64_FUCOMP_STI , 0 , 0 , 0 , 0, 0],
    'fxch':     [X64_FXCH_STI   , 0 , 0 , 0 , 0, 0],
    'ffree':    [X64_FFREE_STI  , 0 , 0 , 0 , 0, 0],

    'fadd':     [0, 0, X64_FADD_M32  , X64_FADD_M64  , 0, 0],
    'fmul':     [0, 0, X64_FMUL_M32  , X64_FMUL_M64  , 0, 0],
    'fsub':     [0, 0, X64_FSUB_M32  , X64_FSUB_M64  , 0, 0],
    'fsubr':    [0, 0, X64_FSUBR_M32 , X64_FSUBR_M64 , 0, 0],
    'fdiv':     [0, 0, X64_FDIV_M32  , X64_FDIV_M64  , 0, 0],
    'fdivr':    [0, 0, X64_FDIVR_M32 , X64_FDIVR_M64 , 0, 0],

    'fnstsw':   [0, X64_FNSTSW_M16, 0, 0, 0, 0], # m16
    'fstsw':    [0, X64_FSTSW_M16 , 0, 0, 0, 0], # m16
    'fldcw':    [0, X64_FLDCW     , 0, 0, 0, 0], # m16
    'fnstcw':   [0, X64_FNSTCW    , 0, 0, 0, 0], # m16
    'fstcw':    [0, X64_FSTCW     , 0, 0, 0, 0], # m16

    'fldenv':   [0, 0, 0, 0, 0, X64_FLDENV  ], # m224
    'fldenvd':  [0, 0, 0, 0, 0, X64_FLDENV  ], # m224
    'fnstenv':  [0, 0, 0, 0, 0, X64_FNSTENV ], # m224
    'frstor':   [0, 0, 0, 0, 0, X64_FRSTOR  ], # m864
    'frstord':  [0, 0, 0, 0, 0, X64_FRSTOR  ], # m864
    'fnsave':   [0, 0, 0, 0, 0, X64_FNSAVE  ], # m864

    'fldenvw':  [0, 0, 0, 0, 0, X64_FLDENVW ], # m112
    'fnstenvw': [0, 0, 0, 0, 0, X64_FNSTENVW], # m112
    'frstorw':  [0, 0, 0, 0, 0, X64_FRSTORW ], # m752
    'fnsavew':  [0, 0, 0, 0, 0, X64_FNSAVEW ], # m752
    'fnstenvw': [0, 0, 0, 0, 0, X64_FNSTENVW], # m112
    'frstorw':  [0, 0, 0, 0, 0, X64_FRSTORW ], # m752
    'fnsavew':  [0, 0, 0, 0, 0, X64_FNSAVEW ], # m752

    'fstenv':   [0, 0, 0, 0, 0, X64_FSTENV  ], # m224
    'fstenvd':  [0, 0, 0, 0, 0, X64_FSTENV  ], # m224
    'fsave':    [0, 0, 0, 0, 0, X64_FSAVE   ], # m864
    'fsaved':   [0, 0, 0, 0, 0, X64_FSAVE   ], # m864

    'fstenvw':  [0, 0, 0, 0, 0, X64_FSTENVW ], # m112
    'fsavew':   [0, 0, 0, 0, 0, X64_FSAVEW  ], # m752
    'fxsave':   [0, 0, 0, 0, 0, X64_FXSAVE  ], # m4096
    'fxrstor':  [0, 0, 0, 0, 0, X64_FXRSTOR ]  # m4096
  },
  {
    # Two operands.
    # opcode     st0,sti           , sti,st0
    'fadd':     [X64_FADD_ST0_STI  , X64_FADD_STI_ST0],
    'fmul':     [X64_FMUL_ST0_STI  , X64_FMUL_STI_ST0],
    'fsub':     [X64_FSUB_ST0_STI  , X64_FSUB_STI_ST0],
    'fsubr':    [X64_FSUBR_ST0_STI , X64_FSUBR_STI_ST0],
    'fdiv':     [X64_FDIV_ST0_STI  , X64_FDIV_STI_ST0],
    'fdivr':    [X64_FDIVR_ST0_STI , X64_FDIVR_STI_ST0],

    'faddp':    [0, X64_FADDP_STI_ST0],
    'fmulp':    [0, X64_FMULP_STI_ST0],
    'fsubrp':   [0, X64_FSUBRP_STI_ST0],
    'fsubp':    [0, X64_FSUBP_STI_ST0],
    'fdivrp':   [0, X64_FDIVRP_STI_ST0],
    'fdivp':    [0, X64_FDIVP_STI_ST0],

    'fcmovb':   [X64_FCMOVB   , 0],
    'fcmove':   [X64_FCMOVE   , 0],
    'fcmovbe':  [X64_FCMOVBE  , 0],
    'fcmovu':   [X64_FCMOVU   , 0],
    'fcmovnb':  [X64_FCMOVNB  , 0],
    'fcmovne':  [X64_FCMOVNE  , 0],
    'fcmovnbe': [X64_FCMOVNBE , 0],
    'fcmovnu':  [X64_FCMOVNU  , 0],
    'fcomi':    [X64_FCOMI    , 0],
    'fcomip':   [X64_FCOMIP   , 0],
    'fucomi':   [X64_FUCOMI   , 0],
    'fucomip':  [X64_FUCOMIP  , 0]
  }
]

class X64Translator extends PipeAbstract
  method emitCore_x_y(opcode, item)
    emiter   = this.outputObject
    reg      = item.reg
    regBase  = item.base
    regIndex = item.index
    disp     = item.disp
    scale    = item.scale

    if item.imm is defined
      if reg isnt -1
        # opcode r, imm
        emiter.emitCore_r_imm(opcode, reg, item.imm)
      else
        # opcode m, imm
        emiter.emitCore_m_imm(
          opcode, regBase, scale, regIndex, disp, item.imm, item.dataSize)
      endif

    elif reg isnt -1
      if item.rm isnt -1
        # opcode r, r
        regSrc = item.rm
        emiter.emitCore_r_r(opcode, reg, regSrc)

      elif item.scale is defined
        # opcode r, m
        # opcode m, r
        # opcode m, imm
        if item.imm is defined
          emiter.emitCore_m_imm(opcode, regBase, scale, regIndex, disp, item.imm)

        elif item.isWriteToMemory is true
          emiter.emitCore_m_r(opcode, regBase, scale, regIndex, disp, reg)

        else
          emiter.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)
        endif
      endif
    endif
  endmethod

  method emitCoreALU2(opcode, item)
    # TODO: Review it.
    # Why we need to swap regs here?
    reg = item.reg
    rm  = item.rm

    if (reg isnt -1) and (item.rm isnt -1)
      item.reg = item.rm
      item.rm  = reg
    endif

    this._validateOperandSizes(reg, rm, item.dataSize, item.imm)

    # Recognized common two-operands opcode.
    if item.imm is undefined
      if (X64_IsReg8(item.reg) is true) or (item.dataSize is 1)
        # 8-bit operands. Do nothing.

      elif opcode < 256
        # Set size bit in primary opcode to enable operands
        # greater than 8-bit.
        # This is old encoding pattern from original 8086 processor.
        opcode = opcode + 1

      else
        # 2-byte opcode. Primary opcode is in the higher byte.
        opcode = bitor(opcode, 256)
      endif
    endif

    # Generic two operands handler.
    this.emitCore_x_y(opcode, item)
  endmethod

  method _error(msg)
    die('error: ' ~ msg)
  endmethod

  method _validateNumberOfOperands(cnt, expectedCnt)
    if cnt < expectedCnt
      this._error('not enough operands')
    elif cnt > expectedCnt
      this._error('too many operands')
    endif
  endmethod

  method _validateOperandSizes(reg, rm, dataSize, imm)
    global X64_DATA_SIZE_ID
    regSizeId  = reg // 16
    rmSizeId   = rm  // 16
    dataSizeId = X64_DATA_SIZE_ID[dataSize]

    # TODO: Optimize it.
    if imm is undefined
      # r,r
      # r,m
      # m,r
      if (((rm isnt -1)      and (regSizeId isnt rmSizeId)) or # r,r
         ((dataSize isnt -1) and (regSizeId isnt dataSizeId))) # r,m or m,r
        this._error('operand sizes do not match')
      endif
    else
      this._validateImmRange(reg, rm, dataSize, imm)
    endif
  endmethod

  method _validateImmRange(reg, rm, dataSize, imm)
    global X64_DATA_SIZE_ID

    # TODO: Optimize it.
    if imm is defined
      regSizeId  = reg // 16
      rmSizeId   = rm  // 16
      dataSizeId = X64_DATA_SIZE_ID[dataSize]

      if reg isnt -1
        # r, imm
        if X64_IsReg8(reg) is true
          this._failIfOutOfRange(imm, -127, 255)
        elif X64_IsReg16(reg) is true
          this._failIfOutOfRange(imm, -32767, 65535)
        endif

      elif dataSize isnt -1
        # m, imm
        if dataSize is 1
          this._failIfOutOfRange(imm, -127, 255)
        elif dataSize is 2
          this._failIfOutOfRange(imm, -32767, 65535)
        endif
      endif
    endif
  endmethod

  method _failIf8BitOperandIsUsed(item)
    if ((item.dataSize is 1) or
        ((item.reg isnt -1) and (item.reg // 16 is 0)) or
        ((item.rm isnt -1) and (item.rm // 16 is 0)))
      this._error("8-bit operands not allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfNon8BitOperandIsUsed(item)
    if (((item.scale is defined) and (item.dataSize > 1)) or
        ((item.reg isnt -1) and (item.reg // 16 > 0)) or
        ((item.rm isnt -1) and (item.rm // 16 > 0)))
      this._error("only 8-bit operands are allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfNon16BitOperandIsUsed(item)
    if (((item.scale is defined) and (item.dataSize isnt 2)) or
        ((item.reg isnt -1) and (item.reg // 16 > 1)) or
        ((item.rm isnt -1) and (item.rm // 16 > 1)))
      this._error("only 16-bit operands are allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfMemoryWrite(item)
    if item.isWriteToMemory is true
      this._error("memory address cannot be destination operand for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfMemoryRead(item)
    if item.isWriteToMemory is false
      this._error("memory address cannot be used as the second operand for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfImmIsUsed(item)
    if item.imm is defined
      this._error("immediate operand not allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfMemoryReadOrWrite(item)
    if item.scale is defined
      this._error("memory operands not allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfRegsAreUsed(item)
    if (item.reg isnt -1) or (item.rm isnt -1)
      this._error("register operands not allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfImmIsMissing(item)
    if item.imm is undefined
      this._error("immediate operand expected for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _failIfOutOfRange(x, valueMin, valueMax)
    if (x < valueMin) or (x > valueMax)
      this._error('value out of range')
    endif
  endmethod

  method _failIfNonMMReg(item, reg)
    if X64_IsRegMM(reg) is false
      this._errorBadSyntax(item)
    endif
  endmethod

  method _failIfNon64Data(item)
    if item.dataSize isnt 8
      this._error("only 64-bit data allowed for: '" ~ item.mnemonic ~ "'")
    endif
  endmethod

  method _errorBadSyntax(item)
    this._error("operand does not match the statement for: '" ~ item.mnemonic ~ "'")
  endmethod

  method _errorUnrecognizedInstruction(item)
    this._error("unrecognized instruction: '" ~ item.mnemonic ~ "'")
  endmethod

  method _errorGenericFPU(item)
    global X64_OPCODES_MAP_FPU

    numberOfOperands = item.numberOfOperands
    mnemonic         = item.mnemonic
    opcode0          = X64_OPCODES_MAP_FPU[0]{mnemonic}
    opcode1          = X64_OPCODES_MAP_FPU[1]{mnemonic}
    opcode2          = X64_OPCODES_MAP_FPU[2]{mnemonic}

    if opcode0 is defined
      if ((opcode1 is undefined) and (opcode2 is undefined))
        this._validateNumberOfOperands(numberOfOperands, 0)
      endif

    elif opcode1 is defined
      this._validateNumberOfOperands(numberOfOperands, 1)

    elif opcode2 is defined
      this._validateNumberOfOperands(numberOfOperands, 2)

    else
      this._errorUnrecognizedInstruction(item)
    endif

    this._errorBadSyntax(item)
  endmethod

  method _emitVariableLengthOpcode(opcode)
    encoder = this.outputObject

    if opcode > 0xffff
      # 3 bytes opcode.
      encoder.emitByte(bitand(opcode, 0xff))
      encoder.emitWord(opcode // 256)
    elif opcode > 0xff
      # 2 bytes opcode.
      encoder.emitWord(opcode)
    else
      # 1 byte opcode.
      encoder.emitByte(opcode)
    endif
  endmethod

  method _processFPU(item)
    global X64_OPCODES_MAP_FPU
    global X64_ST0
    global X64_AX
    global X64_DATA_SIZE_ID
    global X64_FNSTSW_AX, X64_FSTSW_AX

    encoder          = this.outputObject
    mnemonic         = item.mnemonic
    reg              = item.reg
    rm               = item.rm
    scale            = item.scale
    dataSize         = item.dataSize
    numberOfOperands = item.numberOfOperands

    if numberOfOperands > 2
      this._error('too many operands')
    endif

    # Search for instruction.
    opcodesMapFPU = X64_OPCODES_MAP_FPU[numberOfOperands]
    opcodeInfoFPU = opcodesMapFPU{mnemonic}
    opcode        = 0

    if opcodeInfoFPU is undefined
      this._errorGenericFPU(item)
    endif

    # FPU opcode with single operand.
    if numberOfOperands is 0
      # opcode without operands
      this._emitVariableLengthOpcode(opcodeInfoFPU)

    else
      if numberOfOperands is 1
        if scale is defined
          # opcode m
          if dataSize is -1
            # Memory operand without word/dword/qword/tword prefix.
            opcode = opcodeInfoFPU[5]
            if opcode is 0
              this._error("ambiguous operand size for: '" ~ mnemonic ~ "'")
            endif

          else
            # Memory operand with word/dword/qword/tword prefix.
            dataSizeId = X64_DATA_SIZE_ID[dataSize]
            opcode     = opcodeInfoFPU[dataSizeId]

            if (opcode is 0) or (dataSize is 1)
              if ((opcodeInfoFPU[1] isnt 0) or # m16
                  (opcodeInfoFPU[2] isnt 0) or # m32
                  (opcodeInfoFPU[3] isnt 0) or # m64
                  (opcodeInfoFPU[4] isnt 0) or # m80
                  (opcodeInfoFPU[5] isnt 0))   # mcustom

                # Instruction can handle memory operand, but not with given size.
                this._error("invalid operand size for: '" ~ mnemonic ~ "'")
              endif
            endif
          endif

        elif reg is X64_AX
          # Special case. There are only two FPU opcodes working with
          # general purpose register.
          if mnemonic is 'fnstsw'
            # fnstsw ax
            opcode = X64_FNSTSW_AX

          elif mnemonic is 'fstsw'
            # fstsw ax
            opcode = X64_FSTSW_AX
          endif

        elif X64_IsRegSTI(reg) is true
          # sti
          opcode = opcodeInfoFPU[0]
        endif

      elif (reg is X64_ST0) and (rm is X64_ST0)
        # st0,st0
        opcode = opcodeInfoFPU[0]
        if opcode is 0
          opcode = opcodeInfoFPU[1]
        endif

      elif (rm is X64_ST0) and (X64_IsRegSTI(reg) is true)
        # sti,st0
        opcode = opcodeInfoFPU[1]

      elif (reg is X64_ST0) and (X64_IsRegSTI(rm) is true)
        # st0,sti
        opcode = opcodeInfoFPU[0]
        reg    = rm
      endif

      # Emit hardcoded prefixes if needed.
      if opcode > 0xffffff
        # 2 byte prefixes.
        encoder.emitWord(bitand(opcode, 0xffff))
        opcode = opcode // 65536

      elif opcode > 0xffff
        # 1 byte prefix.
        encoder.emitByte(bitand(opcode, 0xff))
        opcode = opcode // 256

      elif opcode is 0
        this._errorBadSyntax(item)
      endif

      # Emit opcode.
      if scale is defined
        # opcode m16 | m32 | m64 | m80 | mcustom
        encoder.emitFPU_m(opcode, item.base, scale, item.index, item.disp)

      else
        # opcode sti | st0,sti | sti,st0
        encoder.emitFPU_sti(opcode, reg)
      endif
    endif
  endmethod

  method processOneItem(item)
    global X64_OPCODES_MAP

    global X64_CMPXCHG_RM8_R8, X64_CMPXCHG_RM32_R32, X64_CL, X64_DX
    global X64_XADD_RM8_R8, X64_XADD_RM32_R32, X64_ST0, X64_ST1, X64_AX

    global X64_HANDLER_CORE_ALU1, X64_HANDLER_CORE_ALU2
    global X64_HANDLER_CMOVCC, X64_HANDLER_JCC, X64_HANDLER_JUMPS_REL8
    global X64_HANDLER_JUMPS_REL8_2BYTES, X64_HANDLER_286
    global X64_HANDLER_0F_00_GROUP, X64_HANDLER_0F_01_GROUP
    global X64_HANDLER_SHIFT_GROUP, X64_HANDLER_SETCC, X64_HANDLER_DO_NOTHING
    global X64_HANDLER_INVALID_IN_64, X64_HANDLER_OPCODE_ONLY_0F_XX_YY
    global X64_HANDLER_CUSTOM, X64_HANDLER_OPCODE_ONLY_BYTE
    global X64_HANDLER_OPCODE_ONLY_WORD, X64_HANDLER_MOV_EXTEND
    global X64_HANDLER_OPCODE_ONLY_3BYTES
    global X64_HANDLER_CUSTOM_X, X64_HANDLER_CUSTOM_X_Y
    global X64_HANDLER_CORE_RMD_RD, X64_HANDLER_CORE_RM_R
    global X64_HANDLER_MMX, X64_HANDLER_MMX_SHIFT

    global X64_LEA, X64_MOV, X64_TEST, X64_XCHG, X64_CALL_REL32, X64_NOP
    global X64_IN, X64_OUT, X64_JMP_REL32, X64_PUSH_R64, X64_POP_R64
    global X64_RET, X64_RETF, X64_BSWAP, X64_CMPXCHG8B, X64_CMPXCHG16B
    global X64_INC_R32, X64_DEC_R32, X64_ENTER, X64_LEAVE, X64_INT
    global X64_LSL, X64_MOVSXD, X64_MOVD_MM_RM32, X64_MOVQ_MM_M64
    global X64_PALIGNR, X64_PEXTRW, X64_PINSRW, X64_PMOVMSKB, X64_PSHUFW

    global X64_SYNTAX_ZERO_OPERANDS, X64_SYNTAX_ONE_OPERAND_READ_ONLY
    global X64_SYNTAX_TWO_OPERANDS, X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE
    global X64_SYNTAX_ONE_OPERAND_READWRITE

    encoder = this.outputObject

    if item.type is 'instruction'
      # Parse one code line.
      # Fetch instruction info.
      mnemonic = item.mnemonic

      if mnemonic[0] is 'f'
        # Escape to FPU (x87) handler.
        this._processFPU(item)

      else
        # General case.
        # Search for mnemonic.
        opcodeInfo = X64_OPCODES_MAP{mnemonic}

        if opcodeInfo is defined
          # Decode handler and opcode.
          opcode    = bitand(opcodeInfo, 0x00ffffff)
          handlerId = bitand(opcodeInfo, 0xff000000)
          syntaxId  = bitand(opcodeInfo, 0xf0000000)

          reg              = item.reg
          rm               = item.rm
          regBase          = item.base
          regIndex         = item.index
          disp             = item.disp
          scale            = item.scale
          imm              = item.imm
          dataSize         = item.dataSize
          numberOfOperands = item.numberOfOperands

          # Generic syntax checking for most common rules.
          if syntaxId is X64_SYNTAX_ZERO_OPERANDS
            this._validateNumberOfOperands(numberOfOperands, 0)

          elif syntaxId is X64_SYNTAX_ONE_OPERAND_READ_ONLY
            this._validateNumberOfOperands(numberOfOperands, 1)

          elif syntaxId is X64_SYNTAX_ONE_OPERAND_READWRITE
            this._validateNumberOfOperands(numberOfOperands, 1)
            this._failIfImmIsUsed(item)

          elif syntaxId is X64_SYNTAX_TWO_OPERANDS_EQUAL_SIZE
            this._validateNumberOfOperands(numberOfOperands, 2)
            this._validateOperandSizes(reg, rm, dataSize, imm)
            this._validateImmRange(reg, rm, dataSize, imm)

          elif syntaxId is X64_SYNTAX_TWO_OPERANDS
            this._validateNumberOfOperands(numberOfOperands, 2)
          endif

          # Only mov can handle 64-bit immediate.
          if (imm is defined) and (opcode isnt X64_MOV)
            this._failIfOutOfRange(imm, -2147483647, 4294967295)
          endif

          # Dispatch opcode handler.
          if handlerId is X64_HANDLER_OPCODE_ONLY_BYTE
            # Single byte opcode without operands: xx
            # Just emit opcode as is.
            encoder.emitByte(opcode)

          elif handlerId is X64_HANDLER_OPCODE_ONLY_WORD
            # Two bytes opcode without operands: xx yy
            # Just emit opcode as is.
            encoder.emitWord(opcode)

          elif handlerId is X64_HANDLER_OPCODE_ONLY_3BYTES
            # Three bytes opcode without operands: xx yy zz
            # Just emit opcode as is.
            print hex(opcode)
            encoder.emitByte(bitand(opcode, 0xff))
            encoder.emitWord(opcode // 256)

          elif handlerId is X64_HANDLER_OPCODE_ONLY_0F_XX_YY
            # Three bytes opcode without operands: 0f xx yy
            # Just emit opcode as is.
            encoder.emitByte(0x0f)
            encoder.emitWord(opcode)

          elif handlerId is X64_HANDLER_CORE_ALU1
            if reg is -1
              # not/neg/mul/div/imul/idiv m
              encoder.emitCore_unaryGroup_m(opcode, regBase, scale, regIndex, disp, dataSize)
            else
              # not/neg/mul/div/imul/idiv r
              encoder.emitCore_unaryGroup_r(opcode, reg)
            endif

          elif handlerId is X64_HANDLER_CORE_ALU2
            this.emitCoreALU2(opcode, item)

          elif handlerId is X64_HANDLER_CMOVCC
            this._failIfMemoryWrite(item)
            this._failIf8BitOperandIsUsed(item)
            this._failIfImmIsUsed(item)
            this.emitCore_x_y(opcode, item)

          elif handlerId is X64_HANDLER_JCC
            # jcc rel8/32
            this._failIfImmIsMissing(item)
            encoder.emitCore_jcc_rel(opcode, imm - item.offset)

          elif handlerId is X64_HANDLER_JUMPS_REL8
            # One byte jump with rel8 always.
            # loopz rel8 like.
            this._failIfImmIsMissing(item)
            rel8 = imm - item.offset - 2
            # TODO: Check range.
            # this._failIfOutOfRange(rel8, -127, 128)
            encoder.emitCore_jmp_rel8(opcode, rel8)

          elif handlerId is X64_HANDLER_JUMPS_REL8_2BYTES
            # One byte jump with rel8 always and 0x67 prefix.
            # loopz rel8 like.
            # TODO: Clean up this mess.
            this._failIfImmIsMissing(item)
            rel8 = imm - item.offset - 3
            # TODO: Check range.
            # this._failIfOutOfRange(rel8, -127, 128)
            encoder.emitByte(0x67)
            encoder.emitCore_jmp_rel8(opcode, rel8)

          elif handlerId is X64_HANDLER_SHIFT_GROUP
            regCL = -1

            if scale is defined
              this._failIfMemoryRead(item)
              if imm is defined
                # m, imm8
                this._failIfOutOfRange(imm, -127, 255)
                encoder.emitCore_shiftGroup_m_imm8(opcode, regBase, scale, regIndex, disp, imm, dataSize)
              else
                # m, cl
                encoder.emitCore_shiftGroup_m_cl(opcode, regBase, scale, regIndex, disp, dataSize)
                regCL = reg
              endif

            elif imm is defined
              # r, imm8
              this._failIfOutOfRange(imm, -127, 255)
              encoder.emitCore_shiftGroup_r_imm8(opcode, reg, imm)
            else
              # r, cl
              encoder.emitCore_shiftGroup_r_cl(opcode, reg)
              regCL = rm
            endif

            if (regCL isnt -1) and (regCL isnt X64_CL)
              this._error("only imm8 or the cl register can be used as the second operand for: '" ~ mnemonic ~ "'")
            endif

          elif handlerId is X64_HANDLER_SETCC
            this._failIfNon8BitOperandIsUsed(item)
            if scale is defined
              # setcc m8
              encoder.emitCore_m(opcode, regBase, scale, regIndex, disp)
            else
              # setcc r8
              encoder.emitCore_r(opcode, reg)
            endif

          elif handlerId is X64_HANDLER_MOV_EXTEND
            this._failIfImmIsUsed(item)
            this._failIfMemoryWrite(item)
            if scale is defined
              # movsx r16/32/64, m8/16
              # movzx r16/32/64, m8/16
              if (dataSize > 2) or (reg // 16 <= dataSize - 1)
                # Destination must be wider than source.
                this._errorBadSyntax(item)
              endif

              # TODO: Bad result with -O1 for:
              # x = bitor(x, 256)
              if dataSize is 2
                finalOpcode = bitor(opcode, 256)
              else
                finalOpcode = opcode
              endif

              encoder.emitCore_movExtend_r_m(finalOpcode, reg, regBase, scale, regIndex, disp)

            else
              # movsx r16/32/64, r8/16
              # movzx r16/32/64, r8/16
              if (rm >= 32) or ((reg // 16) <= (rm // 16))
                # Destination must be wider than source.
                this._errorBadSyntax(item)
              endif

              encoder.emitCore_movExtend_r_r(opcode, reg, rm)
            endif

          elif handlerId is X64_HANDLER_CORE_RMD_RD
            this._failIf8BitOperandIsUsed(item)
            this._failIfMemoryRead(item)
            this._failIfImmIsUsed(item)
            this.emitCoreALU2(opcode, item)

          elif handlerId is X64_HANDLER_CORE_RM_R
            this._failIfMemoryRead(item)
            this._failIfImmIsUsed(item)
            this.emitCoreALU2(opcode, item)

          elif handlerId is X64_HANDLER_DO_NOTHING
            # Do nothing.

          elif handlerId is X64_HANDLER_CUSTOM_X_Y
            # Custom handler for two operands opcode
            # opcode x,y
            if opcode is X64_MOV
              if imm is defined
                this._validateImmRange(reg, rm, dataSize, imm)
                if reg isnt -1
                  # mov r, imm
                  encoder.mov_r_imm(reg, imm)
                else
                  # mov m, imm
                  encoder.mov_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
                endif
              else
                this.emitCoreALU2(opcode, item)
              endif

            elif opcode is X64_LEA
              this._failIfMemoryWrite(item)
              this._failIfImmIsUsed(item)

              if X64_IsReg8(reg) is true
                this._errorBadSyntax(item)
              endif

              encoder.lea_r_m(reg, regBase, scale, regIndex, disp)

            elif opcode is X64_TEST
              if imm is defined
                this._validateImmRange(reg, rm, dataSize, imm)
                if reg isnt -1
                  # test r, imm
                  encoder.test_r_imm(reg, imm)
                else
                  # test m, imm
                  encoder.test_m_imm(regBase, scale, regIndex, disp, imm, dataSize)
                endif
              else
                # Opcodes have fixed diretion flag, but other assemblers accept both and
                # swap operands silently if needed.
                # Only test r/m, r/imm exists.
                item.isWriteToMemory = true
                this.emitCoreALU2(opcode, item)
              endif

            elif opcode is X64_XCHG
              this._validateOperandSizes(reg, rm, dataSize, imm)
              this._failIfImmIsUsed(item)

              if (reg isnt -1) and (rm isnt -1)
                # xchg r, r
                encoder.xchg_r_r(reg, rm)
              else
                # Opcodes have fixed diretion flag, but other assemblers accept both and
                # swap operands silently if needed.
                # Only xchg r, r/m exists.
                item.isWriteToMemory = false
                this.emitCoreALU2(opcode, item)
              endif

            elif opcode is X64_OUT
              this._failIfMemoryReadOrWrite(item)
              if imm is defined
                this._failIfOutOfRange(imm, 0, 255)
                encoder.out_imm_r(imm, reg)
              elif reg is X64_DX
                encoder.out_dx_r(rm)
              else
                this._error("port must be imm8 or dx register for: 'out'")
              endif

            elif opcode is X64_IN
              this._failIfMemoryReadOrWrite(item)
              if imm is defined
                this._failIfOutOfRange(imm, 0, 255)
                encoder.in_r_imm(reg, imm)
              elif rm is X64_DX
                encoder.in_r_dx(reg)
              else
                this._error("port must be imm8 or dx register for: 'in'")
              endif

            elif opcode is X64_LSL
              this._failIfMemoryWrite(item)
              this._failIf8BitOperandIsUsed(item)
              this._failIfImmIsUsed(item)

              if (scale is defined) and (dataSize isnt 2)
                this._errorBadSyntax(item)
              endif
              this.emitCore_x_y(opcode, item)

            elif opcode is X64_MOVSXD
              # movsxd r64, r/m32
              this._failIfMemoryWrite(item)
              this._failIfImmIsUsed(item)

              if ((X64_IsReg64(reg) is false) or
                  ((rm isnt -1) and (X64_IsReg32(rm) is false)) or
                  ((dataSize isnt -1) and (dataSize isnt 4)))
                this._errorBadSyntax(item)
              endif

              this.emitCore_x_y(opcode, item)

            elif opcode is X64_ENTER
              # enter imm16, imm8
              if (imm is undefined) or (item.imm2 is undefined)
                this._error("two immediate operands are expected for: 'enter'")
              endif
              this._failIfOutOfRange(imm,       0, 65535)
              this._failIfOutOfRange(item.imm2, 0, 255)
              encoder.enter_imm16_imm8(imm, item.imm2)

            elif opcode is X64_MOVD_MM_RM32
              this._failIfImmIsUsed(item)

              if (scale is defined) and (X64_IsRegMM(reg) is true) and (dataSize is 4)
                # movd m32, mm
                # movd mm, m32

                if item.isWriteToMemory is true
                  # movd m32, mm
                  encoder.movd_m32_mm(regBase, scale, regIndex, disp, reg)
                else
                  # movd mm, m32
                  encoder.movd_mm_m32(reg, regBase, scale, regIndex, disp)
                endif

              elif (X64_IsReg32(reg) is true) and (X64_IsRegMM(rm) is true)
                # movd r32,mm
                encoder.movd_r32_mm(reg, rm)

              elif (X64_IsRegMM(reg) is true) and (X64_IsReg32(rm) is true)
                # movd mm,r32
                encoder.movd_mm_r32(reg, rm)

              else
                # Syntax syntax.
                this._errorBadSyntax(item)
              endif

            elif opcode is X64_MOVQ_MM_M64
              this._failIfImmIsUsed(item)

              if (scale is defined) and (dataSize is 8) and (X64_IsRegMM(reg) is true)
                if item.isWriteToMemory is true
                  # movd m64,mm
                  encoder.movq_m64_mm(regBase, scale, regIndex, disp, reg)
                else
                  # movd mm,m64
                  encoder.movq_mm_m64(reg, regBase, scale, regIndex, disp)
                endif

              elif (X64_IsRegMM(reg) is true) and (X64_IsRegMM(rm) is true)
                # movq mm,mm
                encoder.movq_mm_mm(reg, rm)

              elif (X64_IsReg64(reg) is true) and (X64_IsRegMM(rm) is true)
                # movd r64,mm
                encoder.movq_r64_mm(reg, rm)

              elif (X64_IsRegMM(reg) is true) and (X64_IsReg64(rm) is true)
                # movd mm,r64
                encoder.movq_mm_r64(reg, rm)

              else
                # Syntax error.
                this._errorBadSyntax(item)
              endif
            endif

          elif handlerId is X64_HANDLER_CUSTOM_X
            # Custom handler for one operand opcode
            # opcode x
            if opcode is X64_PUSH_R64
              if reg isnt -1
                # push r
                encoder.push_r(reg)

              elif imm is defined
                if (imm >= -127) and (imm <= 128)
                  # push imm8
                  encoder.push_imm8(imm)
                else
                  # push imm32
                  this._failIfOutOfRange(imm, -32767, 65535)
                  encoder.push_imm32(imm)
                 endif
              else
                # push m
                encoder.push_m(regBase, scale, regIndex, disp, dataSize)
              endif

            elif opcode is X64_POP_R64
              this._failIfImmIsUsed(item)
              if reg isnt -1
                encoder.pop_r(reg)
              else
                encoder.pop_m(regBase, scale, regIndex, disp, dataSize)
              endif

            elif opcode is X64_CALL_REL32
              if reg isnt -1
                # call r
                if (X64_IsReg8(reg) is true) or (X64_IsReg32(reg) is true)
                  this._error("8/32-bit addresses not allowed for: '" ~ item.mnemonic ~ "'")
                endif
                encoder.call_r(reg)

              elif scale is defined
                # call m
                if (dataSize is 1) or (dataSize is 4)
                  this._error("8/32-bit addresses not allowed for: '" ~ item.mnemonic ~ "'")
                endif

                encoder.call_m(regBase, scale, regIndex, disp, dataSize)

              else
                # call rel32
                encoder.call_rel(imm - item.offset)
              endif

            elif opcode is X64_JMP_REL32
              if reg isnt -1
                # jmp r
                if (X64_IsReg8(reg) is true) or (X64_IsReg32(reg) is true)
                  this._error("8/32-bit addresses not allowed for: '" ~ item.mnemonic ~ "'")
                endif
                encoder.jmp_r(reg)
              elif scale is defined
                # jmp m
                if (dataSize is 1) or (dataSize is 4)
                  this._error("8/32-bit addresses not allowed for: '" ~ item.mnemonic ~ "'")
                endif
                encoder.jmp_m(regBase, scale, regIndex, disp, dataSize)
              else
                # jmp rel8/32
                encoder.jmp_rel(imm - item.offset)
              endif

            elif opcode is X64_BSWAP
              this._failIfMemoryReadOrWrite(item)
              this._failIfImmIsUsed(item)
              if reg < 32
                this._errorBadSyntax(item)
              endif

              encoder.bswap_r(reg)

            elif opcode is X64_CMPXCHG8B
              this._failIfImmIsUsed(item)
              this._failIfRegsAreUsed(item)

              # TODO: Don't compare strings.
              if mnemonic is 'cmpxchg8b'
                encoder.cmpxchg8b_m(regBase, scale, regIndex, disp)
              else
                encoder.cmpxchg16b_m(regBase, scale, regIndex, disp)
              endif

            elif opcode is X64_INC_R32
              this._failIfImmIsUsed(item)
              if reg isnt -1
                # inc r
                encoder.inc_r(reg)
              else
                # inc m
                encoder.inc_m(regBase, scale, regIndex, disp, dataSize)
              endif

            elif opcode is X64_DEC_R32
              this._failIfImmIsUsed(item)
              if reg isnt -1
                # dec r
                encoder.dec_r(reg)
              else
                # dec m
                encoder.dec_m(regBase, scale, regIndex, disp, dataSize)
              endif

            elif opcode is X64_INT
              # int imm8
              this._failIfImmIsMissing(item)
              this._failIfOutOfRange(imm, 0, 255)
              encoder.int_imm(imm)
            endif

          elif handlerId is X64_HANDLER_MMX
            this._failIfImmIsUsed(item)
            this._failIfNonMMReg(item, reg)

            if scale is defined
              # mm,m64
              this._failIfMemoryWrite(item)
              this._failIfNon64Data(item)
              encoder.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)

            elif rm is defined
              # mm,mm
              this._failIfNonMMReg(item, rm)
              encoder.emitCore_r_r(opcode, reg, rm)
            endif

          elif handlerId is X64_HANDLER_MMX_SHIFT
            this._failIfNonMMReg(item, reg)

            if imm is defined
              # mm,imm
              # TODO: Clean up this mess.
              this._failIfOutOfRange(imm, 0, 255)

              operationId = opcode // 65536
              opcode      = bitand(opcode, 0xfff) + 0x7000
              encoder.emitCore_r_r(opcode, operationId, reg)
              encoder.emitByte(imm)

            elif scale is defined
              # mm,m64
              this._failIfMemoryWrite(item)
              this._failIfNon64Data(item)

              opcode = bitand(opcode, 0xffff)
              encoder.emitCore_r_m(opcode, reg, regBase, scale, regIndex, disp)

            elif rm is defined
              # mm,mm
              this._failIfNonMMReg(item, rm)
              opcode = bitand(opcode, 0xffff)
              encoder.emitCore_r_r(opcode, reg, rm)
            endif

          elif handlerId is X64_HANDLER_CUSTOM
            # Custom handler for opcodes with variable numberof operands.
            # Dispatch opcode.
            if opcode is X64_RET
              if numberOfOperands is 0
                encoder.ret()
              else
                this._validateNumberOfOperands(numberOfOperands, 1)
                this._failIfImmIsMissing(item)
                this._failIfOutOfRange(imm, 0, 65535)
                encoder.ret_imm(imm)
              endif

            elif opcode is X64_RETF
              if numberOfOperands is 0
                encoder.retf()
              else
                this._validateNumberOfOperands(numberOfOperands, 1)
                this._failIfImmIsMissing(item)
                this._failIfOutOfRange(imm, 0, 65535)
                encoder.retf_imm(imm)
              endif

            elif opcode is X64_NOP
              if numberOfOperands is 0
                # One byte nop.
                this._validateNumberOfOperands(numberOfOperands, 0)
                encoder.nop()

              else
                # Muli-byte nop.
                this._validateNumberOfOperands(numberOfOperands, 1)
                this._failIfImmIsUsed(item)
                this._failIf8BitOperandIsUsed(item)

                if scale is defined
                  # nop m
                  encoder.nop_m(regBase, scale, regIndex, disp, dataSize)
                elif reg isnt -1
                  # nop r
                  encoder.nop_r(reg)
                endif
              endif

            elif opcode is X64_PALIGNR
              this._validateNumberOfOperands(numberOfOperands, 3)
              this._failIfImmIsMissing(item)
              this._failIfNonMMReg(item, reg)
              this._failIfOutOfRange(imm, 0, 255)

              if scale is defined
                # palignr mm, m64, imm8
                this._failIfMemoryWrite(item)
                this._failIfNon64Data(item)
                encoder.palignr_mm_m64_imm8(reg, regBase, scale, regIndex, disp, imm)

              else
                # palignr mm, mm, imm8
                this._failIfNonMMReg(item, rm)
                encoder.palignr_mm_mm_imm8(reg, rm, imm)
              endif

            elif opcode is X64_PEXTRW
              # pextrw r32, mm
              # pextrw r64, mm
              this._validateNumberOfOperands(numberOfOperands, 3)
              this._failIfMemoryReadOrWrite(item)
              this._failIfImmIsMissing(item)
              this._failIfNonMMReg(item, rm)
              this._failIfOutOfRange(imm, 0, 255)

              if (X64_IsReg32(reg) is false) and (X64_IsReg64(reg) is false)
                # Dest operand must be r32 or r64.
                this._errorBadSyntax(item)
              endif

              encoder.pextrw_r64_mm_imm8(reg, rm, imm)

            elif opcode is X64_PINSRW
              this._validateNumberOfOperands(numberOfOperands, 3)
              this._failIfMemoryWrite(item)
              this._failIfImmIsMissing(item)
              this._failIfNonMMReg(item, reg)
              this._failIfOutOfRange(imm, 0, 255)

              if scale is defined
                # pinsrw mm, m16, imm8
                if dataSize isnt 2
                  this._errorBadSyntax(item)
                endif
                encoder.pinsrw_mm_m16_imm8(reg, regBase, scale, regIndex, disp, imm)
              else
                # pinsrw mm, r32, imm8
                if X64_IsReg32(rm) is false
                  this._errorBadSyntax(item)
                endif
                encoder.pinsrw_mm_r32_imm8(reg, rm, imm)
              endif

            elif opcode is X64_PMOVMSKB
              # pmovmskb r32, mm
              # pmovmskb r64, mm
              this._validateNumberOfOperands(numberOfOperands, 2)
              this._failIfMemoryReadOrWrite(item)
              this._failIfImmIsUsed(item)

              if (X64_IsReg32(reg) is false) and (X64_IsReg64(reg) is false)
                # Dest operand must be r32 or r64.
                this._errorBadSyntax(item)
              endif

              this._failIfNonMMReg(item, rm)

              encoder.pmovmskb_r_mm(reg, rm)

            elif opcode is X64_PSHUFW
              this._validateNumberOfOperands(numberOfOperands, 3)
              this._failIfImmIsMissing(item)
              this._failIfNonMMReg(item, reg)
              this._failIfOutOfRange(imm, 0, 255)

              if scale is defined
                # pshufw mm, m64, imm8
                this._failIfMemoryWrite(item)
                this._failIfNon64Data(item)
                encoder.pshufw_mm_m64_imm8(reg, regBase, scale, regIndex, disp, imm)
              else
                # pshufw mm, mm, imm8
                this._failIfNonMMReg(item, rm)
                encoder.pshufw_mm_mm_imm8(reg, rm, imm)
              endif

            endif

          elif handlerId is X64_HANDLER_286
            this._failIfMemoryWrite(item)
            this._failIf8BitOperandIsUsed(item)
            this._failIfImmIsUsed(item)

            if scale is defined
              # r,m
              encoder.emitCore286_r_m(opcode, reg, regBase, scale, regIndex, disp)
            else
              # r,r
              encoder.emitCore286_r_r(opcode, reg, rm)
            endif

          elif handlerId is X64_HANDLER_0F_00_GROUP
            this._failIf8BitOperandIsUsed(item)
            # 0f 00 /x
            if scale is defined
              # m
              encoder.emitCore_group0f_00_m(opcode, regBase, scale, regIndex, disp)
            else
              # r
              encoder.emitCore_group0f_00_r(opcode, reg)
            endif

          elif handlerId is X64_HANDLER_0F_01_GROUP
            # 0f 01 /x
            if scale is defined
              # m
              encoder.emitCore_group0f_01_m(opcode, regBase, scale, regIndex, disp)
            else
              # r
              encoder.emitCore_group0f_01_r(opcode, reg)
            endif

          elif handlerId is X64_HANDLER_INVALID_IN_64
            # Instruction is correct, but not allowed in native 64-bit mode.
            this._error("invalid in 64-bit mode: '" ~ mnemonic ~ "'")

          else
            # Error - unexpected handler id.
            # Should never happen on production.
            this._error('unknown opcode handler: ' ~ str(handlerId))
          endif

        else
          this._errorUnrecognizedInstruction(item)
        endif
      endif

    elif item.type is 'label'
      # Collect label positions.
      this.labelsMap[item.name] = encoder.getCurrentPosition()

    elif item.type is 'data'
      if item.dataSize is 1
        encoder.emitByte(item.imm)
      elif item.dataSize is 2
        encoder.emitWord(item.imm)
      elif item.dataSize is 4
        encoder.emitDword(item.imm)
      elif item.dataSize is 8
        encoder.emitQword(item.imm)
      endif
    endif
  endmethod

  method getCurrentPosition() -> rv
    # TODO: Clean up this mess.
    rv = this.outputObject.getCurrentPosition()
  endmethod
endclass
