# ------------------------------------------------------------------------------
#                                 One byte opcodes
# ------------------------------------------------------------------------------

X86_ADD                     = 0x00 # 00-05 add
X86_PUSH_ES                 = 0x06 # 06    push es
X86_POP_ES                  = 0x07 # 07    pop es
X86_OR                      = 0x08 # 08-0d or
X86_PUSH_CS                 = 0x0e # 0e    push cs
X86_PREFIX_TWO_BYTES_OPCODE = 0x0f # 0f    2-byte opcode prefix
X86_ADC                     = 0x10 # 10-15 adc
X86_PUSH_SS                 = 0x16 # 16    push ss
X86_POP_SS                  = 0x17 # 17    pop ss
X86_SBB                     = 0x18 # 18-1d sbb
X86_PUSH_DS                 = 0x1e # 1e    push ds
X86_POP_DS                  = 0x1f # 1f    pop ds
X86_AND                     = 0x20 # 20-25 and
X86_SUB                     = 0x28 # 28-2d sub
X86_PREFIX_SEG_CS           = 0x2e # 2e    seg=cs prefix
X86_DAS                     = 0x2f # 2f    das (invalid in 64-bit)
X86_XOR                     = 0x30 # 30-35 xor
X86_CMP                     = 0x38 # 38-3d cmp
X86_PREFIX_SEG_DS           = 0x3e # 3e    seg=ds prefix
X86_AAS                     = 0x3f # 3f    aas (invalid in 64-bit)
X86_INC_R32                 = 0x40 # 40-47 inc r32 (invalid in 64-bit)
X86_DEC_R32                 = 0x48 # 48-4f dec r32 (invalid in 64-bit)
X86_PUSH_R64                = 0x50 # 50-57 push r64
X86_POP_R64                 = 0x58 # 58-5f pop r64
X86_PUSHA                   = 0x60 # 60    pusha / pushad
X86_POPA                    = 0x61 # 61    popa / popad
X86_BOUND                   = 0x62 # 62    bound (invalid in 64-bit)
X86_MOVSXD_R32_RM32         = 0x63 # 63    arpl / movsxd r32, r/m32
X86_PREFIX_SEG_FS           = 0x64 # 64    seg fs prefix
X86_PREFIX_SEG_GS           = 0x65 # 65    seg gs prefix
X86_PREFIX_OPERAND_SIZE     = 0x66 # 66    operand size prefix
X86_PREFIX_ADDRESS_SIZE     = 0x67 # 67    address size prefix
X86_PUSH_IMM32              = 0x68 # 68    push imm32
X86_IMUL_R32_RM32_IMM32     = 0x69 # 69    imul r32, r/m32, imm32
X86_PUSH_IMM8               = 0x6a # 6a    push imm8
X86_IMUL_R32_RM32_IMM8      = 0x6b # 6b    imul r32, r/m32, imm8
X86_INSB                    = 0x6c # 6c    insb
X86_INSD                    = 0x6d # 6d    insw/d/q
X86_OUTSB                   = 0x6e # 6e    outsb
X86_OUTSD                   = 0x6f # 6f    outsw/d/q
X86_JXX                     = 0x70 # 70-7f jxx
X86_JO                      = 0x70 # 70    jo
X86_JNO                     = 0x71 # 71    jno
X86_JB                      = 0x72 # 72    jb, jnae, jc
X86_JAE                     = 0x73 # 73    jnb, jae, jnc
X86_JZ                      = 0x74 # 74    jz, je
X86_JNZ                     = 0x75 # 75    jnz, jne
X86_JBE                     = 0x76 # 76    jbe, jna
X86_JA                      = 0x77 # 77    jnbe, ja
X86_JS                      = 0x78 # 78    js
X86_JNS                     = 0x79 # 79    jns
X86_JP                      = 0x7a # 7a    jp, jpe
X86_JNP                     = 0x7b # 7b    jnp, jpo
X86_JL                      = 0x7c # 7c    jl, jnge
X86_JGE                     = 0x7d # 7d    jnl, jge
X86_JLE                     = 0x7e # 7e    jle, jng
X86_JG                      = 0x7f # 7f    jnle, jg
X86_ALU_RM8_IMM8_GROUP      = 0x80 # 80    add/or/adc/sbb/and/sub/xor/cmp r/m8, imm8
X86_ALU_RM32_IMM32_GROUP    = 0x81 # 81    add/or/adc/sbb/and/sub/xor/cmp r/m32, imm32
X86_INVALID_OPCODE_82       = 0x82 # 82    invalid opcode
X86_ALU_RM32_IMM8_GROUP     = 0x83 # 83    add/or/adc/sbb/and/sub/xor/cmp r/m32, imm8
X86_TEST_RM8_R8             = 0x84 # 84    test r/m8, r8
X86_TEST_RM32_R32           = 0x85 # 85    test r/m32, r32
X86_XCHG_RM8_R8             = 0x86 # 86    xchg r/m8, r8
X86_XCHG_RM32_R32           = 0x87 # 87    xchg r/m32, r32
X86_MOV_RM8_R8              = 0x88 # 88    mov r/m8, r8
X86_MOV_RM32_R32            = 0x89 # 89    mov r/m32, r32
X86_MOV_R8_RM8              = 0x8a # 8a    mov r8, r/m8
X86_MOV_R32_RM32            = 0x8b # 8b    mov r32, r/m32
X86_MOV_RM16_SEG            = 0x8c # 8c    mov r/m16, seg
X86_LEA_R32_M64             = 0x8d # 8d    lea r32, m64
X86_MOV_SEG_RM16            = 0x8e # 8e    mov seg, r/m16
X86_POP_RM64                = 0x8f # 8f    pop r/m64
X86_NOP                     = 0x90 # 90    nop
X86_XCHG_EAX_R32            = 0x90 # 90-97 xchg eax, r32
X86_CWDE                    = 0x98 # 98    cbw / cwde / cdqe
X86_CDQ                     = 0x99 # 99    cwd / cdq / cqo
X86_CALLF                   = 0x9a # 9a    call ptr16:32 (invalid in 64-bit)
X86_FWAIT                   = 0x9b # 9b    fwait
X86_PUSHF                   = 0x9c # 9c    pushf
X86_POPF                    = 0x9d # 9d    popf
X86_SAHF                    = 0x9e # 9e    sahf (invalid in 64-bit)
X86_LAHF                    = 0x9f # 9f    lahf (invalid in 64-bit)
X86_MOV_AL_M8               = 0xa0 # a0    mov al, moffs8
X86_MOV_EAX_M32             = 0xa1 # a1    mov eax, moffs32
X86_MOV_M8_AL               = 0xa2 # a2    mov moffs8, al
X86_MOV_M32_EAX             = 0xa3 # a3    mov moffs32, eax
X86_MOVSB                   = 0xa4 # a4    movsb
X86_MOVSD                   = 0xa5 # a5    movsw/d/q
X86_CMPSB                   = 0xa6 # a6    cmpsb
X86_CMPSD                   = 0xa7 # a7    cmpsw/d/q
X86_TEST_AL_IMM8            = 0xa8 # a8    test al, imm8
X86_TEST_EAX_IMM32          = 0xa9 # a9    test eax, imm32
X86_STOSB                   = 0xaa # aa    stosb
X86_STOSD                   = 0xab # ab    stosw/d/q
X86_LODSB                   = 0xac # ac    lodsb
X86_LODSD                   = 0xad # ad    lodsw/d/q
X86_SCASB                   = 0xae # ae    scasb
X86_SCASD                   = 0xaf # af    scasw/d/q
X86_MOV_R8_IMM8             = 0xb0 # b0-b7 mov r8, imm8
X86_MOV_R32_IMM32           = 0xb8 # b8-bf mov r32, imm32
X86_SHIFT_RM8_IMM8_GROUP    = 0xc0 # c0    rol/ror/rcl/rcr/shl/rhr/sar r/m8, imm8
X86_SHIFT_RM32_IMM32_GROUP  = 0xc1 # c1    rol/ror/rcl/rcr/shl/rhr/sar r/m32, imm8
X86_RETN                    = 0xc2 # c2    near retn
X86_RET                     = 0xc3 # c3    near ret
X86_LES_R32_MFAR32          = 0xc4 # c4    les r32, m16:32 (invalid in 64-bit)
X86_LDS_R32_MFAR32          = 0xc5 # c5    lds r32, m16:32 (invalid in 64-bit)
X86_MOV_RM8_IMM8            = 0xc6 # c6    mov r/m8, imm8
X86_MOV_RM32_IMM32          = 0xc7 # c7    mov r/m32, imm32
X86_ENTER_IMM16_IMM8        = 0xc8 # c8    enter imm16, imm8
X86_LEAVE                   = 0xc9 # c9    leave
X86_RETFN                   = 0xca # ca    far retn
X86_RETF                    = 0xcb # cb    far ret
X86_INT3                    = 0xcc # cc    int3
X86_INT_IMM8                = 0xcd # cd    int imm8
X86_INT0                    = 0xce # ce    into
X86_IRET                    = 0xcf # cf    iret
X86_SHIFT_RM8_1_GROUP       = 0xd0 # d0    rol/ror/rcl/rcr/shl/rhr/sar r/m8, 1
X86_SHIFT_RM32_1_GROUP      = 0xd1 # d1    rol/ror/rcl/rcr/shl/rhr/sar r/m32, 1
X86_SHIFT_RM8_CL_GROUP      = 0xd2 # d2    rol/ror/rcl/rcr/shl/rhr/sar r/m8, cl
X86_SHIFT_RM32_CL_GROUP     = 0xd3 # d3    rol/ror/rcl/rcr/shl/rhr/sar r/m32, cl
X86_AAM                     = 0xd4 # d4    aam (invalid in 64-bit)
X86_AAD                     = 0xd5 # d5    aad (invalid in 64-bit)
X86_INVALID_OPCODE_D6       = 0xd6 # d6    invalid opcode
X86_XLAT                    = 0xd7 # d7    xlatb
X86_ESC_X87                 = 0xd8 # d8-df esc (escape to x87)
X86_LOOPNZ_REL8             = 0xe0 # e0    loopnz rel8
X86_LOOPZ_REL8              = 0xe1 # e1    loopz rel8
X86_LOOP_REL8               = 0xe2 # e2    loop rel8
X86_JRCXZ_REL8              = 0xe3 # e3    jrcxz rel8
X86_IN_AL_IMM8              = 0xe4 # e4    in al, imm8
X86_IN_EAX_IMM8             = 0xe5 # e5    in eax, imm8
X86_OUT_IMM8_AL             = 0xe6 # e6    out imm8, al
X86_OUT_IMM8_EAX            = 0xe7 # e7    out imm8, eax
X86_CALL_REL32              = 0xe8 # e8    call rel32
X86_JMP_REL32               = 0xe9 # e9    jmp rel32
X86_JMP_PTR32_FAR           = 0xea # ea    jmp ptr16:32 (invalid in 64-bit)
X86_JMP_REL8                = 0xeb # eb    jmp rel8
X86_IN_AL_DX                = 0xec # ec    in al, dx
X86_IN_EAX_DX               = 0xed # ed    in eax, dx
X86_OUT_DX_AL               = 0xee # ee    out dx, al
X86_OUT_DX_EAX              = 0xef # ef    out dx, eax
X86_PREFIX_LOCK             = 0xf0 # f0    lock prefix
X86_INT1                    = 0xf1 # f1    int1
X86_PREFIX_REPNE            = 0xf2 # f2    repne prefix
X86_PREFIX_REPE             = 0xf3 # f3    repe prefix
X86_HLT                     = 0xf4 # f4    hlt
X86_CMC                     = 0xf5 # f5    cmc
X86_UNARY8_GROUP            = 0xf6 # f6    test/not/neg/mul/imul/div/idiv (8-bit)
X86_UNARY32_GROUP           = 0xf7 # f7    test/not/neg/mul/imul/div/idiv (32-bit)
X86_CLC                     = 0xf8 # f8    clc
X86_STC                     = 0xf9 # f9    stc
X86_CLI                     = 0xfa # fa    cli
X86_STI                     = 0xfb # fb    sti
X86_CLD                     = 0xfc # fc    cld
X86_STD                     = 0xfd # fd    std
X86_INC_DEC_RM8_GROUP       = 0xfe # fe    inc/dec r/m8
X86_INC_DEC_RM32_GROUP      = 0xff # ff    inc/dec r/m32
X86_CALL_GROUP              = 0xff # ff    call

# Not a real opcodes, but aliases for generic
# emit_r_r() like dispatchers.
# Example:
#   emit_r_r(X86_MOV, X86_RAX, X86_RCX)

X86_MOV  = 1000
X86_TEST = 1001
X86_NOT  = 1002
X86_NEG  = 1003
X86_INC  = 1004
X86_DEC  = 1005
X86_PUSH = 1006
X86_POP  = 1007
X86_XCHG = 1008

# ------------------------------------------------------------------------------
#                                  Registers
# ------------------------------------------------------------------------------

# Registers: 8-bit
X86_AL   = 0
X86_CL   = 1
X86_DL   = 2
X86_BL   = 3
X86_AH   = 4
X86_CH   = 5
X86_DH   = 6
X86_BH   = 7
X86_R8L  = 8
X86_R9L  = 9
X86_R10L = 10
X86_R11L = 11
X86_R12L = 12
X86_R13L = 13
X86_R14L = 14
X86_R15L = 15

# Registers: 16-bit
X86_AX   = 16 + 0
X86_CX   = 16 + 1
X86_DX   = 16 + 2
X86_BX   = 16 + 3
X86_SP   = 16 + 4
X86_BP   = 16 + 5
X86_SI   = 16 + 6
X86_DI   = 16 + 7
X86_R8W  = 16 + 8
X86_R9W  = 16 + 9
X86_R10W = 16 + 10
X86_R11W = 16 + 11
X86_R12W = 16 + 12
X86_R13W = 16 + 13
X86_R14W = 16 + 14
X86_R15W = 16 + 15

# Registers: 32-bit
X86_EAX  = 16 * 2 + 0
X86_ECX  = 16 * 2 + 1
X86_EDX  = 16 * 2 + 2
X86_EBX  = 16 * 2 + 3
X86_ESP  = 16 * 2 + 4
X86_EBP  = 16 * 2 + 5
X86_ESI  = 16 * 2 + 6
X86_EDI  = 16 * 2 + 7
X86_R8D  = 16 * 2 + 8
X86_R9D  = 16 * 2 + 9
X86_R10D = 16 * 2 + 10
X86_R11D = 16 * 2 + 11
X86_R12D = 16 * 2 + 12
X86_R13D = 16 * 2 + 13
X86_R14D = 16 * 2 + 14
X86_R15D = 16 * 2 + 15

# Registers: 64-bit
X86_RAX = 16 * 3 + 0
X86_RCX = 16 * 3 + 1
X86_RDX = 16 * 3 + 2
X86_RBX = 16 * 3 + 3
X86_RSP = 16 * 3 + 4
X86_RBP = 16 * 3 + 5
X86_RSI = 16 * 3 + 6
X86_RDI = 16 * 3 + 7
X86_R8  = 16 * 3 + 8
X86_R9  = 16 * 3 + 9
X86_R10 = 16 * 3 + 10
X86_R11 = 16 * 3 + 11
X86_R12 = 16 * 3 + 12
X86_R13 = 16 * 3 + 13
X86_R14 = 16 * 3 + 14
X86_R15 = 16 * 3 + 15

# ------------------------------------------------------------------------------
#                              Mod-Reg-R/M byte
# ------------------------------------------------------------------------------

# http://www.c-jump.com/CIS77/CPU/x86/lecture.html
X86_MOD_INDIRECT = 0
X86_MOD_DISP8    = 1
X86_MOD_DISP32   = 2
X86_MOD_REGISTER = 3

X86_DIRECTION_SRC_DST      = 0
X86_DIRECTION_DST_SRC      = 1
X86_DIRECTION_WRITE_MEMORY = 0
X86_DIRECTION_READ_MEMORY  = 1

X86_SIZE8        = 0
X86_SIZE16_32_64 = 1

# R/M = RSP = Scaled Index Base (SIB) Mode
X86_RM_SIB_MODE = 4

# ------------------------------------------------------------------------------
#                          Scaled Index Byte (SIB)
# ------------------------------------------------------------------------------

X86_SCALE1 = 0
X86_SCALE2 = 1
X86_SCALE4 = 2
X86_SCALE8 = 3
