################################################################################
#                                                                              #
# This file is part of Mold project.                                           #
# Copyright (C) 2015, 2019 Sylwester Wysocki <sw143@wp.pl>                     #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program. If not, see <http://www.gnu.org/licenses/>          #
#                                                                              #
################################################################################

import 'ParserAssemblerX64.mold'
import 'TranslatorAssemblerX64.mold'
import 'MachineEncoderX64.mold'

arrayOfTests = [
  'core/add_r_r',
  'core/or_r_r',
  'core/adc_r_r',
  'core/sbb_r_r',
  'core/and_r_r',
  'core/sub_r_r',
  'core/xor_r_r',
  'core/cmp_r_r',
  'core/test_r_r',
  'core/mov_r_r',
  'core/add_r_m',
  'core/or_r_m',
  'core/adc_r_m',
  'core/sbb_r_m',
  'core/and_r_m',
  'core/sub_r_m',
  'core/xor_r_m',
  'core/cmp_r_m',
  'core/test_r_m',
  'core/mov_r_m',
  'core/add_m_r',
  'core/or_m_r',
  'core/adc_m_r',
  'core/sbb_m_r',
  'core/and_m_r',
  'core/sub_m_r',
  'core/xor_m_r',
  'core/cmp_m_r',
  'core/test_m_r',
  'core/mov_m_r',
  'core/add_r_imm',
  'core/or_r_imm',
  'core/adc_r_imm',
  'core/sbb_r_imm',
  'core/and_r_imm',
  'core/sub_r_imm',
  'core/xor_r_imm',
  'core/cmp_r_imm',
  'core/test_r_imm',
  'core/mov_r_imm',
  'core/add_m_imm',
  'core/or_m_imm',
  'core/adc_m_imm',
  'core/sbb_m_imm',
  'core/and_m_imm',
  'core/sub_m_imm',
  'core/xor_m_imm',
  'core/cmp_m_imm',
  'core/test_m_imm',
  'core/mov_m_imm',
  'core/xchg_r_r',
  'core/xchg_r_m',
  'core/xchg_m_r'
]

class TesterAssemblerX64
  method constructor()
    this.f              = false
    this.parser         = new ParserAssemblerX64()
    this.translator     = new TranslatorAssemblerX64()
    this.machineEncoder = new MachineEncoderX64()

    # Set up toolchain.
    # We want to catch generated code by this object.
    this.parser.connectTo(this.translator).connectTo(this.machineEncoder).connectTo(this)
  endmethod

  method compare(x, y)
    if x isnt y
      die(' FAIL! (data mismatch, got: ' + hex(x) + ', expected: ' + hex(y) + ')')
    endif
  endmethod

  method emitByte(x)
    this.compare(x, readByte(this.f))
  endmethod

  method emitWord(x)
    this.compare(x, readWord(this.f))
  endmethod

  method emitDword(x)
    this.compare(x, readDword(this.f))
  endmethod

  method emitQword(x)
    this.compare(x, readQword(this.f))
  endmethod

  method compileSourceFile(pathAsm, pathBin)
    # Open binary file to compare result.
    __mold_printToStdOutput(pathAsm + '...')
    this.f = open('tests/' + pathBin, 'r')
    this.parser.parseFile('tests/' + pathAsm)

    # TODO: Compare number of bytes emited.
    if ord(readChar(this.f)) isnt 0
      die('FAIL! (too less data)')
    endif

    close(this.f)

    print ' OK'
    endmethod
endclass

tester = new TesterAssemblerX64()

for values testName in arrayOfTests
  pathAsm = testName + '.asm'
  pathBin = testName + '.bin'
  tester.compileSourceFile(pathAsm, pathBin)
endfor
